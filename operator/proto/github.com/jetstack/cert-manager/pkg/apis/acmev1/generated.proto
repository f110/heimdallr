// Generated by: gen-go-to-protobuf
syntax = "proto3";
package github.com.jetstack.cert_manager.pkg.apis.acmev1;
option  go_package              = "github.com/jetstack/cert-manager/pkg/apis/acme/v1";
option (dev.f110.kubeproto.k8s) = {
  sub_group: "cert-manager.io",
  version: "v1",
};

import "kube.proto";
import "operator/proto/github.com/jetstack/cert-manager/pkg/apis/metav1/generated.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";

enum ACMEChallengeType {
  ACME_CHALLENGE_TYPE_HTTP_01 = 0 [(dev.f110.kubeproto.value) = { value: "HTTP-01" }];
  ACME_CHALLENGE_TYPE_DNS_01  = 1 [(dev.f110.kubeproto.value) = { value: "DNS-01" }];
}

enum AzureDNSEnvironment {
  AZURE_DNS_ENVIRONMENT_AZURE_PUBLIC_CLOUD         = 0;
  AZURE_DNS_ENVIRONMENT_AZURE_CHINA_CLOUD          = 1;
  AZURE_DNS_ENVIRONMENT_AZURE_GERMAN_CLOUD         = 2;
  AZURE_DNS_ENVIRONMENT_AZURE_U_S_GOVERNMENT_CLOUD = 3;
}

enum HMACKeyAlgorithm {
  HMAC_KEY_ALGORITHM_H_S256 = 0;
  HMAC_KEY_ALGORITHM_H_S384 = 1;
  HMAC_KEY_ALGORITHM_H_S512 = 2;
}

enum State {
  STATE_UNKNOWN    = 0 [(dev.f110.kubeproto.value) = { value: "" }];
  STATE_VALID      = 1 [(dev.f110.kubeproto.value) = { value: "valid" }];
  STATE_READY      = 2 [(dev.f110.kubeproto.value) = { value: "ready" }];
  STATE_PENDING    = 3 [(dev.f110.kubeproto.value) = { value: "pending" }];
  STATE_PROCESSING = 4 [(dev.f110.kubeproto.value) = { value: "processing" }];
  STATE_INVALID    = 5 [(dev.f110.kubeproto.value) = { value: "invalid" }];
  STATE_EXPIRED    = 6 [(dev.f110.kubeproto.value) = { value: "expired" }];
  STATE_ERRORED    = 7 [(dev.f110.kubeproto.value) = { value: "errored" }];
}

message ACMEAuthorization {
  // URL is the URL of the Authorization that must be completed
  string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // Identifier is the DNS name to be validated as part of this authorization
  optional string identifier = 2 [(dev.f110.kubeproto.field) = { go_name: "Identifier", api_field_name: "identifier", inline: false }];
  // Wildcard will be true if this authorization is for a wildcard DNS name.
  // If this is true, the identifier will be the *non-wildcard* version of
  // the DNS name.
  // For example, if '*.example.com' is the DNS name being validated, this
  // field will be 'true' and the 'identifier' field will be 'example.com'.
  optional bool wildcard = 3 [(dev.f110.kubeproto.field) = { go_name: "Wildcard", api_field_name: "wildcard", inline: false }];
  // InitialState is the initial state of the ACME authorization when first
  // fetched from the ACME server.
  // If an Authorization is already 'valid', the Order controller will not
  // create a Challenge resource for the authorization. This will occur when
  // working with an ACME server that enables 'authz reuse' (such as Let's
  // Encrypt's production endpoint).
  // If not set and 'identifier' is set, the state is assumed to be pending
  // and a Challenge will be created.
  optional State initial_state = 4 [(dev.f110.kubeproto.field) = { go_name: "InitialState", api_field_name: "initialState", inline: false }];
  // Challenges specifies the challenge types offered by the ACME server.
  // One of these challenge types will be selected when validating the DNS
  // name and an appropriate Challenge resource will be created to perform
  // the ACME challenge process.
  repeated ACMEChallenge challenges = 5 [(dev.f110.kubeproto.field) = { go_name: "Challenges", api_field_name: "challenges", inline: false }];
}

message ACMEChallenge {
  // URL is the URL of this challenge. It can be used to retrieve additional
  // metadata about the Challenge from the ACME server.
  string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // Token is the token that must be presented for this challenge.
  // This is used to compute the 'key' that must also be presented.
  string token = 2 [(dev.f110.kubeproto.field) = { go_name: "Token", api_field_name: "token", inline: false }];
  // Type is the type of challenge being offered, e.g. 'http-01', 'dns-01',
  // 'tls-sni-01', etc.
  // This is the raw value retrieved from the ACME server.
  // Only 'http-01' and 'dns-01' are supported by cert-manager, other values
  // will be ignored.
  string type = 3 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
}

message ACMEChallengeSolver {
  // Selector selects a set of DNSNames on the Certificate resource that
  // should be solved using this challenge solver.
  // If not specified, the solver will be treated as the 'default' solver
  // with the lowest priority, i.e. if any other solver has a more specific
  // match, it will be used instead.
  optional CertificateDNSNameSelector selector = 1 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // Configures cert-manager to attempt to complete authorizations by
  // performing the HTTP01 challenge flow.
  // It is not possible to obtain certificates for wildcard domain names
  // (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
  optional ACMEChallengeSolverHTTP01 http_01 = 2 [(dev.f110.kubeproto.field) = { go_name: "HTTP01", api_field_name: "http01", inline: false }];
  // Configures cert-manager to attempt to complete authorizations by
  // performing the DNS01 challenge flow.
  optional ACMEChallengeSolverDNS01 dns_01 = 3 [(dev.f110.kubeproto.field) = { go_name: "DNS01", api_field_name: "dns01", inline: false }];
}

message ACMEChallengeSolverDNS01 {
  // CNAMEStrategy configures how the DNS01 provider should handle CNAME
  // records when found in DNS zones.
  string c_n_a_m_e_strategy = 1 [(dev.f110.kubeproto.field) = { go_name: "CNAMEStrategy", api_field_name: "cnameStrategy", inline: false }];
  // Use the Akamai DNS zone management API to manage DNS01 challenge records.
  optional ACMEIssuerDNS01ProviderAkamai akamai = 2 [(dev.f110.kubeproto.field) = { go_name: "Akamai", api_field_name: "akamai", inline: false }];
  // Use the Google Cloud DNS API to manage DNS01 challenge records.
  optional ACMEIssuerDNS01ProviderCloudDNS cloud_dns = 3 [(dev.f110.kubeproto.field) = { go_name: "CloudDNS", api_field_name: "cloudDNS", inline: false }];
  // Use the Cloudflare API to manage DNS01 challenge records.
  optional ACMEIssuerDNS01ProviderCloudflare cloudflare = 4 [(dev.f110.kubeproto.field) = { go_name: "Cloudflare", api_field_name: "cloudflare", inline: false }];
  // Use the AWS Route53 API to manage DNS01 challenge records.
  optional ACMEIssuerDNS01ProviderRoute53 route53 = 5 [(dev.f110.kubeproto.field) = { go_name: "Route53", api_field_name: "route53", inline: false }];
  // Use the Microsoft Azure DNS API to manage DNS01 challenge records.
  optional ACMEIssuerDNS01ProviderAzureDNS azure_dns = 6 [(dev.f110.kubeproto.field) = { go_name: "AzureDNS", api_field_name: "azureDNS", inline: false }];
  // Use the DigitalOcean DNS API to manage DNS01 challenge records.
  optional ACMEIssuerDNS01ProviderDigitalOcean digital_ocean = 7 [(dev.f110.kubeproto.field) = { go_name: "DigitalOcean", api_field_name: "digitalocean", inline: false }];
  // Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
  // DNS01 challenge records.
  optional ACMEIssuerDNS01ProviderAcmeDNS acme_dns = 8 [(dev.f110.kubeproto.field) = { go_name: "AcmeDNS", api_field_name: "acmeDNS", inline: false }];
  // Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
  // to manage DNS01 challenge records.
  optional ACMEIssuerDNS01ProviderRFC2136 r_fc_2136 = 9 [(dev.f110.kubeproto.field) = { go_name: "RFC2136", api_field_name: "rfc2136", inline: false }];
  // Configure an external webhook based DNS01 challenge solver to manage
  // DNS01 challenge records.
  optional ACMEIssuerDNS01ProviderWebhook webhook = 10 [(dev.f110.kubeproto.field) = { go_name: "Webhook", api_field_name: "webhook", inline: false }];
}

message ACMEChallengeSolverHTTP01 {
  // The ingress based HTTP01 challenge solver will solve challenges by
  // creating or modifying Ingress resources in order to route requests for
  // '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
  // provisioned by cert-manager for each Challenge to be completed.
  optional ACMEChallengeSolverHTTP01Ingress ingress = 1 [(dev.f110.kubeproto.field) = { go_name: "Ingress", api_field_name: "ingress", inline: false }];
  // The Gateway API is a sig-network community API that models service networking
  // in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
  // create HTTPRoutes with the specified labels in the same namespace as the challenge.
  // This solver is experimental, and fields / behaviour may change in the future.
  optional ACMEChallengeSolverHTTP01GatewayHTTPRoute gateway_http_route = 2 [(dev.f110.kubeproto.field) = { go_name: "GatewayHTTPRoute", api_field_name: "gatewayHTTPRoute", inline: false }];
}

message ACMEChallengeSolverHTTP01GatewayHTTPRoute {
  // Optional service type for Kubernetes solver service. Supported values
  // are NodePort or ClusterIP. If unset, defaults to NodePort.
  optional .k8s.io.api.core.v1.ServiceType service_type = 1 [(dev.f110.kubeproto.field) = { go_name: "ServiceType", api_field_name: "serviceType", inline: false }];
  // The labels that cert-manager will use when creating the temporary
  // HTTPRoute needed for solving the HTTP-01 challenge. These labels
  // must match the label selector of at least one Gateway.
  map<string, string> labels = 2 [(dev.f110.kubeproto.field) = { go_name: "Labels", api_field_name: "labels", inline: false }];
}

message ACMEChallengeSolverHTTP01Ingress {
  // Optional service type for Kubernetes solver service. Supported values
  // are NodePort or ClusterIP. If unset, defaults to NodePort.
  optional .k8s.io.api.core.v1.ServiceType service_type = 1 [(dev.f110.kubeproto.field) = { go_name: "ServiceType", api_field_name: "serviceType", inline: false }];
  // The ingress class to use when creating Ingress resources to solve ACME
  // challenges that use this challenge solver.
  // Only one of 'class' or 'name' may be specified.
  optional string class = 2 [(dev.f110.kubeproto.field) = { go_name: "Class", api_field_name: "class", inline: false }];
  // The name of the ingress resource that should have ACME challenge solving
  // routes inserted into it in order to solve HTTP01 challenges.
  // This is typically used in conjunction with ingress controllers like
  // ingress-gce, which maintains a 1:1 mapping between external IPs and
  // ingress resources.
  optional string name = 3 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Optional pod template used to configure the ACME challenge solver pods
  // used for HTTP01 challenges.
  optional ACMEChallengeSolverHTTP01IngressPodTemplate pod_template = 4 [(dev.f110.kubeproto.field) = { go_name: "PodTemplate", api_field_name: "podTemplate", inline: false }];
  // Optional ingress template used to configure the ACME challenge solver
  // ingress used for HTTP01 challenges.
  optional ACMEChallengeSolverHTTP01IngressTemplate ingress_template = 5 [(dev.f110.kubeproto.field) = { go_name: "IngressTemplate", api_field_name: "ingressTemplate", inline: false }];
}

message ACMEChallengeSolverHTTP01IngressObjectMeta {
  // Annotations that should be added to the created ACME HTTP01 solver ingress.
  map<string, string> annotations = 1 [(dev.f110.kubeproto.field) = { go_name: "Annotations", api_field_name: "annotations", inline: false }];
  // Labels that should be added to the created ACME HTTP01 solver ingress.
  map<string, string> labels = 2 [(dev.f110.kubeproto.field) = { go_name: "Labels", api_field_name: "labels", inline: false }];
}

message ACMEChallengeSolverHTTP01IngressPodObjectMeta {
  // Annotations that should be added to the create ACME HTTP01 solver pods.
  map<string, string> annotations = 1 [(dev.f110.kubeproto.field) = { go_name: "Annotations", api_field_name: "annotations", inline: false }];
  // Labels that should be added to the created ACME HTTP01 solver pods.
  map<string, string> labels = 2 [(dev.f110.kubeproto.field) = { go_name: "Labels", api_field_name: "labels", inline: false }];
}

message ACMEChallengeSolverHTTP01IngressPodSpec {
  // NodeSelector is a selector which must be true for the pod to fit on a node.
  // Selector which must match a node's labels for the pod to be scheduled on that node.
  // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  map<string, string> node_selector = 1 [(dev.f110.kubeproto.field) = { go_name: "NodeSelector", api_field_name: "nodeSelector", inline: false }];
  // If specified, the pod's scheduling constraints
  optional .k8s.io.api.core.v1.Affinity affinity = 2 [(dev.f110.kubeproto.field) = { go_name: "Affinity", api_field_name: "affinity", inline: false }];
  // If specified, the pod's tolerations.
  repeated .k8s.io.api.core.v1.Toleration tolerations = 3 [(dev.f110.kubeproto.field) = { go_name: "Tolerations", api_field_name: "tolerations", inline: false }];
  // If specified, the pod's priorityClassName.
  optional string priority_class_name = 4 [(dev.f110.kubeproto.field) = { go_name: "PriorityClassName", api_field_name: "priorityClassName", inline: false }];
  // If specified, the pod's service account
  optional string service_account_name = 5 [(dev.f110.kubeproto.field) = { go_name: "ServiceAccountName", api_field_name: "serviceAccountName", inline: false }];
}

message ACMEChallengeSolverHTTP01IngressPodTemplate {
  // ObjectMeta overrides for the pod used to solve HTTP01 challenges.
  // Only the 'labels' and 'annotations' fields may be set.
  // If labels or annotations overlap with in-built values, the values here
  // will override the in-built values.
  ACMEChallengeSolverHTTP01IngressPodObjectMeta acme_challenge_solver_http_01_ingress_pod_object_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "ACMEChallengeSolverHTTP01IngressPodObjectMeta", api_field_name: "metadata", inline: false }];
  // PodSpec defines overrides for the HTTP01 challenge solver pod.
  // Only the 'priorityClassName', 'nodeSelector', 'affinity',
  // 'serviceAccountName' and 'tolerations' fields are supported currently.
  // All other fields will be ignored.
  ACMEChallengeSolverHTTP01IngressPodSpec spec = 2 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
}

message ACMEChallengeSolverHTTP01IngressTemplate {
  // ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
  // Only the 'labels' and 'annotations' fields may be set.
  // If labels or annotations overlap with in-built values, the values here
  // will override the in-built values.
  ACMEChallengeSolverHTTP01IngressObjectMeta acme_challenge_solver_http_01_ingress_object_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "ACMEChallengeSolverHTTP01IngressObjectMeta", api_field_name: "metadata", inline: false }];
}

message ACMEExternalAccountBinding {
  // keyID is the ID of the CA key that the External Account is bound to.
  string key_id = 1 [(dev.f110.kubeproto.field) = { go_name: "KeyID", api_field_name: "keyID", inline: false }];
  // keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes
  // Secret which holds the symmetric MAC key of the External Account Binding.
  // The `key` is the index string that is paired with the key data in the
  // Secret and should not be confused with the key data itself, or indeed with
  // the External Account Binding keyID above.
  // The secret key stored in the Secret **must** be un-padded, base64 URL
  // encoded data.
  .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector key = 2 [(dev.f110.kubeproto.field) = { go_name: "Key", api_field_name: "keySecretRef", inline: false }];
  // Deprecated: keyAlgorithm field exists for historical compatibility
  // reasons and should not be used. The algorithm is now hardcoded to HS256
  // in golang/x/crypto/acme.
  optional HMACKeyAlgorithm key_algorithm = 3 [(dev.f110.kubeproto.field) = { go_name: "KeyAlgorithm", api_field_name: "keyAlgorithm", inline: false }];
}

message ACMEIssuer {
  // Email is the email address to be associated with the ACME account.
  // This field is optional, but it is strongly recommended to be set.
  // It will be used to contact you in case of issues with your account or
  // certificates, including expiry notification emails.
  // This field may be updated after the account is initially registered.
  optional string email = 1 [(dev.f110.kubeproto.field) = { go_name: "Email", api_field_name: "email", inline: false }];
  // Server is the URL used to access the ACME server's 'directory' endpoint.
  // For example, for Let's Encrypt's staging endpoint, you would use:
  // "https://acme-staging-v02.api.letsencrypt.org/directory".
  // Only ACME v2 endpoints (i.e. RFC 8555) are supported.
  string server = 2 [(dev.f110.kubeproto.field) = { go_name: "Server", api_field_name: "server", inline: false }];
  // PreferredChain is the chain to use if the ACME server outputs multiple.
  // PreferredChain is no guarantee that this one gets delivered by the ACME
  // endpoint.
  // For example, for Let's Encrypt's DST crosssign you would use:
  // "DST Root CA X3" or "ISRG Root X1" for the newer Let's Encrypt root CA.
  // This value picks the first certificate bundle in the ACME alternative
  // chains that has a certificate with this value as its issuer's CN
  string preferred_chain = 3 [(dev.f110.kubeproto.field) = { go_name: "PreferredChain", api_field_name: "preferredChain", inline: false }];
  // Enables or disables validation of the ACME server TLS certificate.
  // If true, requests to the ACME server will not have their TLS certificate
  // validated (i.e. insecure connections will be allowed).
  // Only enable this option in development environments.
  // The cert-manager system installed roots will be used to verify connections
  // to the ACME server if this is false.
  // Defaults to false.
  optional bool skip_tls_verify = 4 [(dev.f110.kubeproto.field) = { go_name: "SkipTLSVerify", api_field_name: "skipTLSVerify", inline: false }];
  // ExternalAccountBinding is a reference to a CA external account of the ACME
  // server.
  // If set, upon registration cert-manager will attempt to associate the given
  // external account credentials with the registered ACME account.
  optional ACMEExternalAccountBinding external_account_binding = 5 [(dev.f110.kubeproto.field) = { go_name: "ExternalAccountBinding", api_field_name: "externalAccountBinding", inline: false }];
  // PrivateKey is the name of a Kubernetes Secret resource that will be used to
  // store the automatically generated ACME account private key.
  // Optionally, a `key` may be specified to select a specific entry within
  // the named Secret resource.
  // If `key` is not specified, a default of `tls.key` will be used.
  .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector private_key = 6 [(dev.f110.kubeproto.field) = { go_name: "PrivateKey", api_field_name: "privateKeySecretRef", inline: false }];
  // Solvers is a list of challenge solvers that will be used to solve
  // ACME challenges for the matching domains.
  // Solver configurations must be provided in order to obtain certificates
  // from an ACME server.
  // For more information, see: https://cert-manager.io/docs/configuration/acme/
  repeated ACMEChallengeSolver solvers = 7 [(dev.f110.kubeproto.field) = { go_name: "Solvers", api_field_name: "solvers", inline: false }];
  // Enables or disables generating a new ACME account key.
  // If true, the Issuer resource will *not* request a new account but will expect
  // the account key to be supplied via an existing secret.
  // If false, the cert-manager system will generate a new ACME account key
  // for the Issuer.
  // Defaults to false.
  optional bool disable_account_key_generation = 8 [(dev.f110.kubeproto.field) = { go_name: "DisableAccountKeyGeneration", api_field_name: "disableAccountKeyGeneration", inline: false }];
  // Enables requesting a Not After date on certificates that matches the
  // duration of the certificate. This is not supported by all ACME servers
  // like Let's Encrypt. If set to true when the ACME server does not support
  // it it will create an error on the Order.
  // Defaults to false.
  optional bool enable_duration_feature = 9 [(dev.f110.kubeproto.field) = { go_name: "EnableDurationFeature", api_field_name: "enableDurationFeature", inline: false }];
}

message ACMEIssuerDNS01ProviderAcmeDNS {
  string                                                              host           = 1 [(dev.f110.kubeproto.field) = { go_name: "Host", api_field_name: "host", inline: false }];
  .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector account_secret = 2 [(dev.f110.kubeproto.field) = { go_name: "AccountSecret", api_field_name: "accountSecretRef", inline: false }];
}

message ACMEIssuerDNS01ProviderAkamai {
  string                                                              service_consumer_domain = 1 [(dev.f110.kubeproto.field) = { go_name: "ServiceConsumerDomain", api_field_name: "serviceConsumerDomain", inline: false }];
  .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector client_token            = 2 [(dev.f110.kubeproto.field) = { go_name: "ClientToken", api_field_name: "clientTokenSecretRef", inline: false }];
  .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector client_secret           = 3 [(dev.f110.kubeproto.field) = { go_name: "ClientSecret", api_field_name: "clientSecretSecretRef", inline: false }];
  .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector access_token            = 4 [(dev.f110.kubeproto.field) = { go_name: "AccessToken", api_field_name: "accessTokenSecretRef", inline: false }];
}

message ACMEIssuerDNS01ProviderAzureDNS {
  // if both this and ClientSecret are left unset MSI will be used
  optional string client_id = 1 [(dev.f110.kubeproto.field) = { go_name: "ClientID", api_field_name: "clientID", inline: false }];
  // if both this and ClientID are left unset MSI will be used
  optional .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector client_secret = 2 [(dev.f110.kubeproto.field) = { go_name: "ClientSecret", api_field_name: "clientSecretSecretRef", inline: false }];
  // ID of the Azure subscription
  string subscription_id = 3 [(dev.f110.kubeproto.field) = { go_name: "SubscriptionID", api_field_name: "subscriptionID", inline: false }];
  // when specifying ClientID and ClientSecret then this field is also needed
  optional string tenant_id = 4 [(dev.f110.kubeproto.field) = { go_name: "TenantID", api_field_name: "tenantID", inline: false }];
  // resource group the DNS zone is located in
  string resource_group_name = 5 [(dev.f110.kubeproto.field) = { go_name: "ResourceGroupName", api_field_name: "resourceGroupName", inline: false }];
  // name of the DNS zone that should be used
  optional string hosted_zone_name = 6 [(dev.f110.kubeproto.field) = { go_name: "HostedZoneName", api_field_name: "hostedZoneName", inline: false }];
  // name of the Azure environment (default AzurePublicCloud)
  optional AzureDNSEnvironment environment = 7 [(dev.f110.kubeproto.field) = { go_name: "Environment", api_field_name: "environment", inline: false }];
  // managed identity configuration, can not be used at the same time as clientID, clientSecretSecretRef or tenantID
  optional AzureManagedIdentity managed_identity = 8 [(dev.f110.kubeproto.field) = { go_name: "ManagedIdentity", api_field_name: "managedIdentity", inline: false }];
}

message ACMEIssuerDNS01ProviderCloudDNS {
  optional .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector service_account = 1 [(dev.f110.kubeproto.field) = { go_name: "ServiceAccount", api_field_name: "serviceAccountSecretRef", inline: false }];
  string                                                                       project         = 2 [(dev.f110.kubeproto.field) = { go_name: "Project", api_field_name: "project", inline: false }];
  // HostedZoneName is an optional field that tells cert-manager in which
  // Cloud DNS zone the challenge record has to be created.
  // If left empty cert-manager will automatically choose a zone.
  optional string hosted_zone_name = 3 [(dev.f110.kubeproto.field) = { go_name: "HostedZoneName", api_field_name: "hostedZoneName", inline: false }];
}

message ACMEIssuerDNS01ProviderCloudflare {
  // Email of the account, only required when using API key based authentication.
  optional string email = 1 [(dev.f110.kubeproto.field) = { go_name: "Email", api_field_name: "email", inline: false }];
  // API key to use to authenticate with Cloudflare.
  // Note: using an API token to authenticate is now the recommended method
  // as it allows greater control of permissions.
  optional .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector api_key = 2 [(dev.f110.kubeproto.field) = { go_name: "APIKey", api_field_name: "apiKeySecretRef", inline: false }];
  // API token used to authenticate with Cloudflare.
  optional .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector api_token = 3 [(dev.f110.kubeproto.field) = { go_name: "APIToken", api_field_name: "apiTokenSecretRef", inline: false }];
}

message ACMEIssuerDNS01ProviderDigitalOcean {
  .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector token = 1 [(dev.f110.kubeproto.field) = { go_name: "Token", api_field_name: "tokenSecretRef", inline: false }];
}

message ACMEIssuerDNS01ProviderRFC2136 {
  // The IP address or hostname of an authoritative DNS server supporting
  // RFC2136 in the form host:port. If the host is an IPv6 address it must be
  // enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
  // This field is required.
  string nameserver = 1 [(dev.f110.kubeproto.field) = { go_name: "Nameserver", api_field_name: "nameserver", inline: false }];
  // The name of the secret containing the TSIG value.
  // If ``tsigKeyName`` is defined, this field is required.
  optional .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector t_s_i_g_secret = 2 [(dev.f110.kubeproto.field) = { go_name: "TSIGSecret", api_field_name: "tsigSecretSecretRef", inline: false }];
  // The TSIG Key name configured in the DNS.
  // If ``tsigSecretSecretRef`` is defined, this field is required.
  optional string t_s_i_g_key_name = 3 [(dev.f110.kubeproto.field) = { go_name: "TSIGKeyName", api_field_name: "tsigKeyName", inline: false }];
  // The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
  // when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
  // Supported values are (case-insensitive): ``HMACMD5`` (default),
  // ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
  optional string t_s_i_g_algorithm = 4 [(dev.f110.kubeproto.field) = { go_name: "TSIGAlgorithm", api_field_name: "tsigAlgorithm", inline: false }];
}

message ACMEIssuerDNS01ProviderRoute53 {
  // The AccessKeyID is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata
  // see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
  optional string access_key_id = 1 [(dev.f110.kubeproto.field) = { go_name: "AccessKeyID", api_field_name: "accessKeyID", inline: false }];
  // The SecretAccessKey is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata
  // https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
  .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector secret_access_key = 2 [(dev.f110.kubeproto.field) = { go_name: "SecretAccessKey", api_field_name: "secretAccessKeySecretRef", inline: false }];
  // Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
  // or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
  optional string role = 3 [(dev.f110.kubeproto.field) = { go_name: "Role", api_field_name: "role", inline: false }];
  // If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
  optional string hosted_zone_id = 4 [(dev.f110.kubeproto.field) = { go_name: "HostedZoneID", api_field_name: "hostedZoneID", inline: false }];
  // Always set the region when using AccessKeyID and SecretAccessKey
  string region = 5 [(dev.f110.kubeproto.field) = { go_name: "Region", api_field_name: "region", inline: false }];
}

message ACMEIssuerDNS01ProviderWebhook {
  // The API group name that should be used when POSTing ChallengePayload
  // resources to the webhook apiserver.
  // This should be the same as the GroupName specified in the webhook
  // provider implementation.
  string group_name = 1 [(dev.f110.kubeproto.field) = { go_name: "GroupName", api_field_name: "groupName", inline: false }];
  // The name of the solver to use, as defined in the webhook provider
  // implementation.
  // This will typically be the name of the provider, e.g. 'cloudflare'.
  string solver_name = 2 [(dev.f110.kubeproto.field) = { go_name: "SolverName", api_field_name: "solverName", inline: false }];
  // Additional configuration that should be passed to the webhook apiserver
  // when challenges are processed.
  // This can contain arbitrary JSON data.
  // Secret values should not be specified in this stanza.
  // If secret values are needed (e.g. credentials for a DNS service), you
  // should use a SecretKeySelector to reference a Secret resource.
  // For details on the schema of this field, consult the webhook provider
  // implementation's documentation.
  optional .k8s.io.apiextensions_apiserver.pkg.apis.apiextensions.v1.JSON config = 3 [(dev.f110.kubeproto.field) = { go_name: "Config", api_field_name: "config", inline: false }];
}

message ACMEIssuerStatus {
  // URI is the unique account identifier, which can also be used to retrieve
  // account details from the CA
  optional string uri = 1 [(dev.f110.kubeproto.field) = { go_name: "URI", api_field_name: "uri", inline: false }];
  // LastRegisteredEmail is the email associated with the latest registered
  // ACME account, in order to track changes made to registered account
  // associated with the  Issuer
  optional string last_registered_email = 2 [(dev.f110.kubeproto.field) = { go_name: "LastRegisteredEmail", api_field_name: "lastRegisteredEmail", inline: false }];
}

message AzureManagedIdentity {
  // client ID of the managed identity, can not be used at the same time as resourceID
  optional string client_id = 1 [(dev.f110.kubeproto.field) = { go_name: "ClientID", api_field_name: "clientID", inline: false }];
  // resource ID of the managed identity, can not be used at the same time as clientID
  optional string resource_id = 2 [(dev.f110.kubeproto.field) = { go_name: "ResourceID", api_field_name: "resourceID", inline: false }];
}

message CertificateDNSNameSelector {
  // A label selector that is used to refine the set of certificate's that
  // this challenge solver will apply to.
  map<string, string> match_labels = 1 [(dev.f110.kubeproto.field) = { go_name: "MatchLabels", api_field_name: "matchLabels", inline: false }];
  // List of DNSNames that this solver will be used to solve.
  // If specified and a match is found, a dnsNames selector will take
  // precedence over a dnsZones selector.
  // If multiple solvers match with the same dnsNames value, the solver
  // with the most matching labels in matchLabels will be selected.
  // If neither has more matches, the solver defined earlier in the list
  // will be selected.
  repeated string dns_names = 2 [(dev.f110.kubeproto.field) = { go_name: "DNSNames", api_field_name: "dnsNames", inline: false }];
  // List of DNSZones that this solver will be used to solve.
  // The most specific DNS zone match specified here will take precedence
  // over other DNS zone matches, so a solver specifying sys.example.com
  // will be selected over one specifying example.com for the domain
  // www.sys.example.com.
  // If multiple solvers match with the same dnsZones value, the solver
  // with the most matching labels in matchLabels will be selected.
  // If neither has more matches, the solver defined earlier in the list
  // will be selected.
  repeated string dns_zones = 3 [(dev.f110.kubeproto.field) = { go_name: "DNSZones", api_field_name: "dnsZones", inline: false }];
}

message Challenge {
  ChallengeSpec   spec   = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  ChallengeStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ChallengeList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated Challenge                             items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ChallengeSpec {
  // The URL of the ACME Challenge resource for this challenge.
  // This can be used to lookup details about the status of this challenge.
  string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // The URL to the ACME Authorization resource that this
  // challenge is a part of.
  string authorization_url = 2 [(dev.f110.kubeproto.field) = { go_name: "AuthorizationURL", api_field_name: "authorizationURL", inline: false }];
  // dnsName is the identifier that this challenge is for, e.g. example.com.
  // If the requested DNSName is a 'wildcard', this field MUST be set to the
  // non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
  string dns_name = 3 [(dev.f110.kubeproto.field) = { go_name: "DNSName", api_field_name: "dnsName", inline: false }];
  // wildcard will be true if this challenge is for a wildcard identifier,
  // for example '*.example.com'.
  bool wildcard = 4 [(dev.f110.kubeproto.field) = { go_name: "Wildcard", api_field_name: "wildcard", inline: false }];
  // The type of ACME challenge this resource represents.
  // One of "HTTP-01" or "DNS-01".
  ACMEChallengeType type = 5 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // The ACME challenge token for this challenge.
  // This is the raw value returned from the ACME server.
  string token = 6 [(dev.f110.kubeproto.field) = { go_name: "Token", api_field_name: "token", inline: false }];
  // The ACME challenge key for this challenge
  // For HTTP01 challenges, this is the value that must be responded with to
  // complete the HTTP01 challenge in the format:
  // `<private key JWK thumbprint>.<key from acme server for challenge>`.
  // For DNS01 challenges, this is the base64 encoded SHA256 sum of the
  // `<private key JWK thumbprint>.<key from acme server for challenge>`
  // text that must be set as the TXT record content.
  string key = 7 [(dev.f110.kubeproto.field) = { go_name: "Key", api_field_name: "key", inline: false }];
  // Contains the domain solving configuration that should be used to
  // solve this challenge resource.
  ACMEChallengeSolver solver = 8 [(dev.f110.kubeproto.field) = { go_name: "Solver", api_field_name: "solver", inline: false }];
  // References a properly configured ACME-type Issuer which should
  // be used to create this Challenge.
  // If the Issuer does not exist, processing will be retried.
  // If the Issuer is not an 'ACME' Issuer, an error will be returned and the
  // Challenge will be marked as failed.
  .github.com.jetstack.cert_manager.pkg.apis.metav1.ObjectReference issuer_ref = 9 [(dev.f110.kubeproto.field) = { go_name: "IssuerRef", api_field_name: "issuerRef", inline: false }];
}

message ChallengeStatus {
  // Used to denote whether this challenge should be processed or not.
  // This field will only be set to true by the 'scheduling' component.
  // It will only be set to false by the 'challenges' controller, after the
  // challenge has reached a final state or timed out.
  // If this field is set to false, the challenge controller will not take
  // any more action.
  bool processing = 1 [(dev.f110.kubeproto.field) = { go_name: "Processing", api_field_name: "processing", inline: false }];
  // presented will be set to true if the challenge values for this challenge
  // are currently 'presented'.
  // This *does not* imply the self check is passing. Only that the values
  // have been 'submitted' for the appropriate challenge mechanism (i.e. the
  // DNS01 TXT record has been presented, or the HTTP01 configuration has been
  // configured).
  bool presented = 2 [(dev.f110.kubeproto.field) = { go_name: "Presented", api_field_name: "presented", inline: false }];
  // Contains human readable information on why the Challenge is in the
  // current state.
  optional string reason = 3 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // Contains the current 'state' of the challenge.
  // If not set, the state of the challenge is unknown.
  optional State state = 4 [(dev.f110.kubeproto.field) = { go_name: "State", api_field_name: "state", inline: false }];
}

message Order {
  OrderSpec   spec   = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  OrderStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message OrderList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated Order                                 items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message OrderSpec {
  // Certificate signing request bytes in DER encoding.
  // This will be used when finalizing the order.
  // This field must be set on the order.
  optional bytes request = 1 [(dev.f110.kubeproto.field) = { go_name: "Request", api_field_name: "request", inline: false }];
  // IssuerRef references a properly configured ACME-type Issuer which should
  // be used to create this Order.
  // If the Issuer does not exist, processing will be retried.
  // If the Issuer is not an 'ACME' Issuer, an error will be returned and the
  // Order will be marked as failed.
  .github.com.jetstack.cert_manager.pkg.apis.metav1.ObjectReference issuer_ref = 2 [(dev.f110.kubeproto.field) = { go_name: "IssuerRef", api_field_name: "issuerRef", inline: false }];
  // CommonName is the common name as specified on the DER encoded CSR.
  // If specified, this value must also be present in `dnsNames` or `ipAddresses`.
  // This field must match the corresponding field on the DER encoded CSR.
  optional string common_name = 3 [(dev.f110.kubeproto.field) = { go_name: "CommonName", api_field_name: "commonName", inline: false }];
  // DNSNames is a list of DNS names that should be included as part of the Order
  // validation process.
  // This field must match the corresponding field on the DER encoded CSR.
  repeated string dns_names = 4 [(dev.f110.kubeproto.field) = { go_name: "DNSNames", api_field_name: "dnsNames", inline: false }];
  // IPAddresses is a list of IP addresses that should be included as part of the Order
  // validation process.
  // This field must match the corresponding field on the DER encoded CSR.
  repeated string ip_addresses = 5 [(dev.f110.kubeproto.field) = { go_name: "IPAddresses", api_field_name: "ipAddresses", inline: false }];
  // Duration is the duration for the not after date for the requested certificate.
  // this is set on order creation as pe the ACME spec.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration duration = 6 [(dev.f110.kubeproto.field) = { go_name: "Duration", api_field_name: "duration", inline: false }];
}

message OrderStatus {
  // URL of the Order.
  // This will initially be empty when the resource is first created.
  // The Order controller will populate this field when the Order is first processed.
  // This field will be immutable after it is initially set.
  optional string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // FinalizeURL of the Order.
  // This is used to obtain certificates for this order once it has been completed.
  optional string finalize_url = 2 [(dev.f110.kubeproto.field) = { go_name: "FinalizeURL", api_field_name: "finalizeURL", inline: false }];
  // Authorizations contains data returned from the ACME server on what
  // authorizations must be completed in order to validate the DNS names
  // specified on the Order.
  repeated ACMEAuthorization authorizations = 3 [(dev.f110.kubeproto.field) = { go_name: "Authorizations", api_field_name: "authorizations", inline: false }];
  // Certificate is a copy of the PEM encoded certificate for this Order.
  // This field will be populated after the order has been successfully
  // finalized with the ACME server, and the order has transitioned to the
  // 'valid' state.
  optional bytes certificate = 4 [(dev.f110.kubeproto.field) = { go_name: "Certificate", api_field_name: "certificate", inline: false }];
  // State contains the current state of this Order resource.
  // States 'success' and 'expired' are 'final'
  optional State state = 5 [(dev.f110.kubeproto.field) = { go_name: "State", api_field_name: "state", inline: false }];
  // Reason optionally provides more information about a why the order is in
  // the current state.
  optional string reason = 6 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // FailureTime stores the time that this order failed.
  // This is used to influence garbage collection and back-off.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time failure_time = 7 [(dev.f110.kubeproto.field) = { go_name: "FailureTime", api_field_name: "failureTime", inline: false }];
}
