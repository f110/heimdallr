// Generated by: gen-go-to-protobuf
syntax = "proto3";
package github.com.jetstack.cert_manager.pkg.apis.acmev1;
option go_package = "go.f110.dev/heimdallr/pkg/k8s/thirdpartyapi/cert-manager/acmev1";
option (dev.f110.kubeproto.k8s) = {
sub_group: "cert-manager.io",
version: "v1",
};

import "kube.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "operator/proto/github.com/jetstack/cert-manager/pkg/apis/metav1/generated.proto";

enum ACMEChallengeType {
ACME_CHALLENGE_TYPE_HTTP_01 = 0 [(dev.f110.kubeproto.value) = {value: "HTTP-01"}];
ACME_CHALLENGE_TYPE_DNS_01 = 1 [(dev.f110.kubeproto.value) = {value: "DNS-01"}];
}

enum AzureDNSEnvironment {
AZURE_DNS_ENVIRONMENT_AZURE_PUBLIC_CLOUD = 0;
AZURE_DNS_ENVIRONMENT_AZURE_CHINA_CLOUD = 1;
AZURE_DNS_ENVIRONMENT_AZURE_GERMAN_CLOUD = 2;
AZURE_DNS_ENVIRONMENT_AZURE_U_S_GOVERNMENT_CLOUD = 3;
}

enum HMACKeyAlgorithm {
HMAC_KEY_ALGORITHM_H_S256 = 0;
HMAC_KEY_ALGORITHM_H_S384 = 1;
HMAC_KEY_ALGORITHM_H_S512 = 2;
}

enum State {
STATE_UNKNOWN = 0 [(dev.f110.kubeproto.value) = {value: ""}];
STATE_VALID = 1 [(dev.f110.kubeproto.value) = {value: "valid"}];
STATE_READY = 2 [(dev.f110.kubeproto.value) = {value: "ready"}];
STATE_PENDING = 3 [(dev.f110.kubeproto.value) = {value: "pending"}];
STATE_PROCESSING = 4 [(dev.f110.kubeproto.value) = {value: "processing"}];
STATE_INVALID = 5 [(dev.f110.kubeproto.value) = {value: "invalid"}];
STATE_EXPIRED = 6 [(dev.f110.kubeproto.value) = {value: "expired"}];
STATE_ERRORED = 7 [(dev.f110.kubeproto.value) = {value: "errored"}];
}

message ACMEAuthorization {
// URL is the URL of the Authorization that must be completed
string url = 1 [(dev.f110.kubeproto.field) = {go_name: "URL", api_field_name: "url", inline: false}];
// Identifier is the DNS name to be validated as part of this authorization
optional string identifier = 2 [(dev.f110.kubeproto.field) = {go_name: "Identifier", api_field_name: "identifier", inline: false}];
// Wildcard will be true if this authorization is for a wildcard DNS name.
// If this is true, the identifier will be the *non-wildcard* version of
// the DNS name.
// For example, if '*.example.com' is the DNS name being validated, this
// field will be 'true' and the 'identifier' field will be 'example.com'.
optional bool wildcard = 3 [(dev.f110.kubeproto.field) = {go_name: "Wildcard", api_field_name: "wildcard", inline: false}];
// InitialState is the initial state of the ACME authorization when first
// fetched from the ACME server.
// If an Authorization is already 'valid', the Order controller will not
// create a Challenge resource for the authorization. This will occur when
// working with an ACME server that enables 'authz reuse' (such as Let's
// Encrypt's production endpoint).
// If not set and 'identifier' is set, the state is assumed to be pending
// and a Challenge will be created.
optional State initial_state = 4 [(dev.f110.kubeproto.field) = {go_name: "InitialState", api_field_name: "initialState", inline: false}];
// Challenges specifies the challenge types offered by the ACME server.
// One of these challenge types will be selected when validating the DNS
// name and an appropriate Challenge resource will be created to perform
// the ACME challenge process.
repeated ACMEChallenge challenges = 5 [(dev.f110.kubeproto.field) = {go_name: "Challenges", api_field_name: "challenges", inline: false}];
}

message ACMEChallenge {
// URL is the URL of this challenge. It can be used to retrieve additional
// metadata about the Challenge from the ACME server.
string url = 1 [(dev.f110.kubeproto.field) = {go_name: "URL", api_field_name: "url", inline: false}];
// Token is the token that must be presented for this challenge.
// This is used to compute the 'key' that must also be presented.
string token = 2 [(dev.f110.kubeproto.field) = {go_name: "Token", api_field_name: "token", inline: false}];
// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01',
// 'tls-sni-01', etc.
// This is the raw value retrieved from the ACME server.
// Only 'http-01' and 'dns-01' are supported by cert-manager, other values
// will be ignored.
string type = 3 [(dev.f110.kubeproto.field) = {go_name: "Type", api_field_name: "type", inline: false}];
}

message ACMEChallengeSolver {
// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
optional CertificateDNSNameSelector selector = 1 [(dev.f110.kubeproto.field) = {go_name: "Selector", api_field_name: "selector", inline: false}];
// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
optional ACMEChallengeSolverHTTP01 http_01 = 2 [(dev.f110.kubeproto.field) = {go_name: "HTTP01", api_field_name: "http01", inline: false}];
// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
optional ACMEChallengeSolverDNS01 dns_01 = 3 [(dev.f110.kubeproto.field) = {go_name: "DNS01", api_field_name: "dns01", inline: false}];
}

message ACMEChallengeSolverDNS01 {
// CNAMEStrategy configures how the DNS01 provider should handle CNAME
// records when found in DNS zones.
string c_n_a_m_e_strategy = 1 [(dev.f110.kubeproto.field) = {go_name: "CNAMEStrategy", api_field_name: "cnameStrategy", inline: false}];
// Use the Akamai DNS zone management API to manage DNS01 challenge records.
optional ACMEIssuerDNS01ProviderAkamai akamai = 2 [(dev.f110.kubeproto.field) = {go_name: "Akamai", api_field_name: "akamai", inline: false}];
// Use the Google Cloud DNS API to manage DNS01 challenge records.
optional ACMEIssuerDNS01ProviderCloudDNS cloud_dns = 3 [(dev.f110.kubeproto.field) = {go_name: "CloudDNS", api_field_name: "cloudDNS", inline: false}];
// Use the Cloudflare API to manage DNS01 challenge records.
optional ACMEIssuerDNS01ProviderCloudflare cloudflare = 4 [(dev.f110.kubeproto.field) = {go_name: "Cloudflare", api_field_name: "cloudflare", inline: false}];
// Use the AWS Route53 API to manage DNS01 challenge records.
optional ACMEIssuerDNS01ProviderRoute53 route53 = 5 [(dev.f110.kubeproto.field) = {go_name: "Route53", api_field_name: "route53", inline: false}];
// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
optional ACMEIssuerDNS01ProviderAzureDNS azure_dns = 6 [(dev.f110.kubeproto.field) = {go_name: "AzureDNS", api_field_name: "azureDNS", inline: false}];
// Use the DigitalOcean DNS API to manage DNS01 challenge records.
optional ACMEIssuerDNS01ProviderDigitalOcean digital_ocean = 7 [(dev.f110.kubeproto.field) = {go_name: "DigitalOcean", api_field_name: "digitalocean", inline: false}];
// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
optional ACMEIssuerDNS01ProviderAcmeDNS acme_dns = 8 [(dev.f110.kubeproto.field) = {go_name: "AcmeDNS", api_field_name: "acmeDNS", inline: false}];
// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
optional ACMEIssuerDNS01ProviderRFC2136 r_fc_2136 = 9 [(dev.f110.kubeproto.field) = {go_name: "RFC2136", api_field_name: "rfc2136", inline: false}];
// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
optional ACMEIssuerDNS01ProviderWebhook webhook = 10 [(dev.f110.kubeproto.field) = {go_name: "Webhook", api_field_name: "webhook", inline: false}];
}

message ACMEChallengeSolverHTTP01 {
// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
optional ACMEChallengeSolverHTTP01Ingress ingress = 1 [(dev.f110.kubeproto.field) = {go_name: "Ingress", api_field_name: "ingress", inline: false}];
// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
optional ACMEChallengeSolverHTTP01GatewayHTTPRoute gateway_http_route = 2 [(dev.f110.kubeproto.field) = {go_name: "GatewayHTTPRoute", api_field_name: "gatewayHTTPRoute", inline: false}];
}

message ACMEChallengeSolverHTTP01GatewayHTTPRoute {
// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
optional .k8s.io.api.core.v1.ServiceType service_type = 1 [(dev.f110.kubeproto.field) = {go_name: "ServiceType", api_field_name: "serviceType", inline: false}];
// The labels that cert-manager will use when creating the temporary
// HTTPRoute needed for solving the HTTP-01 challenge. These labels
// must match the label selector of at least one Gateway.
map<string, string> labels = 2 [(dev.f110.kubeproto.field) = {go_name: "Labels", api_field_name: "labels", inline: false}];
}

message ACMEChallengeSolverHTTP01Ingress {
// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
optional .k8s.io.api.core.v1.ServiceType service_type = 1 [(dev.f110.kubeproto.field) = {go_name: "ServiceType", api_field_name: "serviceType", inline: false}];
// The ingress class to use when creating Ingress resources to solve ACME
// challenges that use this challenge solver.
// Only one of 'class' or 'name' may be specified.
optional string class = 2 [(dev.f110.kubeproto.field) = {go_name: "Class", api_field_name: "class", inline: false}];
// The name of the ingress resource that should have ACME challenge solving
// routes inserted into it in order to solve HTTP01 challenges.
// This is typically used in conjunction with ingress controllers like
// ingress-gce, which maintains a 1:1 mapping between external IPs and
// ingress resources.
optional string name = 3 [(dev.f110.kubeproto.field) = {go_name: "Name", api_field_name: "name", inline: false}];
// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
optional ACMEChallengeSolverHTTP01IngressPodTemplate pod_template = 4 [(dev.f110.kubeproto.field) = {go_name: "PodTemplate", api_field_name: "podTemplate", inline: false}];
// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
optional ACMEChallengeSolverHTTP01IngressTemplate ingress_template = 5 [(dev.f110.kubeproto.field) = {go_name: "IngressTemplate", api_field_name: "ingressTemplate", inline: false}];
}

message ACMEChallengeSolverHTTP01IngressObjectMeta {
// Annotations that should be added to the created ACME HTTP01 solver ingress.
map<string, string> annotations = 1 [(dev.f110.kubeproto.field) = {go_name: "Annotations", api_field_name: "annotations", inline: false}];
// Labels that should be added to the created ACME HTTP01 solver ingress.
map<string, string> labels = 2 [(dev.f110.kubeproto.field) = {go_name: "Labels", api_field_name: "labels", inline: false}];
}

message ACMEChallengeSolverHTTP01IngressPodObjectMeta {
// Annotations that should be added to the create ACME HTTP01 solver pods.
map<string, string> annotations = 1 [(dev.f110.kubeproto.field) = {go_name: "Annotations", api_field_name: "annotations", inline: false}];
// Labels that should be added to the created ACME HTTP01 solver pods.
map<string, string> labels = 2 [(dev.f110.kubeproto.field) = {go_name: "Labels", api_field_name: "labels", inline: false}];
}

message ACMEChallengeSolverHTTP01IngressPodSpec {
// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
map<string, string> node_selector = 1 [(dev.f110.kubeproto.field) = {go_name: "NodeSelector", api_field_name: "nodeSelector", inline: false}];
// If specified, the pod's scheduling constraints
optional .k8s.io.api.core.v1.Affinity affinity = 2 [(dev.f110.kubeproto.field) = {go_name: "Affinity", api_field_name: "affinity", inline: false}];
// If specified, the pod's tolerations.
repeated .k8s.io.api.core.v1.Toleration tolerations = 3 [(dev.f110.kubeproto.field) = {go_name: "Tolerations", api_field_name: "tolerations", inline: false}];
// If specified, the pod's priorityClassName.
optional string priority_class_name = 4 [(dev.f110.kubeproto.field) = {go_name: "PriorityClassName", api_field_name: "priorityClassName", inline: false}];
// If specified, the pod's service account
optional string service_account_name = 5 [(dev.f110.kubeproto.field) = {go_name: "ServiceAccountName", api_field_name: "serviceAccountName", inline: false}];
}

message ACMEChallengeSolverHTTP01IngressPodTemplate {
// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
ACMEChallengeSolverHTTP01IngressPodObjectMeta acme_challenge_solver_http_01_ingress_pod_object_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "ACMEChallengeSolverHTTP01IngressPodObjectMeta", api_field_name: "metadata", inline: false}];
// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Only the 'priorityClassName', 'nodeSelector', 'affinity',
// 'serviceAccountName' and 'tolerations' fields are supported currently.
// All other fields will be ignored.
ACMEChallengeSolverHTTP01IngressPodSpec spec = 2 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];
}

message ACMEChallengeSolverHTTP01IngressTemplate {
// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
ACMEChallengeSolverHTTP01IngressObjectMeta acme_challenge_solver_http_01_ingress_object_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "ACMEChallengeSolverHTTP01IngressObjectMeta", api_field_name: "metadata", inline: false}];
}

message ACMEExternalAccountBinding {
// keyID is the ID of the CA key that the External Account is bound to.
string key_id = 1 [(dev.f110.kubeproto.field) = {go_name: "KeyID", api_field_name: "keyID", inline: false}];
// keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes
// Secret which holds the symmetric MAC key of the External Account Binding.
// The `key` is the index string that is paired with the key data in the
// Secret and should not be confused with the key data itself, or indeed with
// the External Account Binding keyID above.
// The secret key stored in the Secret **must** be un-padded, base64 URL
// encoded data.
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector key = 2 [(dev.f110.kubeproto.field) = {go_name: "Key", api_field_name: "keySecretRef", inline: false}];
// Deprecated: keyAlgorithm field exists for historical compatibility
// reasons and should not be used. The algorithm is now hardcoded to HS256
// in golang/x/crypto/acme.
optional HMACKeyAlgorithm key_algorithm = 3 [(dev.f110.kubeproto.field) = {go_name: "KeyAlgorithm", api_field_name: "keyAlgorithm", inline: false}];
}

message ACMEIssuer {
// Email is the email address to be associated with the ACME account.
// This field is optional, but it is strongly recommended to be set.
// It will be used to contact you in case of issues with your account or
// certificates, including expiry notification emails.
// This field may be updated after the account is initially registered.
optional string email = 1 [(dev.f110.kubeproto.field) = {go_name: "Email", api_field_name: "email", inline: false}];
// Server is the URL used to access the ACME server's 'directory' endpoint.
// For example, for Let's Encrypt's staging endpoint, you would use:
// "https://acme-staging-v02.api.letsencrypt.org/directory".
// Only ACME v2 endpoints (i.e. RFC 8555) are supported.
string server = 2 [(dev.f110.kubeproto.field) = {go_name: "Server", api_field_name: "server", inline: false}];
// PreferredChain is the chain to use if the ACME server outputs multiple.
// PreferredChain is no guarantee that this one gets delivered by the ACME
// endpoint.
// For example, for Let's Encrypt's DST crosssign you would use:
// "DST Root CA X3" or "ISRG Root X1" for the newer Let's Encrypt root CA.
// This value picks the first certificate bundle in the ACME alternative
// chains that has a certificate with this value as its issuer's CN
string preferred_chain = 3 [(dev.f110.kubeproto.field) = {go_name: "PreferredChain", api_field_name: "preferredChain", inline: false}];
// Enables or disables validation of the ACME server TLS certificate.
// If true, requests to the ACME server will not have their TLS certificate
// validated (i.e. insecure connections will be allowed).
// Only enable this option in development environments.
// The cert-manager system installed roots will be used to verify connections
// to the ACME server if this is false.
// Defaults to false.
optional bool skip_tls_verify = 4 [(dev.f110.kubeproto.field) = {go_name: "SkipTLSVerify", api_field_name: "skipTLSVerify", inline: false}];
// ExternalAccountBinding is a reference to a CA external account of the ACME
// server.
// If set, upon registration cert-manager will attempt to associate the given
// external account credentials with the registered ACME account.
optional ACMEExternalAccountBinding external_account_binding = 5 [(dev.f110.kubeproto.field) = {go_name: "ExternalAccountBinding", api_field_name: "externalAccountBinding", inline: false}];
// PrivateKey is the name of a Kubernetes Secret resource that will be used to
// store the automatically generated ACME account private key.
// Optionally, a `key` may be specified to select a specific entry within
// the named Secret resource.
// If `key` is not specified, a default of `tls.key` will be used.
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector private_key = 6 [(dev.f110.kubeproto.field) = {go_name: "PrivateKey", api_field_name: "privateKeySecretRef", inline: false}];
// Solvers is a list of challenge solvers that will be used to solve
// ACME challenges for the matching domains.
// Solver configurations must be provided in order to obtain certificates
// from an ACME server.
// For more information, see: https://cert-manager.io/docs/configuration/acme/
repeated ACMEChallengeSolver solvers = 7 [(dev.f110.kubeproto.field) = {go_name: "Solvers", api_field_name: "solvers", inline: false}];
// Enables or disables generating a new ACME account key.
// If true, the Issuer resource will *not* request a new account but will expect
// the account key to be supplied via an existing secret.
// If false, the cert-manager system will generate a new ACME account key
// for the Issuer.
// Defaults to false.
optional bool disable_account_key_generation = 8 [(dev.f110.kubeproto.field) = {go_name: "DisableAccountKeyGeneration", api_field_name: "disableAccountKeyGeneration", inline: false}];
// Enables requesting a Not After date on certificates that matches the
// duration of the certificate. This is not supported by all ACME servers
// like Let's Encrypt. If set to true when the ACME server does not support
// it it will create an error on the Order.
// Defaults to false.
optional bool enable_duration_feature = 9 [(dev.f110.kubeproto.field) = {go_name: "EnableDurationFeature", api_field_name: "enableDurationFeature", inline: false}];
}

message ACMEIssuerDNS01ProviderAcmeDNS {
string host = 1 [(dev.f110.kubeproto.field) = {go_name: "Host", api_field_name: "host", inline: false}];
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector account_secret = 2 [(dev.f110.kubeproto.field) = {go_name: "AccountSecret", api_field_name: "accountSecretRef", inline: false}];
}

message ACMEIssuerDNS01ProviderAkamai {
string service_consumer_domain = 1 [(dev.f110.kubeproto.field) = {go_name: "ServiceConsumerDomain", api_field_name: "serviceConsumerDomain", inline: false}];
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector client_token = 2 [(dev.f110.kubeproto.field) = {go_name: "ClientToken", api_field_name: "clientTokenSecretRef", inline: false}];
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector client_secret = 3 [(dev.f110.kubeproto.field) = {go_name: "ClientSecret", api_field_name: "clientSecretSecretRef", inline: false}];
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector access_token = 4 [(dev.f110.kubeproto.field) = {go_name: "AccessToken", api_field_name: "accessTokenSecretRef", inline: false}];
}

message ACMEIssuerDNS01ProviderAzureDNS {
// if both this and ClientSecret are left unset MSI will be used
optional string client_id = 1 [(dev.f110.kubeproto.field) = {go_name: "ClientID", api_field_name: "clientID", inline: false}];
// if both this and ClientID are left unset MSI will be used
optional .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector client_secret = 2 [(dev.f110.kubeproto.field) = {go_name: "ClientSecret", api_field_name: "clientSecretSecretRef", inline: false}];
// ID of the Azure subscription
string subscription_id = 3 [(dev.f110.kubeproto.field) = {go_name: "SubscriptionID", api_field_name: "subscriptionID", inline: false}];
// when specifying ClientID and ClientSecret then this field is also needed
optional string tenant_id = 4 [(dev.f110.kubeproto.field) = {go_name: "TenantID", api_field_name: "tenantID", inline: false}];
// resource group the DNS zone is located in
string resource_group_name = 5 [(dev.f110.kubeproto.field) = {go_name: "ResourceGroupName", api_field_name: "resourceGroupName", inline: false}];
// name of the DNS zone that should be used
optional string hosted_zone_name = 6 [(dev.f110.kubeproto.field) = {go_name: "HostedZoneName", api_field_name: "hostedZoneName", inline: false}];
// name of the Azure environment (default AzurePublicCloud)
optional AzureDNSEnvironment environment = 7 [(dev.f110.kubeproto.field) = {go_name: "Environment", api_field_name: "environment", inline: false}];
// managed identity configuration, can not be used at the same time as clientID, clientSecretSecretRef or tenantID
optional AzureManagedIdentity managed_identity = 8 [(dev.f110.kubeproto.field) = {go_name: "ManagedIdentity", api_field_name: "managedIdentity", inline: false}];
}

message ACMEIssuerDNS01ProviderCloudDNS {
optional .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector service_account = 1 [(dev.f110.kubeproto.field) = {go_name: "ServiceAccount", api_field_name: "serviceAccountSecretRef", inline: false}];
string project = 2 [(dev.f110.kubeproto.field) = {go_name: "Project", api_field_name: "project", inline: false}];
// HostedZoneName is an optional field that tells cert-manager in which
// Cloud DNS zone the challenge record has to be created.
// If left empty cert-manager will automatically choose a zone.
optional string hosted_zone_name = 3 [(dev.f110.kubeproto.field) = {go_name: "HostedZoneName", api_field_name: "hostedZoneName", inline: false}];
}

message ACMEIssuerDNS01ProviderCloudflare {
// Email of the account, only required when using API key based authentication.
optional string email = 1 [(dev.f110.kubeproto.field) = {go_name: "Email", api_field_name: "email", inline: false}];
// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
optional .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector api_key = 2 [(dev.f110.kubeproto.field) = {go_name: "APIKey", api_field_name: "apiKeySecretRef", inline: false}];
// API token used to authenticate with Cloudflare.
optional .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector api_token = 3 [(dev.f110.kubeproto.field) = {go_name: "APIToken", api_field_name: "apiTokenSecretRef", inline: false}];
}

message ACMEIssuerDNS01ProviderDigitalOcean {
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector token = 1 [(dev.f110.kubeproto.field) = {go_name: "Token", api_field_name: "tokenSecretRef", inline: false}];
}

message ACMEIssuerDNS01ProviderRFC2136 {
// The IP address or hostname of an authoritative DNS server supporting
// RFC2136 in the form host:port. If the host is an IPv6 address it must be
// enclosed in square brackets (e.g [2001:db8::1])Â ; port is optional.
// This field is required.
string nameserver = 1 [(dev.f110.kubeproto.field) = {go_name: "Nameserver", api_field_name: "nameserver", inline: false}];
// The name of the secret containing the TSIG value.
// If ``tsigKeyName`` is defined, this field is required.
optional .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector t_s_i_g_secret = 2 [(dev.f110.kubeproto.field) = {go_name: "TSIGSecret", api_field_name: "tsigSecretSecretRef", inline: false}];
// The TSIG Key name configured in the DNS.
// If ``tsigSecretSecretRef`` is defined, this field is required.
optional string t_s_i_g_key_name = 3 [(dev.f110.kubeproto.field) = {go_name: "TSIGKeyName", api_field_name: "tsigKeyName", inline: false}];
// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
// when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
// Supported values are (case-insensitive): ``HMACMD5`` (default),
// ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
optional string t_s_i_g_algorithm = 4 [(dev.f110.kubeproto.field) = {go_name: "TSIGAlgorithm", api_field_name: "tsigAlgorithm", inline: false}];
}

message ACMEIssuerDNS01ProviderRoute53 {
// The AccessKeyID is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
optional string access_key_id = 1 [(dev.f110.kubeproto.field) = {go_name: "AccessKeyID", api_field_name: "accessKeyID", inline: false}];
// The SecretAccessKey is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata
// https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector secret_access_key = 2 [(dev.f110.kubeproto.field) = {go_name: "SecretAccessKey", api_field_name: "secretAccessKeySecretRef", inline: false}];
// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
optional string role = 3 [(dev.f110.kubeproto.field) = {go_name: "Role", api_field_name: "role", inline: false}];
// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
optional string hosted_zone_id = 4 [(dev.f110.kubeproto.field) = {go_name: "HostedZoneID", api_field_name: "hostedZoneID", inline: false}];
// Always set the region when using AccessKeyID and SecretAccessKey
string region = 5 [(dev.f110.kubeproto.field) = {go_name: "Region", api_field_name: "region", inline: false}];
}

message ACMEIssuerDNS01ProviderWebhook {
// The API group name that should be used when POSTing ChallengePayload
// resources to the webhook apiserver.
// This should be the same as the GroupName specified in the webhook
// provider implementation.
string group_name = 1 [(dev.f110.kubeproto.field) = {go_name: "GroupName", api_field_name: "groupName", inline: false}];
// The name of the solver to use, as defined in the webhook provider
// implementation.
// This will typically be the name of the provider, e.g. 'cloudflare'.
string solver_name = 2 [(dev.f110.kubeproto.field) = {go_name: "SolverName", api_field_name: "solverName", inline: false}];
// Additional configuration that should be passed to the webhook apiserver
// when challenges are processed.
// This can contain arbitrary JSON data.
// Secret values should not be specified in this stanza.
// If secret values are needed (e.g. credentials for a DNS service), you
// should use a SecretKeySelector to reference a Secret resource.
// For details on the schema of this field, consult the webhook provider
// implementation's documentation.
optional .k8s.io.apiextensions_apiserver.pkg.apis.apiextensions.v1.JSON config = 3 [(dev.f110.kubeproto.field) = {go_name: "Config", api_field_name: "config", inline: false}];
}

message ACMEIssuerStatus {
// URI is the unique account identifier, which can also be used to retrieve
// account details from the CA
optional string uri = 1 [(dev.f110.kubeproto.field) = {go_name: "URI", api_field_name: "uri", inline: false}];
// LastRegisteredEmail is the email associated with the latest registered
// ACME account, in order to track changes made to registered account
// associated with the  Issuer
optional string last_registered_email = 2 [(dev.f110.kubeproto.field) = {go_name: "LastRegisteredEmail", api_field_name: "lastRegisteredEmail", inline: false}];
}

message AzureManagedIdentity {
// client ID of the managed identity, can not be used at the same time as resourceID
optional string client_id = 1 [(dev.f110.kubeproto.field) = {go_name: "ClientID", api_field_name: "clientID", inline: false}];
// resource ID of the managed identity, can not be used at the same time as clientID
optional string resource_id = 2 [(dev.f110.kubeproto.field) = {go_name: "ResourceID", api_field_name: "resourceID", inline: false}];
}

message CertificateDNSNameSelector {
// A label selector that is used to refine the set of certificate's that
// this challenge solver will apply to.
map<string, string> match_labels = 1 [(dev.f110.kubeproto.field) = {go_name: "MatchLabels", api_field_name: "matchLabels", inline: false}];
// List of DNSNames that this solver will be used to solve.
// If specified and a match is found, a dnsNames selector will take
// precedence over a dnsZones selector.
// If multiple solvers match with the same dnsNames value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
repeated string dns_names = 2 [(dev.f110.kubeproto.field) = {go_name: "DNSNames", api_field_name: "dnsNames", inline: false}];
// List of DNSZones that this solver will be used to solve.
// The most specific DNS zone match specified here will take precedence
// over other DNS zone matches, so a solver specifying sys.example.com
// will be selected over one specifying example.com for the domain
// www.sys.example.com.
// If multiple solvers match with the same dnsZones value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
repeated string dns_zones = 3 [(dev.f110.kubeproto.field) = {go_name: "DNSZones", api_field_name: "dnsZones", inline: false}];
}

message Challenge {
ChallengeSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];
ChallengeStatus status = 4 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", sub_resource: true, inline: false}];

option (dev.f110.kubeproto.kind) = {
};
}

message ChallengeList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
.k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
repeated Challenge items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message ChallengeSpec {
// The URL of the ACME Challenge resource for this challenge.
// This can be used to lookup details about the status of this challenge.
string url = 1 [(dev.f110.kubeproto.field) = {go_name: "URL", api_field_name: "url", inline: false}];
// The URL to the ACME Authorization resource that this
// challenge is a part of.
string authorization_url = 2 [(dev.f110.kubeproto.field) = {go_name: "AuthorizationURL", api_field_name: "authorizationURL", inline: false}];
// dnsName is the identifier that this challenge is for, e.g. example.com.
// If the requested DNSName is a 'wildcard', this field MUST be set to the
// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
string dns_name = 3 [(dev.f110.kubeproto.field) = {go_name: "DNSName", api_field_name: "dnsName", inline: false}];
// wildcard will be true if this challenge is for a wildcard identifier,
// for example '*.example.com'.
bool wildcard = 4 [(dev.f110.kubeproto.field) = {go_name: "Wildcard", api_field_name: "wildcard", inline: false}];
// The type of ACME challenge this resource represents.
// One of "HTTP-01" or "DNS-01".
ACMEChallengeType type = 5 [(dev.f110.kubeproto.field) = {go_name: "Type", api_field_name: "type", inline: false}];
// The ACME challenge token for this challenge.
// This is the raw value returned from the ACME server.
string token = 6 [(dev.f110.kubeproto.field) = {go_name: "Token", api_field_name: "token", inline: false}];
// The ACME challenge key for this challenge
// For HTTP01 challenges, this is the value that must be responded with to
// complete the HTTP01 challenge in the format:
// `<private key JWK thumbprint>.<key from acme server for challenge>`.
// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
// `<private key JWK thumbprint>.<key from acme server for challenge>`
// text that must be set as the TXT record content.
string key = 7 [(dev.f110.kubeproto.field) = {go_name: "Key", api_field_name: "key", inline: false}];
// Contains the domain solving configuration that should be used to
// solve this challenge resource.
ACMEChallengeSolver solver = 8 [(dev.f110.kubeproto.field) = {go_name: "Solver", api_field_name: "solver", inline: false}];
// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
.github.com.jetstack.cert_manager.pkg.apis.metav1.ObjectReference issuer_ref = 9 [(dev.f110.kubeproto.field) = {go_name: "IssuerRef", api_field_name: "issuerRef", inline: false}];
}

message ChallengeStatus {
// Used to denote whether this challenge should be processed or not.
// This field will only be set to true by the 'scheduling' component.
// It will only be set to false by the 'challenges' controller, after the
// challenge has reached a final state or timed out.
// If this field is set to false, the challenge controller will not take
// any more action.
bool processing = 1 [(dev.f110.kubeproto.field) = {go_name: "Processing", api_field_name: "processing", inline: false}];
// presented will be set to true if the challenge values for this challenge
// are currently 'presented'.
// This *does not* imply the self check is passing. Only that the values
// have been 'submitted' for the appropriate challenge mechanism (i.e. the
// DNS01 TXT record has been presented, or the HTTP01 configuration has been
// configured).
bool presented = 2 [(dev.f110.kubeproto.field) = {go_name: "Presented", api_field_name: "presented", inline: false}];
// Contains human readable information on why the Challenge is in the
// current state.
optional string reason = 3 [(dev.f110.kubeproto.field) = {go_name: "Reason", api_field_name: "reason", inline: false}];
// Contains the current 'state' of the challenge.
// If not set, the state of the challenge is unknown.
optional State state = 4 [(dev.f110.kubeproto.field) = {go_name: "State", api_field_name: "state", inline: false}];
}

message Order {
OrderSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];
OrderStatus status = 4 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", sub_resource: true, inline: false}];

option (dev.f110.kubeproto.kind) = {
};
}

message OrderList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
.k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
repeated Order items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message OrderSpec {
// Certificate signing request bytes in DER encoding.
// This will be used when finalizing the order.
// This field must be set on the order.
optional bytes request = 1 [(dev.f110.kubeproto.field) = {go_name: "Request", api_field_name: "request", inline: false}];
// IssuerRef references a properly configured ACME-type Issuer which should
// be used to create this Order.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Order will be marked as failed.
.github.com.jetstack.cert_manager.pkg.apis.metav1.ObjectReference issuer_ref = 2 [(dev.f110.kubeproto.field) = {go_name: "IssuerRef", api_field_name: "issuerRef", inline: false}];
// CommonName is the common name as specified on the DER encoded CSR.
// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
// This field must match the corresponding field on the DER encoded CSR.
optional string common_name = 3 [(dev.f110.kubeproto.field) = {go_name: "CommonName", api_field_name: "commonName", inline: false}];
// DNSNames is a list of DNS names that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
repeated string dns_names = 4 [(dev.f110.kubeproto.field) = {go_name: "DNSNames", api_field_name: "dnsNames", inline: false}];
// IPAddresses is a list of IP addresses that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
repeated string ip_addresses = 5 [(dev.f110.kubeproto.field) = {go_name: "IPAddresses", api_field_name: "ipAddresses", inline: false}];
// Duration is the duration for the not after date for the requested certificate.
// this is set on order creation as pe the ACME spec.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration duration = 6 [(dev.f110.kubeproto.field) = {go_name: "Duration", api_field_name: "duration", inline: false}];
}

message OrderStatus {
// URL of the Order.
// This will initially be empty when the resource is first created.
// The Order controller will populate this field when the Order is first processed.
// This field will be immutable after it is initially set.
optional string url = 1 [(dev.f110.kubeproto.field) = {go_name: "URL", api_field_name: "url", inline: false}];
// FinalizeURL of the Order.
// This is used to obtain certificates for this order once it has been completed.
optional string finalize_url = 2 [(dev.f110.kubeproto.field) = {go_name: "FinalizeURL", api_field_name: "finalizeURL", inline: false}];
// Authorizations contains data returned from the ACME server on what
// authorizations must be completed in order to validate the DNS names
// specified on the Order.
repeated ACMEAuthorization authorizations = 3 [(dev.f110.kubeproto.field) = {go_name: "Authorizations", api_field_name: "authorizations", inline: false}];
// Certificate is a copy of the PEM encoded certificate for this Order.
// This field will be populated after the order has been successfully
// finalized with the ACME server, and the order has transitioned to the
// 'valid' state.
optional bytes certificate = 4 [(dev.f110.kubeproto.field) = {go_name: "Certificate", api_field_name: "certificate", inline: false}];
// State contains the current state of this Order resource.
// States 'success' and 'expired' are 'final'
optional State state = 5 [(dev.f110.kubeproto.field) = {go_name: "State", api_field_name: "state", inline: false}];
// Reason optionally provides more information about a why the order is in
// the current state.
optional string reason = 6 [(dev.f110.kubeproto.field) = {go_name: "Reason", api_field_name: "reason", inline: false}];
// FailureTime stores the time that this order failed.
// This is used to influence garbage collection and back-off.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time failure_time = 7 [(dev.f110.kubeproto.field) = {go_name: "FailureTime", api_field_name: "failureTime", inline: false}];
}

