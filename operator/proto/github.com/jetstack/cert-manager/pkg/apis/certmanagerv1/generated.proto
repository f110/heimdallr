// Generated by: gen-go-to-protobuf
syntax = "proto3";
package github.com.jetstack.cert_manager.pkg.apis.certmanagerv1;
option go_package = "go.f110.dev/heimdallr/pkg/k8s/thirdpartyapi/cert-manager/certmanagerv1";
option (dev.f110.kubeproto.k8s) = {
sub_group: "cert-manager.io",
version: "v1",
};

import "kube.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "operator/proto/github.com/jetstack/cert-manager/pkg/apis/acmev1/generated.proto";
import "operator/proto/github.com/jetstack/cert-manager/pkg/apis/metav1/generated.proto";

enum CertificateConditionType {
CERTIFICATE_CONDITION_TYPE_READY = 0 [(dev.f110.kubeproto.value) = {value: "Ready"}];
CERTIFICATE_CONDITION_TYPE_ISSUING = 1 [(dev.f110.kubeproto.value) = {value: "Issuing"}];
}

enum CertificateRequestConditionType {
CERTIFICATE_REQUEST_CONDITION_TYPE_READY = 0 [(dev.f110.kubeproto.value) = {value: "Ready"}];
CERTIFICATE_REQUEST_CONDITION_TYPE_INVALID_REQUEST = 1;
CERTIFICATE_REQUEST_CONDITION_TYPE_APPROVED = 2 [(dev.f110.kubeproto.value) = {value: "Approved"}];
CERTIFICATE_REQUEST_CONDITION_TYPE_DENIED = 3 [(dev.f110.kubeproto.value) = {value: "Denied"}];
}

enum IssuerConditionType {
ISSUER_CONDITION_TYPE_READY = 0 [(dev.f110.kubeproto.value) = {value: "Ready"}];
}

enum KeyUsage {
KEY_USAGE_SIGNING = 0 [(dev.f110.kubeproto.value) = {value: "signing"}];
KEY_USAGE_DIGITAL_SIGNATURE = 1 [(dev.f110.kubeproto.value) = {value: "digital signature"}];
KEY_USAGE_CONTENT_COMMITMENT = 2 [(dev.f110.kubeproto.value) = {value: "content commitment"}];
KEY_USAGE_KEY_ENCIPHERMENT = 3 [(dev.f110.kubeproto.value) = {value: "key encipherment"}];
KEY_USAGE_KEY_AGREEMENT = 4 [(dev.f110.kubeproto.value) = {value: "key agreement"}];
KEY_USAGE_DATA_ENCIPHERMENT = 5 [(dev.f110.kubeproto.value) = {value: "data encipherment"}];
KEY_USAGE_CERT_SIGN = 6 [(dev.f110.kubeproto.value) = {value: "cert sign"}];
KEY_USAGE_CRL_SIGN = 7 [(dev.f110.kubeproto.value) = {value: "crl sign"}];
KEY_USAGE_ENCIPHER_ONLY = 8 [(dev.f110.kubeproto.value) = {value: "encipher only"}];
KEY_USAGE_DECIPHER_ONLY = 9 [(dev.f110.kubeproto.value) = {value: "decipher only"}];
KEY_USAGE_ANY = 10 [(dev.f110.kubeproto.value) = {value: "any"}];
KEY_USAGE_SERVER_AUTH = 11 [(dev.f110.kubeproto.value) = {value: "server auth"}];
KEY_USAGE_CLIENT_AUTH = 12 [(dev.f110.kubeproto.value) = {value: "client auth"}];
KEY_USAGE_CODE_SIGNING = 13 [(dev.f110.kubeproto.value) = {value: "code signing"}];
KEY_USAGE_EMAIL_PROTECTION = 14 [(dev.f110.kubeproto.value) = {value: "email protection"}];
KEY_USAGE_S_MIME = 15 [(dev.f110.kubeproto.value) = {value: "s/mime"}];
KEY_USAGE_IPSEC_END_SYSTEM = 16 [(dev.f110.kubeproto.value) = {value: "ipsec end system"}];
KEY_USAGE_IPSEC_TUNNEL = 17 [(dev.f110.kubeproto.value) = {value: "ipsec tunnel"}];
KEY_USAGE_IPSEC_USER = 18 [(dev.f110.kubeproto.value) = {value: "ipsec user"}];
KEY_USAGE_TIMESTAMPING = 19 [(dev.f110.kubeproto.value) = {value: "timestamping"}];
KEY_USAGE_OCSP_SIGNING = 20 [(dev.f110.kubeproto.value) = {value: "ocsp signing"}];
KEY_USAGE_MICROSOFT_SGC = 21 [(dev.f110.kubeproto.value) = {value: "microsoft sgc"}];
KEY_USAGE_NETSCAPE_SGC = 22 [(dev.f110.kubeproto.value) = {value: "netscape sgc"}];
}

enum PrivateKeyAlgorithm {
PRIVATE_KEY_ALGORITHM_R_S_A = 0;
PRIVATE_KEY_ALGORITHM_E_C_D_S_A = 1;
PRIVATE_KEY_ALGORITHM_ED25519 = 2;
}

enum PrivateKeyEncoding {
PRIVATE_KEY_ENCODING_P_K_C_S1 = 0;
PRIVATE_KEY_ENCODING_P_K_C_S8 = 1;
}

message CAIssuer {
// SecretName is the name of the secret used to sign Certificates issued
// by this Issuer.
string secret_name = 1 [(dev.f110.kubeproto.field) = {go_name: "SecretName", api_field_name: "secretName", inline: false}];
// The CRL distribution points is an X.509 v3 certificate extension which identifies
// the location of the CRL from which the revocation of this certificate can be checked.
// If not set, certificates will be issued without distribution points set.
repeated string c_r_l_distribution_points = 2 [(dev.f110.kubeproto.field) = {go_name: "CRLDistributionPoints", api_field_name: "crlDistributionPoints", inline: false}];
// The OCSP server list is an X.509 v3 extension that defines a list of
// URLs of OCSP responders. The OCSP responders can be queried for the
// revocation status of an issued certificate. If not set, the
// certificate will be issued with no OCSP servers set. For example, an
// OCSP server URL could be "http://ocsp.int-x3.letsencrypt.org".
repeated string o_c_s_p_servers = 3 [(dev.f110.kubeproto.field) = {go_name: "OCSPServers", api_field_name: "ocspServers", inline: false}];
}

message Certificate {
// Desired state of the Certificate resource.
CertificateSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];
// Status of the Certificate. This is set and managed automatically.
CertificateStatus status = 4 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", sub_resource: true, inline: false}];

option (dev.f110.kubeproto.kind) = {
};
}

message CertificateCondition {
// Type of the condition, known values are (`Ready`, `Issuing`).
CertificateConditionType type = 1 [(dev.f110.kubeproto.field) = {go_name: "Type", api_field_name: "type", inline: false}];
// Status of the condition, one of (`True`, `False`, `Unknown`).
.github.com.jetstack.cert_manager.pkg.apis.metav1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", inline: false}];
// LastTransitionTime is the timestamp corresponding to the last status
// change of this condition.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = {go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false}];
// Reason is a brief machine readable explanation for the condition's last
// transition.
optional string reason = 4 [(dev.f110.kubeproto.field) = {go_name: "Reason", api_field_name: "reason", inline: false}];
// Message is a human readable description of the details of the last
// transition, complementing reason.
optional string message = 5 [(dev.f110.kubeproto.field) = {go_name: "Message", api_field_name: "message", inline: false}];
// If set, this represents the .metadata.generation that the condition was
// set based upon.
// For instance, if .metadata.generation is currently 12, but the
// .status.condition[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the Certificate.
optional int64 observed_generation = 6 [(dev.f110.kubeproto.field) = {go_name: "ObservedGeneration", api_field_name: "observedGeneration", inline: false}];
}

message CertificateKeystores {
// JKS configures options for storing a JKS keystore in the
// `spec.secretName` Secret resource.
optional JKSKeystore j_k_s = 1 [(dev.f110.kubeproto.field) = {go_name: "JKS", api_field_name: "jks", inline: false}];
// PKCS12 configures options for storing a PKCS12 keystore in the
// `spec.secretName` Secret resource.
optional PKCS12Keystore p_k_c_s12 = 2 [(dev.f110.kubeproto.field) = {go_name: "PKCS12", api_field_name: "pkcs12", inline: false}];
}

message CertificateList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
.k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
repeated Certificate items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message CertificatePrivateKey {
// RotationPolicy controls how private keys should be regenerated when a
// re-issuance is being processed.
// If set to Never, a private key will only be generated if one does not
// already exist in the target `spec.secretName`. If one does exists but it
// does not have the correct algorithm or size, a warning will be raised
// to await user intervention.
// If set to Always, a private key matching the specified requirements
// will be generated whenever a re-issuance occurs.
// Default is 'Never' for backward compatibility.
string rotation_policy = 1 [(dev.f110.kubeproto.field) = {go_name: "RotationPolicy", api_field_name: "rotationPolicy", inline: false}];
// The private key cryptography standards (PKCS) encoding for this
// certificate's private key to be encoded in.
// If provided, allowed values are `PKCS1` and `PKCS8` standing for PKCS#1
// and PKCS#8, respectively.
// Defaults to `PKCS1` if not specified.
optional PrivateKeyEncoding encoding = 2 [(dev.f110.kubeproto.field) = {go_name: "Encoding", api_field_name: "encoding", inline: false}];
// Algorithm is the private key algorithm of the corresponding private key
// for this certificate. If provided, allowed values are either `RSA`,`Ed25519` or `ECDSA`
// If `algorithm` is specified and `size` is not provided,
// key size of 256 will be used for `ECDSA` key algorithm and
// key size of 2048 will be used for `RSA` key algorithm.
// key size is ignored when using the `Ed25519` key algorithm.
optional PrivateKeyAlgorithm algorithm = 3 [(dev.f110.kubeproto.field) = {go_name: "Algorithm", api_field_name: "algorithm", inline: false}];
// Size is the key bit size of the corresponding private key for this certificate.
// If `algorithm` is set to `RSA`, valid values are `2048`, `4096` or `8192`,
// and will default to `2048` if not specified.
// If `algorithm` is set to `ECDSA`, valid values are `256`, `384` or `521`,
// and will default to `256` if not specified.
// If `algorithm` is set to `Ed25519`, Size is ignored.
// No other values are allowed.
optional int32 size = 4 [(dev.f110.kubeproto.field) = {go_name: "Size", api_field_name: "size", inline: false}];
}

message CertificateRequest {
// Desired state of the CertificateRequest resource.
CertificateRequestSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];
// Status of the CertificateRequest. This is set and managed automatically.
CertificateRequestStatus status = 4 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", sub_resource: true, inline: false}];

option (dev.f110.kubeproto.kind) = {
};
}

message CertificateRequestCondition {
// Type of the condition, known values are (`Ready`, `InvalidRequest`,
// `Approved`, `Denied`).
CertificateRequestConditionType type = 1 [(dev.f110.kubeproto.field) = {go_name: "Type", api_field_name: "type", inline: false}];
// Status of the condition, one of (`True`, `False`, `Unknown`).
.github.com.jetstack.cert_manager.pkg.apis.metav1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", inline: false}];
// LastTransitionTime is the timestamp corresponding to the last status
// change of this condition.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = {go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false}];
// Reason is a brief machine readable explanation for the condition's last
// transition.
optional string reason = 4 [(dev.f110.kubeproto.field) = {go_name: "Reason", api_field_name: "reason", inline: false}];
// Message is a human readable description of the details of the last
// transition, complementing reason.
optional string message = 5 [(dev.f110.kubeproto.field) = {go_name: "Message", api_field_name: "message", inline: false}];
}

message CertificateRequestList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
.k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
repeated CertificateRequest items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message CertificateRequestSpec {
// The requested 'duration' (i.e. lifetime) of the Certificate.
// This option may be ignored/overridden by some issuer types.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration duration = 1 [(dev.f110.kubeproto.field) = {go_name: "Duration", api_field_name: "duration", inline: false}];
// IssuerRef is a reference to the issuer for this CertificateRequest.  If
// the `kind` field is not set, or set to `Issuer`, an Issuer resource with
// the given name in the same namespace as the CertificateRequest will be
// used.  If the `kind` field is set to `ClusterIssuer`, a ClusterIssuer with
// the provided name will be used. The `name` field in this stanza is
// required at all times. The group field refers to the API group of the
// issuer which defaults to `cert-manager.io` if empty.
.github.com.jetstack.cert_manager.pkg.apis.metav1.ObjectReference issuer_ref = 2 [(dev.f110.kubeproto.field) = {go_name: "IssuerRef", api_field_name: "issuerRef", inline: false}];
// The PEM-encoded x509 certificate signing request to be submitted to the
// CA for signing.
optional bytes request = 3 [(dev.f110.kubeproto.field) = {go_name: "Request", api_field_name: "request", inline: false}];
// IsCA will request to mark the certificate as valid for certificate signing
// when submitting to the issuer.
// This will automatically add the `cert sign` usage to the list of `usages`.
optional bool is_c_a = 4 [(dev.f110.kubeproto.field) = {go_name: "IsCA", api_field_name: "isCA", inline: false}];
// Usages is the set of x509 usages that are requested for the certificate.
// If usages are set they SHOULD be encoded inside the CSR spec
// Defaults to `digital signature` and `key encipherment` if not specified.
repeated KeyUsage usages = 5 [(dev.f110.kubeproto.field) = {go_name: "Usages", api_field_name: "usages", inline: false}];
// Username contains the name of the user that created the CertificateRequest.
// Populated by the cert-manager webhook on creation and immutable.
optional string username = 6 [(dev.f110.kubeproto.field) = {go_name: "Username", api_field_name: "username", inline: false}];
// UID contains the uid of the user that created the CertificateRequest.
// Populated by the cert-manager webhook on creation and immutable.
optional string uid = 7 [(dev.f110.kubeproto.field) = {go_name: "UID", api_field_name: "uid", inline: false}];
// Groups contains group membership of the user that created the CertificateRequest.
// Populated by the cert-manager webhook on creation and immutable.
repeated string groups = 8 [(dev.f110.kubeproto.field) = {go_name: "Groups", api_field_name: "groups", inline: false}];
// Extra contains extra attributes of the user that created the CertificateRequest.
// Populated by the cert-manager webhook on creation and immutable.
// This field can not be represented by protobuf.
// map<string, > extra = 9 [(dev.f110.kubeproto.field) = {go_name: "Extra", api_field_name: "extra", inline: false}];
}

message CertificateRequestStatus {
// List of status conditions to indicate the status of a CertificateRequest.
// Known condition types are `Ready` and `InvalidRequest`.
repeated CertificateRequestCondition conditions = 1 [(dev.f110.kubeproto.field) = {go_name: "Conditions", api_field_name: "conditions", inline: false}];
// The PEM encoded x509 certificate resulting from the certificate
// signing request.
// If not set, the CertificateRequest has either not been completed or has
// failed. More information on failure can be found by checking the
// `conditions` field.
optional bytes certificate = 2 [(dev.f110.kubeproto.field) = {go_name: "Certificate", api_field_name: "certificate", inline: false}];
// The PEM encoded x509 certificate of the signer, also known as the CA
// (Certificate Authority).
// This is set on a best-effort basis by different issuers.
// If not set, the CA is assumed to be unknown/not available.
optional bytes c_a = 3 [(dev.f110.kubeproto.field) = {go_name: "CA", api_field_name: "ca", inline: false}];
// FailureTime stores the time that this CertificateRequest failed. This is
// used to influence garbage collection and back-off.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time failure_time = 4 [(dev.f110.kubeproto.field) = {go_name: "FailureTime", api_field_name: "failureTime", inline: false}];
}

message CertificateSecretTemplate {
// Annotations is a key value map to be copied to the target Kubernetes Secret.
map<string, string> annotations = 1 [(dev.f110.kubeproto.field) = {go_name: "Annotations", api_field_name: "annotations", inline: false}];
// Labels is a key value map to be copied to the target Kubernetes Secret.
map<string, string> labels = 2 [(dev.f110.kubeproto.field) = {go_name: "Labels", api_field_name: "labels", inline: false}];
}

message CertificateSpec {
// Full X509 name specification (https://golang.org/pkg/crypto/x509/pkix/#Name).
optional X509Subject subject = 1 [(dev.f110.kubeproto.field) = {go_name: "Subject", api_field_name: "subject", inline: false}];
// CommonName is a common name to be used on the Certificate.
// The CommonName should have a length of 64 characters or fewer to avoid
// generating invalid CSRs.
// This value is ignored by TLS clients when any subject alt name is set.
// This is x509 behaviour: https://tools.ietf.org/html/rfc6125#section-6.4.4
optional string common_name = 2 [(dev.f110.kubeproto.field) = {go_name: "CommonName", api_field_name: "commonName", inline: false}];
// The requested 'duration' (i.e. lifetime) of the Certificate. This option
// may be ignored/overridden by some issuer types. If unset this defaults to
// 90 days. Certificate will be renewed either 2/3 through its duration or
// `renewBefore` period before its expiry, whichever is later. Minimum
// accepted duration is 1 hour. Value must be in units accepted by Go
// time.ParseDuration https://golang.org/pkg/time/#ParseDuration
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration duration = 3 [(dev.f110.kubeproto.field) = {go_name: "Duration", api_field_name: "duration", inline: false}];
// How long before the currently issued certificate's expiry
// cert-manager should renew the certificate. The default is 2/3 of the
// issued certificate's duration. Minimum accepted value is 5 minutes.
// Value must be in units accepted by Go time.ParseDuration
// https://golang.org/pkg/time/#ParseDuration
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration renew_before = 4 [(dev.f110.kubeproto.field) = {go_name: "RenewBefore", api_field_name: "renewBefore", inline: false}];
// DNSNames is a list of DNS subjectAltNames to be set on the Certificate.
repeated string dns_names = 5 [(dev.f110.kubeproto.field) = {go_name: "DNSNames", api_field_name: "dnsNames", inline: false}];
// IPAddresses is a list of IP address subjectAltNames to be set on the Certificate.
repeated string ip_addresses = 6 [(dev.f110.kubeproto.field) = {go_name: "IPAddresses", api_field_name: "ipAddresses", inline: false}];
// URIs is a list of URI subjectAltNames to be set on the Certificate.
repeated string uri_s = 7 [(dev.f110.kubeproto.field) = {go_name: "URIs", api_field_name: "uris", inline: false}];
// EmailAddresses is a list of email subjectAltNames to be set on the Certificate.
repeated string email_addresses = 8 [(dev.f110.kubeproto.field) = {go_name: "EmailAddresses", api_field_name: "emailAddresses", inline: false}];
// SecretName is the name of the secret resource that will be automatically
// created and managed by this Certificate resource.
// It will be populated with a private key and certificate, signed by the
// denoted issuer.
string secret_name = 9 [(dev.f110.kubeproto.field) = {go_name: "SecretName", api_field_name: "secretName", inline: false}];
// SecretTemplate defines annotations and labels to be propagated
// to the Kubernetes Secret when it is created or updated. Once created,
// labels and annotations are not yet removed from the Secret when they are
// removed from the template. See https://github.com/jetstack/cert-manager/issues/4292
optional CertificateSecretTemplate secret_template = 10 [(dev.f110.kubeproto.field) = {go_name: "SecretTemplate", api_field_name: "secretTemplate", inline: false}];
// Keystores configures additional keystore output formats stored in the
// `secretName` Secret resource.
optional CertificateKeystores keystores = 11 [(dev.f110.kubeproto.field) = {go_name: "Keystores", api_field_name: "keystores", inline: false}];
// IssuerRef is a reference to the issuer for this certificate.
// If the `kind` field is not set, or set to `Issuer`, an Issuer resource
// with the given name in the same namespace as the Certificate will be used.
// If the `kind` field is set to `ClusterIssuer`, a ClusterIssuer with the
// provided name will be used.
// The `name` field in this stanza is required at all times.
.github.com.jetstack.cert_manager.pkg.apis.metav1.ObjectReference issuer_ref = 12 [(dev.f110.kubeproto.field) = {go_name: "IssuerRef", api_field_name: "issuerRef", inline: false}];
// IsCA will mark this Certificate as valid for certificate signing.
// This will automatically add the `cert sign` usage to the list of `usages`.
optional bool is_c_a = 13 [(dev.f110.kubeproto.field) = {go_name: "IsCA", api_field_name: "isCA", inline: false}];
// Usages is the set of x509 usages that are requested for the certificate.
// Defaults to `digital signature` and `key encipherment` if not specified.
repeated KeyUsage usages = 14 [(dev.f110.kubeproto.field) = {go_name: "Usages", api_field_name: "usages", inline: false}];
// Options to control private keys used for the Certificate.
optional CertificatePrivateKey private_key = 15 [(dev.f110.kubeproto.field) = {go_name: "PrivateKey", api_field_name: "privateKey", inline: false}];
// EncodeUsagesInRequest controls whether key usages should be present
// in the CertificateRequest
optional bool encode_usages_in_request = 16 [(dev.f110.kubeproto.field) = {go_name: "EncodeUsagesInRequest", api_field_name: "encodeUsagesInRequest", inline: false}];
// revisionHistoryLimit is the maximum number of CertificateRequest revisions
// that are maintained in the Certificate's history. Each revision represents
// a single `CertificateRequest` created by this Certificate, either when it
// was created, renewed, or Spec was changed. Revisions will be removed by
// oldest first if the number of revisions exceeds this number. If set,
// revisionHistoryLimit must be a value of `1` or greater. If unset (`nil`),
// revisions will not be garbage collected. Default value is `nil`.
optional int32 revision_history_limit = 17 [(dev.f110.kubeproto.field) = {go_name: "RevisionHistoryLimit", api_field_name: "revisionHistoryLimit", inline: false}];
}

message CertificateStatus {
// List of status conditions to indicate the status of certificates.
// Known condition types are `Ready` and `Issuing`.
repeated CertificateCondition conditions = 1 [(dev.f110.kubeproto.field) = {go_name: "Conditions", api_field_name: "conditions", inline: false}];
// LastFailureTime is the time as recorded by the Certificate controller
// of the most recent failure to complete a CertificateRequest for this
// Certificate resource.
// If set, cert-manager will not re-request another Certificate until
// 1 hour has elapsed from this time.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_failure_time = 2 [(dev.f110.kubeproto.field) = {go_name: "LastFailureTime", api_field_name: "lastFailureTime", inline: false}];
// The time after which the certificate stored in the secret named
// by this resource in spec.secretName is valid.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time not_before = 3 [(dev.f110.kubeproto.field) = {go_name: "NotBefore", api_field_name: "notBefore", inline: false}];
// The expiration time of the certificate stored in the secret named
// by this resource in `spec.secretName`.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time not_after = 4 [(dev.f110.kubeproto.field) = {go_name: "NotAfter", api_field_name: "notAfter", inline: false}];
// RenewalTime is the time at which the certificate will be next
// renewed.
// If not set, no upcoming renewal is scheduled.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time renewal_time = 5 [(dev.f110.kubeproto.field) = {go_name: "RenewalTime", api_field_name: "renewalTime", inline: false}];
// The current 'revision' of the certificate as issued.
// When a CertificateRequest resource is created, it will have the
// `cert-manager.io/certificate-revision` set to one greater than the
// current value of this field.
// Upon issuance, this field will be set to the value of the annotation
// on the CertificateRequest resource used to issue the certificate.
// Persisting the value on the CertificateRequest resource allows the
// certificates controller to know whether a request is part of an old
// issuance or if it is part of the ongoing revision's issuance by
// checking if the revision value in the annotation is greater than this
// field.
optional int32 revision = 6 [(dev.f110.kubeproto.field) = {go_name: "Revision", api_field_name: "revision", inline: false}];
// The name of the Secret resource containing the private key to be used
// for the next certificate iteration.
// The keymanager controller will automatically set this field if the
// `Issuing` condition is set to `True`.
// It will automatically unset this field when the Issuing condition is
// not set or False.
optional string next_private_key_secret_name = 7 [(dev.f110.kubeproto.field) = {go_name: "NextPrivateKeySecretName", api_field_name: "nextPrivateKeySecretName", inline: false}];
}

message ClusterIssuer {
// Desired state of the ClusterIssuer resource.
IssuerSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];
// Status of the ClusterIssuer. This is set and managed automatically.
IssuerStatus status = 4 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", sub_resource: true, inline: false}];

option (dev.f110.kubeproto.kind) = {
scope: SCOPE_CLUSTER
};
}

message ClusterIssuerList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
.k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
repeated ClusterIssuer items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message Issuer {
// Desired state of the Issuer resource.
IssuerSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];
// Status of the Issuer. This is set and managed automatically.
IssuerStatus status = 4 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", sub_resource: true, inline: false}];

option (dev.f110.kubeproto.kind) = {
};
}

message IssuerCondition {
// Type of the condition, known values are (`Ready`).
IssuerConditionType type = 1 [(dev.f110.kubeproto.field) = {go_name: "Type", api_field_name: "type", inline: false}];
// Status of the condition, one of (`True`, `False`, `Unknown`).
.github.com.jetstack.cert_manager.pkg.apis.metav1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", inline: false}];
// LastTransitionTime is the timestamp corresponding to the last status
// change of this condition.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = {go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false}];
// Reason is a brief machine readable explanation for the condition's last
// transition.
optional string reason = 4 [(dev.f110.kubeproto.field) = {go_name: "Reason", api_field_name: "reason", inline: false}];
// Message is a human readable description of the details of the last
// transition, complementing reason.
optional string message = 5 [(dev.f110.kubeproto.field) = {go_name: "Message", api_field_name: "message", inline: false}];
// If set, this represents the .metadata.generation that the condition was
// set based upon.
// For instance, if .metadata.generation is currently 12, but the
// .status.condition[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the Issuer.
optional int64 observed_generation = 6 [(dev.f110.kubeproto.field) = {go_name: "ObservedGeneration", api_field_name: "observedGeneration", inline: false}];
}

message IssuerConfig {
// ACME configures this issuer to communicate with a RFC8555 (ACME) server
// to obtain signed x509 certificates.
optional .github.com.jetstack.cert_manager.pkg.apis.acmev1.ACMEIssuer acme = 1 [(dev.f110.kubeproto.field) = {go_name: "ACME", api_field_name: "acme", inline: false}];
// CA configures this issuer to sign certificates using a signing CA keypair
// stored in a Secret resource.
// This is used to build internal PKIs that are managed by cert-manager.
optional CAIssuer c_a = 2 [(dev.f110.kubeproto.field) = {go_name: "CA", api_field_name: "ca", inline: false}];
// Vault configures this issuer to sign certificates using a HashiCorp Vault
// PKI backend.
optional VaultIssuer vault = 3 [(dev.f110.kubeproto.field) = {go_name: "Vault", api_field_name: "vault", inline: false}];
// SelfSigned configures this issuer to 'self sign' certificates using the
// private key used to create the CertificateRequest object.
optional SelfSignedIssuer self_signed = 4 [(dev.f110.kubeproto.field) = {go_name: "SelfSigned", api_field_name: "selfSigned", inline: false}];
// Venafi configures this issuer to sign certificates using a Venafi TPP
// or Venafi Cloud policy zone.
optional VenafiIssuer venafi = 5 [(dev.f110.kubeproto.field) = {go_name: "Venafi", api_field_name: "venafi", inline: false}];
}

message IssuerList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
.k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
repeated Issuer items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message IssuerSpec {
IssuerConfig issuer_config = 1 [(dev.f110.kubeproto.field) = {go_name: "IssuerConfig", inline: true}];
}

message IssuerStatus {
// List of status conditions to indicate the status of a CertificateRequest.
// Known condition types are `Ready`.
repeated IssuerCondition conditions = 1 [(dev.f110.kubeproto.field) = {go_name: "Conditions", api_field_name: "conditions", inline: false}];
// ACME specific status options.
// This field should only be set if the Issuer is configured to use an ACME
// server to issue certificates.
optional .github.com.jetstack.cert_manager.pkg.apis.acmev1.ACMEIssuerStatus acme = 2 [(dev.f110.kubeproto.field) = {go_name: "ACME", api_field_name: "acme", inline: false}];
}

message JKSKeystore {
// Create enables JKS keystore creation for the Certificate.
// If true, a file named `keystore.jks` will be created in the target
// Secret resource, encrypted using the password stored in
// `passwordSecretRef`.
// The keystore file will only be updated upon re-issuance.
// A file named `truststore.jks` will also be created in the target
// Secret resource, encrypted using the password stored in
// `passwordSecretRef` containing the issuing Certificate Authority
bool create = 1 [(dev.f110.kubeproto.field) = {go_name: "Create", api_field_name: "create", inline: false}];
// PasswordSecretRef is a reference to a key in a Secret resource
// containing the password used to encrypt the JKS keystore.
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector password_secret_ref = 2 [(dev.f110.kubeproto.field) = {go_name: "PasswordSecretRef", api_field_name: "passwordSecretRef", inline: false}];
}

message PKCS12Keystore {
// Create enables PKCS12 keystore creation for the Certificate.
// If true, a file named `keystore.p12` will be created in the target
// Secret resource, encrypted using the password stored in
// `passwordSecretRef`.
// The keystore file will only be updated upon re-issuance.
// A file named `truststore.p12` will also be created in the target
// Secret resource, encrypted using the password stored in
// `passwordSecretRef` containing the issuing Certificate Authority
bool create = 1 [(dev.f110.kubeproto.field) = {go_name: "Create", api_field_name: "create", inline: false}];
// PasswordSecretRef is a reference to a key in a Secret resource
// containing the password used to encrypt the PKCS12 keystore.
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector password_secret_ref = 2 [(dev.f110.kubeproto.field) = {go_name: "PasswordSecretRef", api_field_name: "passwordSecretRef", inline: false}];
}

message SelfSignedIssuer {
// The CRL distribution points is an X.509 v3 certificate extension which identifies
// the location of the CRL from which the revocation of this certificate can be checked.
// If not set certificate will be issued without CDP. Values are strings.
repeated string c_r_l_distribution_points = 1 [(dev.f110.kubeproto.field) = {go_name: "CRLDistributionPoints", api_field_name: "crlDistributionPoints", inline: false}];
}

message VaultAppRole {
// Path where the App Role authentication backend is mounted in Vault, e.g:
// "approle"
string path = 1 [(dev.f110.kubeproto.field) = {go_name: "Path", api_field_name: "path", inline: false}];
// RoleID configured in the App Role authentication backend when setting
// up the authentication backend in Vault.
string role_id = 2 [(dev.f110.kubeproto.field) = {go_name: "RoleId", api_field_name: "roleId", inline: false}];
// Reference to a key in a Secret that contains the App Role secret used
// to authenticate with Vault.
// The `key` field must be specified and denotes which entry within the Secret
// resource is used as the app role secret.
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector secret_ref = 3 [(dev.f110.kubeproto.field) = {go_name: "SecretRef", api_field_name: "secretRef", inline: false}];
}

message VaultAuth {
// TokenSecretRef authenticates with Vault by presenting a token.
optional .github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector token_secret_ref = 1 [(dev.f110.kubeproto.field) = {go_name: "TokenSecretRef", api_field_name: "tokenSecretRef", inline: false}];
// AppRole authenticates with Vault using the App Role auth mechanism,
// with the role and secret stored in a Kubernetes Secret resource.
optional VaultAppRole app_role = 2 [(dev.f110.kubeproto.field) = {go_name: "AppRole", api_field_name: "appRole", inline: false}];
// Kubernetes authenticates with Vault by passing the ServiceAccount
// token stored in the named Secret resource to the Vault server.
optional VaultKubernetesAuth kubernetes = 3 [(dev.f110.kubeproto.field) = {go_name: "Kubernetes", api_field_name: "kubernetes", inline: false}];
}

message VaultIssuer {
// Auth configures how cert-manager authenticates with the Vault server.
VaultAuth auth = 1 [(dev.f110.kubeproto.field) = {go_name: "Auth", api_field_name: "auth", inline: false}];
// Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
string server = 2 [(dev.f110.kubeproto.field) = {go_name: "Server", api_field_name: "server", inline: false}];
// Path is the mount path of the Vault PKI backend's `sign` endpoint, e.g:
// "my_pki_mount/sign/my-role-name".
string path = 3 [(dev.f110.kubeproto.field) = {go_name: "Path", api_field_name: "path", inline: false}];
// Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1"
// More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
optional string namespace = 4 [(dev.f110.kubeproto.field) = {go_name: "Namespace", api_field_name: "namespace", inline: false}];
// PEM-encoded CA bundle (base64-encoded) used to validate Vault server
// certificate. Only used if the Server URL is using HTTPS protocol. This
// parameter is ignored for plain HTTP protocol connection. If not set the
// system root certificates are used to validate the TLS connection.
optional bytes c_a_bundle = 5 [(dev.f110.kubeproto.field) = {go_name: "CABundle", api_field_name: "caBundle", inline: false}];
}

message VaultKubernetesAuth {
// The Vault mountPath here is the mount path to use when authenticating with
// Vault. For example, setting a value to `/v1/auth/foo`, will use the path
// `/v1/auth/foo/login` to authenticate with Vault. If unspecified, the
// default value "/v1/auth/kubernetes" will be used.
optional string path = 1 [(dev.f110.kubeproto.field) = {go_name: "Path", api_field_name: "mountPath", inline: false}];
// The required Secret field containing a Kubernetes ServiceAccount JWT used
// for authenticating with Vault. Use of 'ambient credentials' is not
// supported.
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector secret_ref = 2 [(dev.f110.kubeproto.field) = {go_name: "SecretRef", api_field_name: "secretRef", inline: false}];
// A required field containing the Vault Role to assume. A Role binds a
// Kubernetes ServiceAccount with a set of Vault policies.
string role = 3 [(dev.f110.kubeproto.field) = {go_name: "Role", api_field_name: "role", inline: false}];
}

message VenafiCloud {
// URL is the base URL for Venafi Cloud.
// Defaults to "https://api.venafi.cloud/v1".
optional string url = 1 [(dev.f110.kubeproto.field) = {go_name: "URL", api_field_name: "url", inline: false}];
// APITokenSecretRef is a secret key selector for the Venafi Cloud API token.
.github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector api_token_secret_ref = 2 [(dev.f110.kubeproto.field) = {go_name: "APITokenSecretRef", api_field_name: "apiTokenSecretRef", inline: false}];
}

message VenafiIssuer {
// Zone is the Venafi Policy Zone to use for this issuer.
// All requests made to the Venafi platform will be restricted by the named
// zone policy.
// This field is required.
string zone = 1 [(dev.f110.kubeproto.field) = {go_name: "Zone", api_field_name: "zone", inline: false}];
// TPP specifies Trust Protection Platform configuration settings.
// Only one of TPP or Cloud may be specified.
optional VenafiTPP t_p_p = 2 [(dev.f110.kubeproto.field) = {go_name: "TPP", api_field_name: "tpp", inline: false}];
// Cloud specifies the Venafi cloud configuration settings.
// Only one of TPP or Cloud may be specified.
optional VenafiCloud cloud = 3 [(dev.f110.kubeproto.field) = {go_name: "Cloud", api_field_name: "cloud", inline: false}];
}

message VenafiTPP {
// URL is the base URL for the vedsdk endpoint of the Venafi TPP instance,
// for example: "https://tpp.example.com/vedsdk".
string url = 1 [(dev.f110.kubeproto.field) = {go_name: "URL", api_field_name: "url", inline: false}];
// CredentialsRef is a reference to a Secret containing the username and
// password for the TPP server.
// The secret must contain two keys, 'username' and 'password'.
.github.com.jetstack.cert_manager.pkg.apis.metav1.LocalObjectReference credentials_ref = 2 [(dev.f110.kubeproto.field) = {go_name: "CredentialsRef", api_field_name: "credentialsRef", inline: false}];
// CABundle is a PEM encoded TLS certificate to use to verify connections to
// the TPP instance.
// If specified, system roots will not be used and the issuing CA for the
// TPP instance must be verifiable using the provided root.
// If not specified, the connection will be verified using the cert-manager
// system root certificates.
optional bytes c_a_bundle = 3 [(dev.f110.kubeproto.field) = {go_name: "CABundle", api_field_name: "caBundle", inline: false}];
}

message X509Subject {
// Organizations to be used on the Certificate.
repeated string organizations = 1 [(dev.f110.kubeproto.field) = {go_name: "Organizations", api_field_name: "organizations", inline: false}];
// Countries to be used on the Certificate.
repeated string countries = 2 [(dev.f110.kubeproto.field) = {go_name: "Countries", api_field_name: "countries", inline: false}];
// Organizational Units to be used on the Certificate.
repeated string organizational_units = 3 [(dev.f110.kubeproto.field) = {go_name: "OrganizationalUnits", api_field_name: "organizationalUnits", inline: false}];
// Cities to be used on the Certificate.
repeated string localities = 4 [(dev.f110.kubeproto.field) = {go_name: "Localities", api_field_name: "localities", inline: false}];
// State/Provinces to be used on the Certificate.
repeated string provinces = 5 [(dev.f110.kubeproto.field) = {go_name: "Provinces", api_field_name: "provinces", inline: false}];
// Street addresses to be used on the Certificate.
repeated string street_addresses = 6 [(dev.f110.kubeproto.field) = {go_name: "StreetAddresses", api_field_name: "streetAddresses", inline: false}];
// Postal codes to be used on the Certificate.
repeated string postal_codes = 7 [(dev.f110.kubeproto.field) = {go_name: "PostalCodes", api_field_name: "postalCodes", inline: false}];
// Serial number to be used on the Certificate.
optional string serial_number = 8 [(dev.f110.kubeproto.field) = {go_name: "SerialNumber", api_field_name: "serialNumber", inline: false}];
}

