// Generated by: gen-go-to-protobuf
syntax = "proto3";
package github.com.jetstack.cert_manager.pkg.apis.certmanagerv1;
option  go_package              = "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1";
option (dev.f110.kubeproto.k8s) = {
  sub_group: "cert-manager.io",
  version: "v1",
};

import "kube.proto";
import "operator/proto/github.com/jetstack/cert-manager/pkg/apis/acmev1/generated.proto";
import "operator/proto/github.com/jetstack/cert-manager/pkg/apis/metav1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";

enum CertificateConditionType {
  CERTIFICATE_CONDITION_TYPE_READY   = 0;
  CERTIFICATE_CONDITION_TYPE_ISSUING = 1;
}

enum CertificateRequestConditionType {
  CERTIFICATE_REQUEST_CONDITION_TYPE_READY           = 0;
  CERTIFICATE_REQUEST_CONDITION_TYPE_INVALID_REQUEST = 1;
  CERTIFICATE_REQUEST_CONDITION_TYPE_APPROVED        = 2;
  CERTIFICATE_REQUEST_CONDITION_TYPE_DENIED          = 3;
}

enum IssuerConditionType {
  ISSUER_CONDITION_TYPE_READY = 0;
}

enum KeyUsage {
  KEY_USAGE_SIGNING            = 0 [(dev.f110.kubeproto.value) = { value: "signing" }];
  KEY_USAGE_DIGITAL_SIGNATURE  = 1 [(dev.f110.kubeproto.value) = { value: "digital signature" }];
  KEY_USAGE_CONTENT_COMMITMENT = 2 [(dev.f110.kubeproto.value) = { value: "content commitment" }];
  KEY_USAGE_KEY_ENCIPHERMENT   = 3 [(dev.f110.kubeproto.value) = { value: "key encipherment" }];
  KEY_USAGE_KEY_AGREEMENT      = 4 [(dev.f110.kubeproto.value) = { value: "key agreement" }];
  KEY_USAGE_DATA_ENCIPHERMENT  = 5 [(dev.f110.kubeproto.value) = { value: "data encipherment" }];
  KEY_USAGE_CERT_SIGN          = 6 [(dev.f110.kubeproto.value) = { value: "cert sign" }];
  KEY_USAGE_CRL_SIGN           = 7 [(dev.f110.kubeproto.value) = { value: "crl sign" }];
  KEY_USAGE_ENCIPHER_ONLY      = 8 [(dev.f110.kubeproto.value) = { value: "encipher only" }];
  KEY_USAGE_DECIPHER_ONLY      = 9 [(dev.f110.kubeproto.value) = { value: "decipher only" }];
  KEY_USAGE_ANY                = 10 [(dev.f110.kubeproto.value) = { value: "any" }];
  KEY_USAGE_SERVER_AUTH        = 11 [(dev.f110.kubeproto.value) = { value: "server auth" }];
  KEY_USAGE_CLIENT_AUTH        = 12 [(dev.f110.kubeproto.value) = { value: "client auth" }];
  KEY_USAGE_CODE_SIGNING       = 13 [(dev.f110.kubeproto.value) = { value: "code signing" }];
  KEY_USAGE_EMAIL_PROTECTION   = 14 [(dev.f110.kubeproto.value) = { value: "email protection" }];
  KEY_USAGE_S_MIME             = 15 [(dev.f110.kubeproto.value) = { value: "s/mime" }];
  KEY_USAGE_IPSEC_END_SYSTEM   = 16 [(dev.f110.kubeproto.value) = { value: "ipsec end system" }];
  KEY_USAGE_IPSEC_TUNNEL       = 17 [(dev.f110.kubeproto.value) = { value: "ipsec tunnel" }];
  KEY_USAGE_IPSEC_USER         = 18 [(dev.f110.kubeproto.value) = { value: "ipsec user" }];
  KEY_USAGE_TIMESTAMPING       = 19 [(dev.f110.kubeproto.value) = { value: "timestamping" }];
  KEY_USAGE_OCSP_SIGNING       = 20 [(dev.f110.kubeproto.value) = { value: "ocsp signing" }];
  KEY_USAGE_MICROSOFT_SGC      = 21 [(dev.f110.kubeproto.value) = { value: "microsoft sgc" }];
  KEY_USAGE_NETSCAPE_SGC       = 22 [(dev.f110.kubeproto.value) = { value: "netscape sgc" }];
}

enum PrivateKeyAlgorithm {
  PRIVATE_KEY_ALGORITHM_R_S_A     = 0;
  PRIVATE_KEY_ALGORITHM_E_C_D_S_A = 1;
  PRIVATE_KEY_ALGORITHM_ED25519   = 2;
}

enum PrivateKeyEncoding {
  PRIVATE_KEY_ENCODING_P_K_C_S1 = 0;
  PRIVATE_KEY_ENCODING_P_K_C_S8 = 1;
}

message CAIssuer {
  // SecretName is the name of the secret used to sign Certificates issued
  // by this Issuer.
  string secret_name = 1 [(dev.f110.kubeproto.field) = { go_name: "SecretName", api_field_name: "secretName", inline: false }];
  // The CRL distribution points is an X.509 v3 certificate extension which identifies
  // the location of the CRL from which the revocation of this certificate can be checked.
  // If not set, certificates will be issued without distribution points set.
  repeated string c_r_l_distribution_points = 2 [(dev.f110.kubeproto.field) = { go_name: "CRLDistributionPoints", api_field_name: "crlDistributionPoints", inline: false }];
  // The OCSP server list is an X.509 v3 extension that defines a list of
  // URLs of OCSP responders. The OCSP responders can be queried for the
  // revocation status of an issued certificate. If not set, the
  // certificate will be issued with no OCSP servers set. For example, an
  // OCSP server URL could be "http://ocsp.int-x3.letsencrypt.org".
  repeated string o_c_s_p_servers = 3 [(dev.f110.kubeproto.field) = { go_name: "OCSPServers", api_field_name: "ocspServers", inline: false }];
}

message Certificate {
  // Desired state of the Certificate resource.
  CertificateSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status of the Certificate. This is set and managed automatically.
  CertificateStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message CertificateCondition {
  // Type of the condition, known values are (`Ready`, `Issuing`).
  CertificateConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition, one of (`True`, `False`, `Unknown`).
  github.com.jetstack.cert_manager.pkg.apis.metav1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // LastTransitionTime is the timestamp corresponding to the last status
  // change of this condition.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // Reason is a brief machine readable explanation for the condition's last
  // transition.
  optional string reason = 4 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // Message is a human readable description of the details of the last
  // transition, complementing reason.
  optional string message = 5 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
  // If set, this represents the .metadata.generation that the condition was
  // set based upon.
  // For instance, if .metadata.generation is currently 12, but the
  // .status.condition[x].observedGeneration is 9, the condition is out of date
  // with respect to the current state of the Certificate.
  optional int64 observed_generation = 6 [(dev.f110.kubeproto.field) = { go_name: "ObservedGeneration", api_field_name: "observedGeneration", inline: false }];
}

message CertificateKeystores {
  // JKS configures options for storing a JKS keystore in the
  // `spec.secretName` Secret resource.
  optional JKSKeystore j_k_s = 1 [(dev.f110.kubeproto.field) = { go_name: "JKS", api_field_name: "jks", inline: false }];
  // PKCS12 configures options for storing a PKCS12 keystore in the
  // `spec.secretName` Secret resource.
  optional PKCS12Keystore p_k_c_s12 = 2 [(dev.f110.kubeproto.field) = { go_name: "PKCS12", api_field_name: "pkcs12", inline: false }];
}

message CertificateList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated Certificate                          items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message CertificatePrivateKey {
  // RotationPolicy controls how private keys should be regenerated when a
  // re-issuance is being processed.
  // If set to Never, a private key will only be generated if one does not
  // already exist in the target `spec.secretName`. If one does exists but it
  // does not have the correct algorithm or size, a warning will be raised
  // to await user intervention.
  // If set to Always, a private key matching the specified requirements
  // will be generated whenever a re-issuance occurs.
  // Default is 'Never' for backward compatibility.
  string rotation_policy = 1 [(dev.f110.kubeproto.field) = { go_name: "RotationPolicy", api_field_name: "rotationPolicy", inline: false }];
  // The private key cryptography standards (PKCS) encoding for this
  // certificate's private key to be encoded in.
  // If provided, allowed values are `PKCS1` and `PKCS8` standing for PKCS#1
  // and PKCS#8, respectively.
  // Defaults to `PKCS1` if not specified.
  optional PrivateKeyEncoding encoding = 2 [(dev.f110.kubeproto.field) = { go_name: "Encoding", api_field_name: "encoding", inline: false }];
  // Algorithm is the private key algorithm of the corresponding private key
  // for this certificate. If provided, allowed values are either `RSA`,`Ed25519` or `ECDSA`
  // If `algorithm` is specified and `size` is not provided,
  // key size of 256 will be used for `ECDSA` key algorithm and
  // key size of 2048 will be used for `RSA` key algorithm.
  // key size is ignored when using the `Ed25519` key algorithm.
  optional PrivateKeyAlgorithm algorithm = 3 [(dev.f110.kubeproto.field) = { go_name: "Algorithm", api_field_name: "algorithm", inline: false }];
  // Size is the key bit size of the corresponding private key for this certificate.
  // If `algorithm` is set to `RSA`, valid values are `2048`, `4096` or `8192`,
  // and will default to `2048` if not specified.
  // If `algorithm` is set to `ECDSA`, valid values are `256`, `384` or `521`,
  // and will default to `256` if not specified.
  // If `algorithm` is set to `Ed25519`, Size is ignored.
  // No other values are allowed.
  optional int32 size = 4 [(dev.f110.kubeproto.field) = { go_name: "Size", api_field_name: "size", inline: false }];
}

message CertificateRequest {
  // Desired state of the CertificateRequest resource.
  CertificateRequestSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status of the CertificateRequest. This is set and managed automatically.
  CertificateRequestStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message CertificateRequestCondition {
  // Type of the condition, known values are (`Ready`, `InvalidRequest`,
  // `Approved`, `Denied`).
  CertificateRequestConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition, one of (`True`, `False`, `Unknown`).
  github.com.jetstack.cert_manager.pkg.apis.metav1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // LastTransitionTime is the timestamp corresponding to the last status
  // change of this condition.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // Reason is a brief machine readable explanation for the condition's last
  // transition.
  optional string reason = 4 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // Message is a human readable description of the details of the last
  // transition, complementing reason.
  optional string message = 5 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message CertificateRequestList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated CertificateRequest                   items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message CertificateRequestSpec {
  // The requested 'duration' (i.e. lifetime) of the Certificate.
  // This option may be ignored/overridden by some issuer types.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration duration = 1 [(dev.f110.kubeproto.field) = { go_name: "Duration", api_field_name: "duration", inline: false }];
  // IssuerRef is a reference to the issuer for this CertificateRequest.  If
  // the `kind` field is not set, or set to `Issuer`, an Issuer resource with
  // the given name in the same namespace as the CertificateRequest will be
  // used.  If the `kind` field is set to `ClusterIssuer`, a ClusterIssuer with
  // the provided name will be used. The `name` field in this stanza is
  // required at all times. The group field refers to the API group of the
  // issuer which defaults to `cert-manager.io` if empty.
  github.com.jetstack.cert_manager.pkg.apis.metav1.ObjectReference issuer_ref = 2 [(dev.f110.kubeproto.field) = { go_name: "IssuerRef", api_field_name: "issuerRef", inline: false }];
  // The PEM-encoded x509 certificate signing request to be submitted to the
  // CA for signing.
  optional bytes request = 3 [(dev.f110.kubeproto.field) = { go_name: "Request", api_field_name: "request", inline: false }];
  // IsCA will request to mark the certificate as valid for certificate signing
  // when submitting to the issuer.
  // This will automatically add the `cert sign` usage to the list of `usages`.
  optional bool is_c_a = 4 [(dev.f110.kubeproto.field) = { go_name: "IsCA", api_field_name: "isCA", inline: false }];
  // Usages is the set of x509 usages that are requested for the certificate.
  // If usages are set they SHOULD be encoded inside the CSR spec
  // Defaults to `digital signature` and `key encipherment` if not specified.
  repeated KeyUsage usages = 5 [(dev.f110.kubeproto.field) = { go_name: "Usages", api_field_name: "usages", inline: false }];
  // Username contains the name of the user that created the CertificateRequest.
  // Populated by the cert-manager webhook on creation and immutable.
  optional string username = 6 [(dev.f110.kubeproto.field) = { go_name: "Username", api_field_name: "username", inline: false }];
  // UID contains the uid of the user that created the CertificateRequest.
  // Populated by the cert-manager webhook on creation and immutable.
  optional string uid = 7 [(dev.f110.kubeproto.field) = { go_name: "UID", api_field_name: "uid", inline: false }];
  // Groups contains group membership of the user that created the CertificateRequest.
  // Populated by the cert-manager webhook on creation and immutable.
  repeated string groups = 8 [(dev.f110.kubeproto.field) = { go_name: "Groups", api_field_name: "groups", inline: false }];
  // Extra contains extra attributes of the user that created the CertificateRequest.
  // Populated by the cert-manager webhook on creation and immutable.
  // This field can not be represented by protobuf.
  // map<string, > extra = 9 [(dev.f110.kubeproto.field) = {go_name: "Extra", api_field_name: "extra", inline: false}];
}

message CertificateRequestStatus {
  // List of status conditions to indicate the status of a CertificateRequest.
  // Known condition types are `Ready` and `InvalidRequest`.
  repeated CertificateRequestCondition conditions = 1 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // The PEM encoded x509 certificate resulting from the certificate
  // signing request.
  // If not set, the CertificateRequest has either not been completed or has
  // failed. More information on failure can be found by checking the
  // `conditions` field.
  optional bytes certificate = 2 [(dev.f110.kubeproto.field) = { go_name: "Certificate", api_field_name: "certificate", inline: false }];
  // The PEM encoded x509 certificate of the signer, also known as the CA
  // (Certificate Authority).
  // This is set on a best-effort basis by different issuers.
  // If not set, the CA is assumed to be unknown/not available.
  optional bytes c_a = 3 [(dev.f110.kubeproto.field) = { go_name: "CA", api_field_name: "ca", inline: false }];
  // FailureTime stores the time that this CertificateRequest failed. This is
  // used to influence garbage collection and back-off.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time failure_time = 4 [(dev.f110.kubeproto.field) = { go_name: "FailureTime", api_field_name: "failureTime", inline: false }];
}

message CertificateSecretTemplate {
  // Annotations is a key value map to be copied to the target Kubernetes Secret.
  map<string, string> annotations = 1 [(dev.f110.kubeproto.field) = { go_name: "Annotations", api_field_name: "annotations", inline: false }];
  // Labels is a key value map to be copied to the target Kubernetes Secret.
  map<string, string> labels = 2 [(dev.f110.kubeproto.field) = { go_name: "Labels", api_field_name: "labels", inline: false }];
}

message CertificateSpec {
  // Full X509 name specification (https://golang.org/pkg/crypto/x509/pkix/#Name).
  optional X509Subject subject = 1 [(dev.f110.kubeproto.field) = { go_name: "Subject", api_field_name: "subject", inline: false }];
  // CommonName is a common name to be used on the Certificate.
  // The CommonName should have a length of 64 characters or fewer to avoid
  // generating invalid CSRs.
  // This value is ignored by TLS clients when any subject alt name is set.
  // This is x509 behaviour: https://tools.ietf.org/html/rfc6125#section-6.4.4
  optional string common_name = 2 [(dev.f110.kubeproto.field) = { go_name: "CommonName", api_field_name: "commonName", inline: false }];
  // The requested 'duration' (i.e. lifetime) of the Certificate. This option
  // may be ignored/overridden by some issuer types. If unset this defaults to
  // 90 days. Certificate will be renewed either 2/3 through its duration or
  // `renewBefore` period before its expiry, whichever is later. Minimum
  // accepted duration is 1 hour. Value must be in units accepted by Go
  // time.ParseDuration https://golang.org/pkg/time/#ParseDuration
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration duration = 3 [(dev.f110.kubeproto.field) = { go_name: "Duration", api_field_name: "duration", inline: false }];
  // How long before the currently issued certificate's expiry
  // cert-manager should renew the certificate. The default is 2/3 of the
  // issued certificate's duration. Minimum accepted value is 5 minutes.
  // Value must be in units accepted by Go time.ParseDuration
  // https://golang.org/pkg/time/#ParseDuration
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration renew_before = 4 [(dev.f110.kubeproto.field) = { go_name: "RenewBefore", api_field_name: "renewBefore", inline: false }];
  // DNSNames is a list of DNS subjectAltNames to be set on the Certificate.
  repeated string dns_names = 5 [(dev.f110.kubeproto.field) = { go_name: "DNSNames", api_field_name: "dnsNames", inline: false }];
  // IPAddresses is a list of IP address subjectAltNames to be set on the Certificate.
  repeated string ip_addresses = 6 [(dev.f110.kubeproto.field) = { go_name: "IPAddresses", api_field_name: "ipAddresses", inline: false }];
  // URIs is a list of URI subjectAltNames to be set on the Certificate.
  repeated string uri_s = 7 [(dev.f110.kubeproto.field) = { go_name: "URIs", api_field_name: "uris", inline: false }];
  // EmailAddresses is a list of email subjectAltNames to be set on the Certificate.
  repeated string email_addresses = 8 [(dev.f110.kubeproto.field) = { go_name: "EmailAddresses", api_field_name: "emailAddresses", inline: false }];
  // SecretName is the name of the secret resource that will be automatically
  // created and managed by this Certificate resource.
  // It will be populated with a private key and certificate, signed by the
  // denoted issuer.
  string secret_name = 9 [(dev.f110.kubeproto.field) = { go_name: "SecretName", api_field_name: "secretName", inline: false }];
  // SecretTemplate defines annotations and labels to be propagated
  // to the Kubernetes Secret when it is created or updated. Once created,
  // labels and annotations are not yet removed from the Secret when they are
  // removed from the template. See https://github.com/jetstack/cert-manager/issues/4292
  optional CertificateSecretTemplate secret_template = 10 [(dev.f110.kubeproto.field) = { go_name: "SecretTemplate", api_field_name: "secretTemplate", inline: false }];
  // Keystores configures additional keystore output formats stored in the
  // `secretName` Secret resource.
  optional CertificateKeystores keystores = 11 [(dev.f110.kubeproto.field) = { go_name: "Keystores", api_field_name: "keystores", inline: false }];
  // IssuerRef is a reference to the issuer for this certificate.
  // If the `kind` field is not set, or set to `Issuer`, an Issuer resource
  // with the given name in the same namespace as the Certificate will be used.
  // If the `kind` field is set to `ClusterIssuer`, a ClusterIssuer with the
  // provided name will be used.
  // The `name` field in this stanza is required at all times.
  github.com.jetstack.cert_manager.pkg.apis.metav1.ObjectReference issuer_ref = 12 [(dev.f110.kubeproto.field) = { go_name: "IssuerRef", api_field_name: "issuerRef", inline: false }];
  // IsCA will mark this Certificate as valid for certificate signing.
  // This will automatically add the `cert sign` usage to the list of `usages`.
  optional bool is_c_a = 13 [(dev.f110.kubeproto.field) = { go_name: "IsCA", api_field_name: "isCA", inline: false }];
  // Usages is the set of x509 usages that are requested for the certificate.
  // Defaults to `digital signature` and `key encipherment` if not specified.
  repeated KeyUsage usages = 14 [(dev.f110.kubeproto.field) = { go_name: "Usages", api_field_name: "usages", inline: false }];
  // Options to control private keys used for the Certificate.
  optional CertificatePrivateKey private_key = 15 [(dev.f110.kubeproto.field) = { go_name: "PrivateKey", api_field_name: "privateKey", inline: false }];
  // EncodeUsagesInRequest controls whether key usages should be present
  // in the CertificateRequest
  optional bool encode_usages_in_request = 16 [(dev.f110.kubeproto.field) = { go_name: "EncodeUsagesInRequest", api_field_name: "encodeUsagesInRequest", inline: false }];
  // revisionHistoryLimit is the maximum number of CertificateRequest revisions
  // that are maintained in the Certificate's history. Each revision represents
  // a single `CertificateRequest` created by this Certificate, either when it
  // was created, renewed, or Spec was changed. Revisions will be removed by
  // oldest first if the number of revisions exceeds this number. If set,
  // revisionHistoryLimit must be a value of `1` or greater. If unset (`nil`),
  // revisions will not be garbage collected. Default value is `nil`.
  optional int32 revision_history_limit = 17 [(dev.f110.kubeproto.field) = { go_name: "RevisionHistoryLimit", api_field_name: "revisionHistoryLimit", inline: false }];
}

message CertificateStatus {
  // List of status conditions to indicate the status of certificates.
  // Known condition types are `Ready` and `Issuing`.
  repeated CertificateCondition conditions = 1 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // LastFailureTime is the time as recorded by the Certificate controller
  // of the most recent failure to complete a CertificateRequest for this
  // Certificate resource.
  // If set, cert-manager will not re-request another Certificate until
  // 1 hour has elapsed from this time.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time last_failure_time = 2 [(dev.f110.kubeproto.field) = { go_name: "LastFailureTime", api_field_name: "lastFailureTime", inline: false }];
  // The time after which the certificate stored in the secret named
  // by this resource in spec.secretName is valid.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time not_before = 3 [(dev.f110.kubeproto.field) = { go_name: "NotBefore", api_field_name: "notBefore", inline: false }];
  // The expiration time of the certificate stored in the secret named
  // by this resource in `spec.secretName`.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time not_after = 4 [(dev.f110.kubeproto.field) = { go_name: "NotAfter", api_field_name: "notAfter", inline: false }];
  // RenewalTime is the time at which the certificate will be next
  // renewed.
  // If not set, no upcoming renewal is scheduled.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time renewal_time = 5 [(dev.f110.kubeproto.field) = { go_name: "RenewalTime", api_field_name: "renewalTime", inline: false }];
  // The current 'revision' of the certificate as issued.
  // When a CertificateRequest resource is created, it will have the
  // `cert-manager.io/certificate-revision` set to one greater than the
  // current value of this field.
  // Upon issuance, this field will be set to the value of the annotation
  // on the CertificateRequest resource used to issue the certificate.
  // Persisting the value on the CertificateRequest resource allows the
  // certificates controller to know whether a request is part of an old
  // issuance or if it is part of the ongoing revision's issuance by
  // checking if the revision value in the annotation is greater than this
  // field.
  optional int32 revision = 6 [(dev.f110.kubeproto.field) = { go_name: "Revision", api_field_name: "revision", inline: false }];
  // The name of the Secret resource containing the private key to be used
  // for the next certificate iteration.
  // The keymanager controller will automatically set this field if the
  // `Issuing` condition is set to `True`.
  // It will automatically unset this field when the Issuing condition is
  // not set or False.
  optional string next_private_key_secret_name = 7 [(dev.f110.kubeproto.field) = { go_name: "NextPrivateKeySecretName", api_field_name: "nextPrivateKeySecretName", inline: false }];
}

message ClusterIssuer {
  // Desired state of the ClusterIssuer resource.
  IssuerSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status of the ClusterIssuer. This is set and managed automatically.
  IssuerStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ClusterIssuerList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated ClusterIssuer                        items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message Issuer {
  // Desired state of the Issuer resource.
  IssuerSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status of the Issuer. This is set and managed automatically.
  IssuerStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message IssuerCondition {
  // Type of the condition, known values are (`Ready`).
  IssuerConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition, one of (`True`, `False`, `Unknown`).
  github.com.jetstack.cert_manager.pkg.apis.metav1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // LastTransitionTime is the timestamp corresponding to the last status
  // change of this condition.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // Reason is a brief machine readable explanation for the condition's last
  // transition.
  optional string reason = 4 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // Message is a human readable description of the details of the last
  // transition, complementing reason.
  optional string message = 5 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
  // If set, this represents the .metadata.generation that the condition was
  // set based upon.
  // For instance, if .metadata.generation is currently 12, but the
  // .status.condition[x].observedGeneration is 9, the condition is out of date
  // with respect to the current state of the Issuer.
  optional int64 observed_generation = 6 [(dev.f110.kubeproto.field) = { go_name: "ObservedGeneration", api_field_name: "observedGeneration", inline: false }];
}

message IssuerConfig {
  // ACME configures this issuer to communicate with a RFC8555 (ACME) server
  // to obtain signed x509 certificates.
  optional github.com.jetstack.cert_manager.pkg.apis.acmev1.ACMEIssuer acme = 1 [(dev.f110.kubeproto.field) = { go_name: "ACME", api_field_name: "acme", inline: false }];
  // CA configures this issuer to sign certificates using a signing CA keypair
  // stored in a Secret resource.
  // This is used to build internal PKIs that are managed by cert-manager.
  optional CAIssuer c_a = 2 [(dev.f110.kubeproto.field) = { go_name: "CA", api_field_name: "ca", inline: false }];
  // Vault configures this issuer to sign certificates using a HashiCorp Vault
  // PKI backend.
  optional VaultIssuer vault = 3 [(dev.f110.kubeproto.field) = { go_name: "Vault", api_field_name: "vault", inline: false }];
  // SelfSigned configures this issuer to 'self sign' certificates using the
  // private key used to create the CertificateRequest object.
  optional SelfSignedIssuer self_signed = 4 [(dev.f110.kubeproto.field) = { go_name: "SelfSigned", api_field_name: "selfSigned", inline: false }];
  // Venafi configures this issuer to sign certificates using a Venafi TPP
  // or Venafi Cloud policy zone.
  optional VenafiIssuer venafi = 5 [(dev.f110.kubeproto.field) = { go_name: "Venafi", api_field_name: "venafi", inline: false }];
}

message IssuerList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated Issuer                               items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message IssuerSpec {
  IssuerConfig issuer_config = 1 [(dev.f110.kubeproto.field) = { go_name: "IssuerConfig", inline: true }];
}

message IssuerStatus {
  // List of status conditions to indicate the status of a CertificateRequest.
  // Known condition types are `Ready`.
  repeated IssuerCondition conditions = 1 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // ACME specific status options.
  // This field should only be set if the Issuer is configured to use an ACME
  // server to issue certificates.
  optional github.com.jetstack.cert_manager.pkg.apis.acmev1.ACMEIssuerStatus acme = 2 [(dev.f110.kubeproto.field) = { go_name: "ACME", api_field_name: "acme", inline: false }];
}

message JKSKeystore {
  // Create enables JKS keystore creation for the Certificate.
  // If true, a file named `keystore.jks` will be created in the target
  // Secret resource, encrypted using the password stored in
  // `passwordSecretRef`.
  // The keystore file will only be updated upon re-issuance.
  // A file named `truststore.jks` will also be created in the target
  // Secret resource, encrypted using the password stored in
  // `passwordSecretRef` containing the issuing Certificate Authority
  bool create = 1 [(dev.f110.kubeproto.field) = { go_name: "Create", api_field_name: "create", inline: false }];
  // PasswordSecretRef is a reference to a key in a Secret resource
  // containing the password used to encrypt the JKS keystore.
  github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector password_secret_ref = 2 [(dev.f110.kubeproto.field) = { go_name: "PasswordSecretRef", api_field_name: "passwordSecretRef", inline: false }];
}

message PKCS12Keystore {
  // Create enables PKCS12 keystore creation for the Certificate.
  // If true, a file named `keystore.p12` will be created in the target
  // Secret resource, encrypted using the password stored in
  // `passwordSecretRef`.
  // The keystore file will only be updated upon re-issuance.
  // A file named `truststore.p12` will also be created in the target
  // Secret resource, encrypted using the password stored in
  // `passwordSecretRef` containing the issuing Certificate Authority
  bool create = 1 [(dev.f110.kubeproto.field) = { go_name: "Create", api_field_name: "create", inline: false }];
  // PasswordSecretRef is a reference to a key in a Secret resource
  // containing the password used to encrypt the PKCS12 keystore.
  github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector password_secret_ref = 2 [(dev.f110.kubeproto.field) = { go_name: "PasswordSecretRef", api_field_name: "passwordSecretRef", inline: false }];
}

message SelfSignedIssuer {
  // The CRL distribution points is an X.509 v3 certificate extension which identifies
  // the location of the CRL from which the revocation of this certificate can be checked.
  // If not set certificate will be issued without CDP. Values are strings.
  repeated string c_r_l_distribution_points = 1 [(dev.f110.kubeproto.field) = { go_name: "CRLDistributionPoints", api_field_name: "crlDistributionPoints", inline: false }];
}

message VaultAppRole {
  // Path where the App Role authentication backend is mounted in Vault, e.g:
  // "approle"
  string path = 1 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // RoleID configured in the App Role authentication backend when setting
  // up the authentication backend in Vault.
  string role_id = 2 [(dev.f110.kubeproto.field) = { go_name: "RoleId", api_field_name: "roleId", inline: false }];
  // Reference to a key in a Secret that contains the App Role secret used
  // to authenticate with Vault.
  // The `key` field must be specified and denotes which entry within the Secret
  // resource is used as the app role secret.
  github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector secret_ref = 3 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
}

message VaultAuth {
  // TokenSecretRef authenticates with Vault by presenting a token.
  optional github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector token_secret_ref = 1 [(dev.f110.kubeproto.field) = { go_name: "TokenSecretRef", api_field_name: "tokenSecretRef", inline: false }];
  // AppRole authenticates with Vault using the App Role auth mechanism,
  // with the role and secret stored in a Kubernetes Secret resource.
  optional VaultAppRole app_role = 2 [(dev.f110.kubeproto.field) = { go_name: "AppRole", api_field_name: "appRole", inline: false }];
  // Kubernetes authenticates with Vault by passing the ServiceAccount
  // token stored in the named Secret resource to the Vault server.
  optional VaultKubernetesAuth kubernetes = 3 [(dev.f110.kubeproto.field) = { go_name: "Kubernetes", api_field_name: "kubernetes", inline: false }];
}

message VaultIssuer {
  // Auth configures how cert-manager authenticates with the Vault server.
  VaultAuth auth = 1 [(dev.f110.kubeproto.field) = { go_name: "Auth", api_field_name: "auth", inline: false }];
  // Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
  string server = 2 [(dev.f110.kubeproto.field) = { go_name: "Server", api_field_name: "server", inline: false }];
  // Path is the mount path of the Vault PKI backend's `sign` endpoint, e.g:
  // "my_pki_mount/sign/my-role-name".
  string path = 3 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1"
  // More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
  optional string namespace = 4 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
  // PEM-encoded CA bundle (base64-encoded) used to validate Vault server
  // certificate. Only used if the Server URL is using HTTPS protocol. This
  // parameter is ignored for plain HTTP protocol connection. If not set the
  // system root certificates are used to validate the TLS connection.
  optional bytes c_a_bundle = 5 [(dev.f110.kubeproto.field) = { go_name: "CABundle", api_field_name: "caBundle", inline: false }];
}

message VaultKubernetesAuth {
  // The Vault mountPath here is the mount path to use when authenticating with
  // Vault. For example, setting a value to `/v1/auth/foo`, will use the path
  // `/v1/auth/foo/login` to authenticate with Vault. If unspecified, the
  // default value "/v1/auth/kubernetes" will be used.
  optional string path = 1 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "mountPath", inline: false }];
  // The required Secret field containing a Kubernetes ServiceAccount JWT used
  // for authenticating with Vault. Use of 'ambient credentials' is not
  // supported.
  github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector secret_ref = 2 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
  // A required field containing the Vault Role to assume. A Role binds a
  // Kubernetes ServiceAccount with a set of Vault policies.
  string role = 3 [(dev.f110.kubeproto.field) = { go_name: "Role", api_field_name: "role", inline: false }];
}

message VenafiCloud {
  // URL is the base URL for Venafi Cloud.
  // Defaults to "https://api.venafi.cloud/v1".
  optional string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // APITokenSecretRef is a secret key selector for the Venafi Cloud API token.
  github.com.jetstack.cert_manager.pkg.apis.metav1.SecretKeySelector api_token_secret_ref = 2 [(dev.f110.kubeproto.field) = { go_name: "APITokenSecretRef", api_field_name: "apiTokenSecretRef", inline: false }];
}

message VenafiIssuer {
  // Zone is the Venafi Policy Zone to use for this issuer.
  // All requests made to the Venafi platform will be restricted by the named
  // zone policy.
  // This field is required.
  string zone = 1 [(dev.f110.kubeproto.field) = { go_name: "Zone", api_field_name: "zone", inline: false }];
  // TPP specifies Trust Protection Platform configuration settings.
  // Only one of TPP or Cloud may be specified.
  optional VenafiTPP t_p_p = 2 [(dev.f110.kubeproto.field) = { go_name: "TPP", api_field_name: "tpp", inline: false }];
  // Cloud specifies the Venafi cloud configuration settings.
  // Only one of TPP or Cloud may be specified.
  optional VenafiCloud cloud = 3 [(dev.f110.kubeproto.field) = { go_name: "Cloud", api_field_name: "cloud", inline: false }];
}

message VenafiTPP {
  // URL is the base URL for the vedsdk endpoint of the Venafi TPP instance,
  // for example: "https://tpp.example.com/vedsdk".
  string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // CredentialsRef is a reference to a Secret containing the username and
  // password for the TPP server.
  // The secret must contain two keys, 'username' and 'password'.
  github.com.jetstack.cert_manager.pkg.apis.metav1.LocalObjectReference credentials_ref = 2 [(dev.f110.kubeproto.field) = { go_name: "CredentialsRef", api_field_name: "credentialsRef", inline: false }];
  // CABundle is a PEM encoded TLS certificate to use to verify connections to
  // the TPP instance.
  // If specified, system roots will not be used and the issuing CA for the
  // TPP instance must be verifiable using the provided root.
  // If not specified, the connection will be verified using the cert-manager
  // system root certificates.
  optional bytes c_a_bundle = 3 [(dev.f110.kubeproto.field) = { go_name: "CABundle", api_field_name: "caBundle", inline: false }];
}

message X509Subject {
  // Organizations to be used on the Certificate.
  repeated string organizations = 1 [(dev.f110.kubeproto.field) = { go_name: "Organizations", api_field_name: "organizations", inline: false }];
  // Countries to be used on the Certificate.
  repeated string countries = 2 [(dev.f110.kubeproto.field) = { go_name: "Countries", api_field_name: "countries", inline: false }];
  // Organizational Units to be used on the Certificate.
  repeated string organizational_units = 3 [(dev.f110.kubeproto.field) = { go_name: "OrganizationalUnits", api_field_name: "organizationalUnits", inline: false }];
  // Cities to be used on the Certificate.
  repeated string localities = 4 [(dev.f110.kubeproto.field) = { go_name: "Localities", api_field_name: "localities", inline: false }];
  // State/Provinces to be used on the Certificate.
  repeated string provinces = 5 [(dev.f110.kubeproto.field) = { go_name: "Provinces", api_field_name: "provinces", inline: false }];
  // Street addresses to be used on the Certificate.
  repeated string street_addresses = 6 [(dev.f110.kubeproto.field) = { go_name: "StreetAddresses", api_field_name: "streetAddresses", inline: false }];
  // Postal codes to be used on the Certificate.
  repeated string postal_codes = 7 [(dev.f110.kubeproto.field) = { go_name: "PostalCodes", api_field_name: "postalCodes", inline: false }];
  // Serial number to be used on the Certificate.
  optional string serial_number = 8 [(dev.f110.kubeproto.field) = { go_name: "SerialNumber", api_field_name: "serialNumber", inline: false }];
}
