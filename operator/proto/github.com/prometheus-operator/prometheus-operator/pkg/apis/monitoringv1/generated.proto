// Generated by: gen-go-to-protobuf
syntax = "proto3";
package github.com.prometheus_operator.prometheus_operator.pkg.apis.monitoringv1;
option  go_package              = "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1";
option (dev.f110.kubeproto.k8s) = {
  domain: "monitoring",
  sub_group: "coreos.com",
  version: "v1",
};

import "kube.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

message APIServerConfig {
  // Host of apiserver.
  // A valid string consisting of a hostname or IP followed by an optional port number
  string host = 1 [(dev.f110.kubeproto.field) = { go_name: "Host", api_field_name: "host", inline: false }];
  // BasicAuth allow an endpoint to authenticate over basic authentication
  optional BasicAuth basic_auth = 2 [(dev.f110.kubeproto.field) = { go_name: "BasicAuth", api_field_name: "basicAuth", inline: false }];
  // Bearer token for accessing apiserver.
  optional string bearer_token = 3 [(dev.f110.kubeproto.field) = { go_name: "BearerToken", api_field_name: "bearerToken", inline: false }];
  // File to read bearer token for accessing apiserver.
  optional string bearer_token_file = 4 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false }];
  // TLS Config to use for accessing apiserver.
  optional TLSConfig tls_config = 5 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
}

message AlertingSpec {
  // AlertmanagerEndpoints Prometheus should fire alerts against.
  repeated AlertmanagerEndpoints alertmanagers = 1 [(dev.f110.kubeproto.field) = { go_name: "Alertmanagers", api_field_name: "alertmanagers", inline: false }];
}

message Alertmanager {
  // Specification of the desired behavior of the Alertmanager cluster. More info:
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  AlertmanagerSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Most recent observed status of the Alertmanager cluster. Read-only. Not
  // included when requesting from the apiserver, only from the Prometheus
  // Operator API itself. More info:
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional AlertmanagerStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message AlertmanagerEndpoints {
  // Namespace of Endpoints object.
  string namespace = 1 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
  // Name of Endpoints object in Namespace.
  string name = 2 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Port the Alertmanager API is exposed on.
  .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 3 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // Scheme to use when firing alerts.
  optional string scheme = 4 [(dev.f110.kubeproto.field) = { go_name: "Scheme", api_field_name: "scheme", inline: false }];
  // Prefix for the HTTP path alerts are pushed to.
  optional string path_prefix = 5 [(dev.f110.kubeproto.field) = { go_name: "PathPrefix", api_field_name: "pathPrefix", inline: false }];
  // TLS Config to use for alertmanager connection.
  optional TLSConfig tls_config = 6 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // BearerTokenFile to read from filesystem to use when authenticating to
  // Alertmanager.
  optional string bearer_token_file = 7 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false }];
  // Version of the Alertmanager API that Prometheus uses to send alerts. It
  // can be "v1" or "v2".
  optional string api_version = 8 [(dev.f110.kubeproto.field) = { go_name: "APIVersion", api_field_name: "apiVersion", inline: false }];
  // Timeout is a per-target Alertmanager timeout when pushing alerts.
  optional string timeout = 9 [(dev.f110.kubeproto.field) = { go_name: "Timeout", api_field_name: "timeout", inline: false }];
}

message AlertmanagerList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of Alertmanagers
  repeated Alertmanager items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message AlertmanagerSpec {
  // PodMetadata configures Labels and Annotations which are propagated to the alertmanager pods.
  optional EmbeddedObjectMetadata pod_metadata = 1 [(dev.f110.kubeproto.field) = { go_name: "PodMetadata", api_field_name: "podMetadata", inline: false }];
  // Image if specified has precedence over baseImage, tag and sha
  // combinations. Specifying the version is still necessary to ensure the
  // Prometheus Operator knows what version of Alertmanager is being
  // configured.
  optional string image = 2 [(dev.f110.kubeproto.field) = { go_name: "Image", api_field_name: "image", inline: false }];
  // Version the cluster should be on.
  optional string version = 3 [(dev.f110.kubeproto.field) = { go_name: "Version", api_field_name: "version", inline: false }];
  // Tag of Alertmanager container image to be deployed. Defaults to the value of `version`.
  // Version is ignored if Tag is set.
  // Deprecated: use 'image' instead.  The image tag can be specified
  // as part of the image URL.
  optional string tag = 4 [(dev.f110.kubeproto.field) = { go_name: "Tag", api_field_name: "tag", inline: false }];
  // SHA of Alertmanager container image to be deployed. Defaults to the value of `version`.
  // Similar to a tag, but the SHA explicitly deploys an immutable container image.
  // Version and Tag are ignored if SHA is set.
  // Deprecated: use 'image' instead.  The image digest can be specified
  // as part of the image URL.
  optional string s_h_a = 5 [(dev.f110.kubeproto.field) = { go_name: "SHA", api_field_name: "sha", inline: false }];
  // Base image that is used to deploy pods, without tag.
  // Deprecated: use 'image' instead
  optional string base_image = 6 [(dev.f110.kubeproto.field) = { go_name: "BaseImage", api_field_name: "baseImage", inline: false }];
  // An optional list of references to secrets in the same namespace
  // to use for pulling prometheus and alertmanager images from registries
  // see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
  repeated .k8s.io.api.core.v1.LocalObjectReference image_pull_secrets = 7 [(dev.f110.kubeproto.field) = { go_name: "ImagePullSecrets", api_field_name: "imagePullSecrets", inline: false }];
  // Secrets is a list of Secrets in the same namespace as the Alertmanager
  // object, which shall be mounted into the Alertmanager Pods.
  // The Secrets are mounted into /etc/alertmanager/secrets/<secret-name>.
  repeated string secrets = 8 [(dev.f110.kubeproto.field) = { go_name: "Secrets", api_field_name: "secrets", inline: false }];
  // ConfigMaps is a list of ConfigMaps in the same namespace as the Alertmanager
  // object, which shall be mounted into the Alertmanager Pods.
  // The ConfigMaps are mounted into /etc/alertmanager/configmaps/<configmap-name>.
  repeated string config_maps = 9 [(dev.f110.kubeproto.field) = { go_name: "ConfigMaps", api_field_name: "configMaps", inline: false }];
  // ConfigSecret is the name of a Kubernetes Secret in the same namespace as the
  // Alertmanager object, which contains configuration for this Alertmanager
  // instance. Defaults to 'alertmanager-<alertmanager-name>'
  // The secret is mounted into /etc/alertmanager/config.
  optional string config_secret = 10 [(dev.f110.kubeproto.field) = { go_name: "ConfigSecret", api_field_name: "configSecret", inline: false }];
  // Log level for Alertmanager to be configured with.
  optional string log_level = 11 [(dev.f110.kubeproto.field) = { go_name: "LogLevel", api_field_name: "logLevel", inline: false }];
  // Log format for Alertmanager to be configured with.
  optional string log_format = 12 [(dev.f110.kubeproto.field) = { go_name: "LogFormat", api_field_name: "logFormat", inline: false }];
  // Size is the expected size of the alertmanager cluster. The controller will
  // eventually make the size of the running cluster equal to the expected
  // size.
  optional int32 replicas = 13 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Time duration Alertmanager shall retain data for. Default is '120h',
  // and must match the regular expression `[0-9]+(ms|s|m|h)` (milliseconds seconds minutes hours).
  optional string retention = 14 [(dev.f110.kubeproto.field) = { go_name: "Retention", api_field_name: "retention", inline: false }];
  // Storage is the definition of how storage will be used by the Alertmanager
  // instances.
  optional StorageSpec storage = 15 [(dev.f110.kubeproto.field) = { go_name: "Storage", api_field_name: "storage", inline: false }];
  // Volumes allows configuration of additional volumes on the output StatefulSet definition.
  // Volumes specified will be appended to other volumes that are generated as a result of
  // StorageSpec objects.
  repeated .k8s.io.api.core.v1.Volume volumes = 16 [(dev.f110.kubeproto.field) = { go_name: "Volumes", api_field_name: "volumes", inline: false }];
  // VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
  // VolumeMounts specified will be appended to other VolumeMounts in the alertmanager container,
  // that are generated as a result of StorageSpec objects.
  repeated .k8s.io.api.core.v1.VolumeMount volume_mounts = 17 [(dev.f110.kubeproto.field) = { go_name: "VolumeMounts", api_field_name: "volumeMounts", inline: false }];
  // The external URL the Alertmanager instances will be available under. This is
  // necessary to generate correct URLs. This is necessary if Alertmanager is not
  // served from root of a DNS name.
  optional string external_url = 18 [(dev.f110.kubeproto.field) = { go_name: "ExternalURL", api_field_name: "externalUrl", inline: false }];
  // The route prefix Alertmanager registers HTTP handlers for. This is useful,
  // if using ExternalURL and a proxy is rewriting HTTP routes of a request,
  // and the actual ExternalURL is still true, but the server serves requests
  // under a different route prefix. For example for use with `kubectl proxy`.
  optional string route_prefix = 19 [(dev.f110.kubeproto.field) = { go_name: "RoutePrefix", api_field_name: "routePrefix", inline: false }];
  // If set to true all actions on the underlying managed objects are not
  // goint to be performed, except for delete actions.
  optional bool paused = 20 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // Define which Nodes the Pods are scheduled on.
  map<string, string> node_selector = 21 [(dev.f110.kubeproto.field) = { go_name: "NodeSelector", api_field_name: "nodeSelector", inline: false }];
  // Define resources requests and limits for single Pods.
  optional .k8s.io.api.core.v1.ResourceRequirements resources = 22 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
  // If specified, the pod's scheduling constraints.
  optional .k8s.io.api.core.v1.Affinity affinity = 23 [(dev.f110.kubeproto.field) = { go_name: "Affinity", api_field_name: "affinity", inline: false }];
  // If specified, the pod's tolerations.
  repeated .k8s.io.api.core.v1.Toleration tolerations = 24 [(dev.f110.kubeproto.field) = { go_name: "Tolerations", api_field_name: "tolerations", inline: false }];
  // If specified, the pod's topology spread constraints.
  repeated .k8s.io.api.core.v1.TopologySpreadConstraint topology_spread_constraints = 25 [(dev.f110.kubeproto.field) = { go_name: "TopologySpreadConstraints", api_field_name: "topologySpreadConstraints", inline: false }];
  // SecurityContext holds pod-level security attributes and common container settings.
  // This defaults to the default PodSecurityContext.
  optional .k8s.io.api.core.v1.PodSecurityContext security_context = 26 [(dev.f110.kubeproto.field) = { go_name: "SecurityContext", api_field_name: "securityContext", inline: false }];
  // ServiceAccountName is the name of the ServiceAccount to use to run the
  // Prometheus Pods.
  optional string service_account_name = 27 [(dev.f110.kubeproto.field) = { go_name: "ServiceAccountName", api_field_name: "serviceAccountName", inline: false }];
  // ListenLocal makes the Alertmanager server listen on loopback, so that it
  // does not bind against the Pod IP. Note this is only for the Alertmanager
  // UI, not the gossip communication.
  optional bool listen_local = 28 [(dev.f110.kubeproto.field) = { go_name: "ListenLocal", api_field_name: "listenLocal", inline: false }];
  // Containers allows injecting additional containers. This is meant to
  // allow adding an authentication proxy to an Alertmanager pod.
  // Containers described here modify an operator generated container if they
  // share the same name and modifications are done via a strategic merge
  // patch. The current container names are: `alertmanager` and
  // `config-reloader`. Overriding containers is entirely outside the scope
  // of what the maintainers will support and by doing so, you accept that
  // this behaviour may break at any time without notice.
  repeated .k8s.io.api.core.v1.Container containers = 29 [(dev.f110.kubeproto.field) = { go_name: "Containers", api_field_name: "containers", inline: false }];
  // InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
  // fetch secrets for injection into the Alertmanager configuration from external sources. Any
  // errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // Using initContainers for any use case other then secret fetching is entirely outside the scope
  // of what the maintainers will support and by doing so, you accept that this behaviour may break
  // at any time without notice.
  repeated .k8s.io.api.core.v1.Container init_containers = 30 [(dev.f110.kubeproto.field) = { go_name: "InitContainers", api_field_name: "initContainers", inline: false }];
  // Priority class assigned to the Pods
  optional string priority_class_name = 31 [(dev.f110.kubeproto.field) = { go_name: "PriorityClassName", api_field_name: "priorityClassName", inline: false }];
  // AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.
  repeated string additional_peers = 32 [(dev.f110.kubeproto.field) = { go_name: "AdditionalPeers", api_field_name: "additionalPeers", inline: false }];
  // ClusterAdvertiseAddress is the explicit address to advertise in cluster.
  // Needs to be provided for non RFC1918 [1] (public) addresses.
  // [1] RFC1918: https://tools.ietf.org/html/rfc1918
  optional string cluster_advertise_address = 33 [(dev.f110.kubeproto.field) = { go_name: "ClusterAdvertiseAddress", api_field_name: "clusterAdvertiseAddress", inline: false }];
  // Interval between gossip attempts.
  optional string cluster_gossip_interval = 34 [(dev.f110.kubeproto.field) = { go_name: "ClusterGossipInterval", api_field_name: "clusterGossipInterval", inline: false }];
  // Interval between pushpull attempts.
  optional string cluster_pushpull_interval = 35 [(dev.f110.kubeproto.field) = { go_name: "ClusterPushpullInterval", api_field_name: "clusterPushpullInterval", inline: false }];
  // Timeout for cluster peering.
  optional string cluster_peer_timeout = 36 [(dev.f110.kubeproto.field) = { go_name: "ClusterPeerTimeout", api_field_name: "clusterPeerTimeout", inline: false }];
  // Port name used for the pods and governing service.
  // This defaults to web
  optional string port_name = 37 [(dev.f110.kubeproto.field) = { go_name: "PortName", api_field_name: "portName", inline: false }];
  // ForceEnableClusterMode ensures Alertmanager does not deactivate the cluster mode when running with a single replica.
  // Use case is e.g. spanning an Alertmanager cluster across Kubernetes clusters with a single replica in each.
  optional bool force_enable_cluster_mode = 38 [(dev.f110.kubeproto.field) = { go_name: "ForceEnableClusterMode", api_field_name: "forceEnableClusterMode", inline: false }];
  // AlertmanagerConfigs to be selected for to merge and configure Alertmanager with.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector alertmanager_config_selector = 39 [(dev.f110.kubeproto.field) = { go_name: "AlertmanagerConfigSelector", api_field_name: "alertmanagerConfigSelector", inline: false }];
  // Namespaces to be selected for AlertmanagerConfig discovery. If nil, only
  // check own namespace.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector alertmanager_config_namespace_selector = 40 [(dev.f110.kubeproto.field) = { go_name: "AlertmanagerConfigNamespaceSelector", api_field_name: "alertmanagerConfigNamespaceSelector", inline: false }];
}

message AlertmanagerStatus {
  // Represents whether any actions on the underlying managed objects are
  // being performed. Only delete actions will be performed.
  bool paused = 1 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // Total number of non-terminated pods targeted by this Alertmanager
  // cluster (their labels match the selector).
  int32 replicas = 2 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Total number of non-terminated pods targeted by this Alertmanager
  // cluster that have the desired version spec.
  int32 updated_replicas = 3 [(dev.f110.kubeproto.field) = { go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false }];
  // Total number of available pods (ready for at least minReadySeconds)
  // targeted by this Alertmanager cluster.
  int32 available_replicas = 4 [(dev.f110.kubeproto.field) = { go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false }];
  // Total number of unavailable pods targeted by this Alertmanager cluster.
  int32 unavailable_replicas = 5 [(dev.f110.kubeproto.field) = { go_name: "UnavailableReplicas", api_field_name: "unavailableReplicas", inline: false }];
}

message ArbitraryFSAccessThroughSMsConfig {
  optional bool deny = 1 [(dev.f110.kubeproto.field) = { go_name: "Deny", api_field_name: "deny", inline: false }];
}

message BasicAuth {
  // The secret in the service monitor namespace that contains the username
  // for authentication.
  optional .k8s.io.api.core.v1.SecretKeySelector username = 1 [(dev.f110.kubeproto.field) = { go_name: "Username", api_field_name: "username", inline: false }];
  // The secret in the service monitor namespace that contains the password
  // for authentication.
  optional .k8s.io.api.core.v1.SecretKeySelector password = 2 [(dev.f110.kubeproto.field) = { go_name: "Password", api_field_name: "password", inline: false }];
}

message EmbeddedObjectMetadata {
  // Name must be unique within a namespace. Is required when creating resources, although
  // some resources may allow a client to request the generation of an appropriate name
  // automatically. Name is primarily intended for creation idempotence and configuration
  // definition.
  // Cannot be updated.
  // More info: http://kubernetes.io/docs/user-guide/identifiers#names
  optional string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Map of string keys and values that can be used to organize and categorize
  // (scope and select) objects. May match selectors of replication controllers
  // and services.
  // More info: http://kubernetes.io/docs/user-guide/labels
  map<string, string> labels = 2 [(dev.f110.kubeproto.field) = { go_name: "Labels", api_field_name: "labels", inline: false }];
  // Annotations is an unstructured key value map stored with a resource that may be
  // set by external tools to store and retrieve arbitrary metadata. They are not
  // queryable and should be preserved when modifying objects.
  // More info: http://kubernetes.io/docs/user-guide/annotations
  map<string, string> annotations = 3 [(dev.f110.kubeproto.field) = { go_name: "Annotations", api_field_name: "annotations", inline: false }];
}

message EmbeddedPersistentVolumeClaim {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
  optional EmbeddedObjectMetadata embedded_object_metadata = 2 [(dev.f110.kubeproto.field) = { go_name: "EmbeddedObjectMetadata", api_field_name: "metadata", inline: false }];
  // Spec defines the desired characteristics of a volume requested by a pod author.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  optional .k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status represents the current information/status of a persistent volume claim.
  // Read-only.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  optional .k8s.io.api.core.v1.PersistentVolumeClaimStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
}

message Endpoint {
  // Name of the service port this endpoint refers to. Mutually exclusive with targetPort.
  optional string port = 1 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // Name or number of the target port of the Pod behind the Service, the port must be specified with container port property. Mutually exclusive with port.
  optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString target_port = 2 [(dev.f110.kubeproto.field) = { go_name: "TargetPort", api_field_name: "targetPort", inline: false }];
  // HTTP path to scrape for metrics.
  optional string path = 3 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // HTTP scheme to use for scraping.
  optional string scheme = 4 [(dev.f110.kubeproto.field) = { go_name: "Scheme", api_field_name: "scheme", inline: false }];
  // Optional HTTP URL parameters
  // This field can not be represented by protobuf.
  // map<string, > params = 5 [(dev.f110.kubeproto.field) = {go_name: "Params", api_field_name: "params", inline: false}];
  // Interval at which metrics should be scraped
  optional string interval = 6 [(dev.f110.kubeproto.field) = { go_name: "Interval", api_field_name: "interval", inline: false }];
  // Timeout after which the scrape is ended
  optional string scrape_timeout = 7 [(dev.f110.kubeproto.field) = { go_name: "ScrapeTimeout", api_field_name: "scrapeTimeout", inline: false }];
  // TLS configuration to use when scraping the endpoint
  optional TLSConfig tls_config = 8 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // File to read bearer token for scraping targets.
  optional string bearer_token_file = 9 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false }];
  // Secret to mount to read bearer token for scraping targets. The secret
  // needs to be in the same namespace as the service monitor and accessible by
  // the Prometheus Operator.
  optional .k8s.io.api.core.v1.SecretKeySelector bearer_token_secret = 10 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenSecret", api_field_name: "bearerTokenSecret", inline: false }];
  // HonorLabels chooses the metric's labels on collisions with target labels.
  optional bool honor_labels = 11 [(dev.f110.kubeproto.field) = { go_name: "HonorLabels", api_field_name: "honorLabels", inline: false }];
  // HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
  optional bool honor_timestamps = 12 [(dev.f110.kubeproto.field) = { go_name: "HonorTimestamps", api_field_name: "honorTimestamps", inline: false }];
  // BasicAuth allow an endpoint to authenticate over basic authentication
  // More info: https://prometheus.io/docs/operating/configuration/#endpoints
  optional BasicAuth basic_auth = 13 [(dev.f110.kubeproto.field) = { go_name: "BasicAuth", api_field_name: "basicAuth", inline: false }];
  // MetricRelabelConfigs to apply to samples before ingestion.
  repeated RelabelConfig metric_relabel_configs = 14 [(dev.f110.kubeproto.field) = { go_name: "MetricRelabelConfigs", api_field_name: "metricRelabelings", inline: false }];
  // RelabelConfigs to apply to samples before scraping.
  // More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
  repeated RelabelConfig relabel_configs = 15 [(dev.f110.kubeproto.field) = { go_name: "RelabelConfigs", api_field_name: "relabelings", inline: false }];
  // ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
  optional string proxy_url = 16 [(dev.f110.kubeproto.field) = { go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false }];
}

message NamespaceSelector {
  // Boolean describing whether all namespaces are selected in contrast to a
  // list restricting them.
  optional bool any = 1 [(dev.f110.kubeproto.field) = { go_name: "Any", api_field_name: "any", inline: false }];
  // List of namespace names.
  repeated string match_names = 2 [(dev.f110.kubeproto.field) = { go_name: "MatchNames", api_field_name: "matchNames", inline: false }];
}

message PodMetricsEndpoint {
  // Name of the pod port this endpoint refers to. Mutually exclusive with targetPort.
  optional string port = 1 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // Deprecated: Use 'port' instead.
  optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString target_port = 2 [(dev.f110.kubeproto.field) = { go_name: "TargetPort", api_field_name: "targetPort", inline: false }];
  // HTTP path to scrape for metrics.
  optional string path = 3 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // HTTP scheme to use for scraping.
  optional string scheme = 4 [(dev.f110.kubeproto.field) = { go_name: "Scheme", api_field_name: "scheme", inline: false }];
  // Optional HTTP URL parameters
  // This field can not be represented by protobuf.
  // map<string, > params = 5 [(dev.f110.kubeproto.field) = {go_name: "Params", api_field_name: "params", inline: false}];
  // Interval at which metrics should be scraped
  optional string interval = 6 [(dev.f110.kubeproto.field) = { go_name: "Interval", api_field_name: "interval", inline: false }];
  // Timeout after which the scrape is ended
  optional string scrape_timeout = 7 [(dev.f110.kubeproto.field) = { go_name: "ScrapeTimeout", api_field_name: "scrapeTimeout", inline: false }];
  // TLS configuration to use when scraping the endpoint.
  optional PodMetricsEndpointTLSConfig tls_config = 8 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // Secret to mount to read bearer token for scraping targets. The secret
  // needs to be in the same namespace as the pod monitor and accessible by
  // the Prometheus Operator.
  optional .k8s.io.api.core.v1.SecretKeySelector bearer_token_secret = 9 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenSecret", api_field_name: "bearerTokenSecret", inline: false }];
  // HonorLabels chooses the metric's labels on collisions with target labels.
  optional bool honor_labels = 10 [(dev.f110.kubeproto.field) = { go_name: "HonorLabels", api_field_name: "honorLabels", inline: false }];
  // HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
  optional bool honor_timestamps = 11 [(dev.f110.kubeproto.field) = { go_name: "HonorTimestamps", api_field_name: "honorTimestamps", inline: false }];
  // BasicAuth allow an endpoint to authenticate over basic authentication.
  // More info: https://prometheus.io/docs/operating/configuration/#endpoint
  optional BasicAuth basic_auth = 12 [(dev.f110.kubeproto.field) = { go_name: "BasicAuth", api_field_name: "basicAuth", inline: false }];
  // MetricRelabelConfigs to apply to samples before ingestion.
  repeated RelabelConfig metric_relabel_configs = 13 [(dev.f110.kubeproto.field) = { go_name: "MetricRelabelConfigs", api_field_name: "metricRelabelings", inline: false }];
  // RelabelConfigs to apply to samples before ingestion.
  // More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
  repeated RelabelConfig relabel_configs = 14 [(dev.f110.kubeproto.field) = { go_name: "RelabelConfigs", api_field_name: "relabelings", inline: false }];
  // ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
  optional string proxy_url = 15 [(dev.f110.kubeproto.field) = { go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false }];
}

message PodMetricsEndpointTLSConfig {
  SafeTLSConfig safe_tls_config = 1 [(dev.f110.kubeproto.field) = { go_name: "SafeTLSConfig", inline: true }];
}

message PodMonitor {
  // Specification of desired Pod selection for target discovery by Prometheus.
  PodMonitorSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message PodMonitorList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of PodMonitors
  repeated PodMonitor items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message PodMonitorSpec {
  // The label to use to retrieve the job name from.
  optional string job_label = 1 [(dev.f110.kubeproto.field) = { go_name: "JobLabel", api_field_name: "jobLabel", inline: false }];
  // PodTargetLabels transfers labels on the Kubernetes Pod onto the target.
  repeated string pod_target_labels = 2 [(dev.f110.kubeproto.field) = { go_name: "PodTargetLabels", api_field_name: "podTargetLabels", inline: false }];
  // A list of endpoints allowed as part of this PodMonitor.
  repeated PodMetricsEndpoint pod_metrics_endpoints = 3 [(dev.f110.kubeproto.field) = { go_name: "PodMetricsEndpoints", api_field_name: "podMetricsEndpoints", inline: false }];
  // Selector to select Pod objects.
  .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // Selector to select which namespaces the Endpoints objects are discovered from.
  optional NamespaceSelector namespace_selector = 5 [(dev.f110.kubeproto.field) = { go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false }];
  // SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
  optional uint64 sample_limit = 6 [(dev.f110.kubeproto.field) = { go_name: "SampleLimit", api_field_name: "sampleLimit", inline: false }];
  // TargetLimit defines a limit on the number of scraped targets that will be accepted.
  optional uint64 target_limit = 7 [(dev.f110.kubeproto.field) = { go_name: "TargetLimit", api_field_name: "targetLimit", inline: false }];
}

message Probe {
  // Specification of desired Ingress selection for target discovery by Prometheus.
  ProbeSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ProbeList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of Probes
  repeated Probe items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ProbeSpec {
  // The job name assigned to scraped metrics by default.
  optional string job_name = 1 [(dev.f110.kubeproto.field) = { go_name: "JobName", api_field_name: "jobName", inline: false }];
  // Specification for the prober to use for probing targets.
  // The prober.URL parameter is required. Targets cannot be probed if left empty.
  optional ProberSpec prober_spec = 2 [(dev.f110.kubeproto.field) = { go_name: "ProberSpec", api_field_name: "prober", inline: false }];
  // The module to use for probing specifying how to probe the target.
  // Example module configuring in the blackbox exporter:
  // https://github.com/prometheus/blackbox_exporter/blob/master/example.yml
  optional string module = 3 [(dev.f110.kubeproto.field) = { go_name: "Module", api_field_name: "module", inline: false }];
  // Targets defines a set of static and/or dynamically discovered targets to be probed using the prober.
  optional ProbeTargets targets = 4 [(dev.f110.kubeproto.field) = { go_name: "Targets", api_field_name: "targets", inline: false }];
  // Interval at which targets are probed using the configured prober.
  // If not specified Prometheus' global scrape interval is used.
  optional string interval = 5 [(dev.f110.kubeproto.field) = { go_name: "Interval", api_field_name: "interval", inline: false }];
  // Timeout for scraping metrics from the Prometheus exporter.
  optional string scrape_timeout = 6 [(dev.f110.kubeproto.field) = { go_name: "ScrapeTimeout", api_field_name: "scrapeTimeout", inline: false }];
}

message ProbeTargetIngress {
  // Select Ingress objects by labels.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // Select Ingress objects by namespace.
  optional NamespaceSelector namespace_selector = 2 [(dev.f110.kubeproto.field) = { go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false }];
  // RelabelConfigs to apply to samples before ingestion.
  // More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
  repeated RelabelConfig relabel_configs = 3 [(dev.f110.kubeproto.field) = { go_name: "RelabelConfigs", api_field_name: "relabelingConfigs", inline: false }];
}

message ProbeTargetStaticConfig {
  // Targets is a list of URLs to probe using the configured prober.
  repeated string targets = 1 [(dev.f110.kubeproto.field) = { go_name: "Targets", api_field_name: "static", inline: false }];
  // Labels assigned to all metrics scraped from the targets.
  map<string, string> labels = 2 [(dev.f110.kubeproto.field) = { go_name: "Labels", api_field_name: "labels", inline: false }];
  // RelabelConfigs to apply to samples before ingestion.
  // More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
  repeated RelabelConfig relabel_configs = 3 [(dev.f110.kubeproto.field) = { go_name: "RelabelConfigs", api_field_name: "relabelingConfigs", inline: false }];
}

message ProbeTargets {
  // StaticConfig defines static targets which are considers for probing.
  // More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
  optional ProbeTargetStaticConfig static_config = 1 [(dev.f110.kubeproto.field) = { go_name: "StaticConfig", api_field_name: "staticConfig", inline: false }];
  // Ingress defines the set of dynamically discovered ingress objects which hosts are considered for probing.
  optional ProbeTargetIngress ingress = 2 [(dev.f110.kubeproto.field) = { go_name: "Ingress", api_field_name: "ingress", inline: false }];
}

message ProberSpec {
  // Mandatory URL of the prober.
  string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // HTTP scheme to use for scraping.
  // Defaults to `http`.
  optional string scheme = 2 [(dev.f110.kubeproto.field) = { go_name: "Scheme", api_field_name: "scheme", inline: false }];
  // Path to collect metrics from.
  // Defaults to `/probe`.
  optional string path = 3 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
}

message Prometheus {
  // Specification of the desired behavior of the Prometheus cluster. More info:
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  PrometheusSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Most recent observed status of the Prometheus cluster. Read-only. Not
  // included when requesting from the apiserver, only from the Prometheus
  // Operator API itself. More info:
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional PrometheusStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message PrometheusList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of Prometheuses
  repeated Prometheus items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message PrometheusRule {
  // Specification of desired alerting rule definitions for Prometheus.
  PrometheusRuleSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message PrometheusRuleExcludeConfig {
  // RuleNamespace - namespace of excluded rule
  string rule_namespace = 1 [(dev.f110.kubeproto.field) = { go_name: "RuleNamespace", api_field_name: "ruleNamespace", inline: false }];
  // RuleNamespace - name of excluded rule
  string rule_name = 2 [(dev.f110.kubeproto.field) = { go_name: "RuleName", api_field_name: "ruleName", inline: false }];
}

message PrometheusRuleList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of Rules
  repeated PrometheusRule items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message PrometheusRuleSpec {
  // Content of Prometheus rule file
  repeated RuleGroup groups = 1 [(dev.f110.kubeproto.field) = { go_name: "Groups", api_field_name: "groups", inline: false }];
}

message PrometheusSpec {
  // PodMetadata configures Labels and Annotations which are propagated to the prometheus pods.
  optional EmbeddedObjectMetadata pod_metadata = 1 [(dev.f110.kubeproto.field) = { go_name: "PodMetadata", api_field_name: "podMetadata", inline: false }];
  // ServiceMonitors to be selected for target discovery. *Deprecated:* if
  // neither this nor podMonitorSelector are specified, configuration is
  // unmanaged.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector service_monitor_selector = 2 [(dev.f110.kubeproto.field) = { go_name: "ServiceMonitorSelector", api_field_name: "serviceMonitorSelector", inline: false }];
  // Namespace's labels to match for ServiceMonitor discovery. If nil, only
  // check own namespace.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector service_monitor_namespace_selector = 3 [(dev.f110.kubeproto.field) = { go_name: "ServiceMonitorNamespaceSelector", api_field_name: "serviceMonitorNamespaceSelector", inline: false }];
  // *Experimental* PodMonitors to be selected for target discovery.
  // *Deprecated:* if neither this nor serviceMonitorSelector are specified,
  // configuration is unmanaged.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector pod_monitor_selector = 4 [(dev.f110.kubeproto.field) = { go_name: "PodMonitorSelector", api_field_name: "podMonitorSelector", inline: false }];
  // Namespace's labels to match for PodMonitor discovery. If nil, only
  // check own namespace.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector pod_monitor_namespace_selector = 5 [(dev.f110.kubeproto.field) = { go_name: "PodMonitorNamespaceSelector", api_field_name: "podMonitorNamespaceSelector", inline: false }];
  // *Experimental* Probes to be selected for target discovery.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector probe_selector = 6 [(dev.f110.kubeproto.field) = { go_name: "ProbeSelector", api_field_name: "probeSelector", inline: false }];
  // *Experimental* Namespaces to be selected for Probe discovery. If nil, only check own namespace.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector probe_namespace_selector = 7 [(dev.f110.kubeproto.field) = { go_name: "ProbeNamespaceSelector", api_field_name: "probeNamespaceSelector", inline: false }];
  // Version of Prometheus to be deployed.
  optional string version = 8 [(dev.f110.kubeproto.field) = { go_name: "Version", api_field_name: "version", inline: false }];
  // Tag of Prometheus container image to be deployed. Defaults to the value of `version`.
  // Version is ignored if Tag is set.
  // Deprecated: use 'image' instead.  The image tag can be specified
  // as part of the image URL.
  optional string tag = 9 [(dev.f110.kubeproto.field) = { go_name: "Tag", api_field_name: "tag", inline: false }];
  // SHA of Prometheus container image to be deployed. Defaults to the value of `version`.
  // Similar to a tag, but the SHA explicitly deploys an immutable container image.
  // Version and Tag are ignored if SHA is set.
  // Deprecated: use 'image' instead.  The image digest can be specified
  // as part of the image URL.
  optional string s_h_a = 10 [(dev.f110.kubeproto.field) = { go_name: "SHA", api_field_name: "sha", inline: false }];
  // When a Prometheus deployment is paused, no actions except for deletion
  // will be performed on the underlying objects.
  optional bool paused = 11 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // Image if specified has precedence over baseImage, tag and sha
  // combinations. Specifying the version is still necessary to ensure the
  // Prometheus Operator knows what version of Prometheus is being
  // configured.
  optional string image = 12 [(dev.f110.kubeproto.field) = { go_name: "Image", api_field_name: "image", inline: false }];
  // Base image to use for a Prometheus deployment.
  // Deprecated: use 'image' instead
  optional string base_image = 13 [(dev.f110.kubeproto.field) = { go_name: "BaseImage", api_field_name: "baseImage", inline: false }];
  // An optional list of references to secrets in the same namespace
  // to use for pulling prometheus and alertmanager images from registries
  // see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
  repeated .k8s.io.api.core.v1.LocalObjectReference image_pull_secrets = 14 [(dev.f110.kubeproto.field) = { go_name: "ImagePullSecrets", api_field_name: "imagePullSecrets", inline: false }];
  // Number of replicas of each shard to deploy for a Prometheus deployment.
  // Number of replicas multiplied by shards is the total number of Pods
  // created.
  optional int32 replicas = 15 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // EXPERIMENTAL: Number of shards to distribute targets onto. Number of
  // replicas multiplied by shards is the total number of Pods created. Note
  // that scaling down shards will not reshard data onto remaining instances,
  // it must be manually moved. Increasing shards will not reshard data
  // either but it will continue to be available from the same instances. To
  // query globally use Thanos sidecar and Thanos querier or remote write
  // data to a central location. Sharding is done on the content of the
  // `__address__` target meta-label.
  optional int32 shards = 16 [(dev.f110.kubeproto.field) = { go_name: "Shards", api_field_name: "shards", inline: false }];
  // Name of Prometheus external label used to denote replica name.
  // Defaults to the value of `prometheus_replica`. External label will
  // _not_ be added when value is set to empty string (`""`).
  optional string replica_external_label_name = 17 [(dev.f110.kubeproto.field) = { go_name: "ReplicaExternalLabelName", api_field_name: "replicaExternalLabelName", inline: false }];
  // Name of Prometheus external label used to denote Prometheus instance
  // name. Defaults to the value of `prometheus`. External label will
  // _not_ be added when value is set to empty string (`""`).
  optional string prometheus_external_label_name = 18 [(dev.f110.kubeproto.field) = { go_name: "PrometheusExternalLabelName", api_field_name: "prometheusExternalLabelName", inline: false }];
  // Time duration Prometheus shall retain data for. Default is '24h',
  // and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)` (milliseconds seconds minutes hours days weeks years).
  optional string retention = 19 [(dev.f110.kubeproto.field) = { go_name: "Retention", api_field_name: "retention", inline: false }];
  // Maximum amount of disk space used by blocks. Supported units: B, KB, MB, GB, TB, PB, EB. Ex: `512MB`.
  optional string retention_size = 20 [(dev.f110.kubeproto.field) = { go_name: "RetentionSize", api_field_name: "retentionSize", inline: false }];
  // Disable prometheus compaction.
  optional bool disable_compaction = 21 [(dev.f110.kubeproto.field) = { go_name: "DisableCompaction", api_field_name: "disableCompaction", inline: false }];
  // Enable compression of the write-ahead log using Snappy. This flag is
  // only available in versions of Prometheus >= 2.11.0.
  optional bool w_a_l_compression = 22 [(dev.f110.kubeproto.field) = { go_name: "WALCompression", api_field_name: "walCompression", inline: false }];
  // Log level for Prometheus to be configured with.
  optional string log_level = 23 [(dev.f110.kubeproto.field) = { go_name: "LogLevel", api_field_name: "logLevel", inline: false }];
  // Log format for Prometheus to be configured with.
  optional string log_format = 24 [(dev.f110.kubeproto.field) = { go_name: "LogFormat", api_field_name: "logFormat", inline: false }];
  // Interval between consecutive scrapes.
  optional string scrape_interval = 25 [(dev.f110.kubeproto.field) = { go_name: "ScrapeInterval", api_field_name: "scrapeInterval", inline: false }];
  // Number of seconds to wait for target to respond before erroring.
  optional string scrape_timeout = 26 [(dev.f110.kubeproto.field) = { go_name: "ScrapeTimeout", api_field_name: "scrapeTimeout", inline: false }];
  // Interval between consecutive evaluations.
  optional string evaluation_interval = 27 [(dev.f110.kubeproto.field) = { go_name: "EvaluationInterval", api_field_name: "evaluationInterval", inline: false }];
  // /--rules.*/ command-line arguments.
  optional Rules rules = 28 [(dev.f110.kubeproto.field) = { go_name: "Rules", api_field_name: "rules", inline: false }];
  // The labels to add to any time series or alerts when communicating with
  // external systems (federation, remote storage, Alertmanager).
  map<string, string> external_labels = 29 [(dev.f110.kubeproto.field) = { go_name: "ExternalLabels", api_field_name: "externalLabels", inline: false }];
  // Enable access to prometheus web admin API. Defaults to the value of `false`.
  // WARNING: Enabling the admin APIs enables mutating endpoints, to delete data,
  // shutdown Prometheus, and more. Enabling this should be done with care and the
  // user is advised to add additional authentication authorization via a proxy to
  // ensure only clients authorized to perform these actions can do so.
  // For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis
  optional bool enable_admin_api = 30 [(dev.f110.kubeproto.field) = { go_name: "EnableAdminAPI", api_field_name: "enableAdminAPI", inline: false }];
  // The external URL the Prometheus instances will be available under. This is
  // necessary to generate correct URLs. This is necessary if Prometheus is not
  // served from root of a DNS name.
  optional string external_url = 31 [(dev.f110.kubeproto.field) = { go_name: "ExternalURL", api_field_name: "externalUrl", inline: false }];
  // The route prefix Prometheus registers HTTP handlers for. This is useful,
  // if using ExternalURL and a proxy is rewriting HTTP routes of a request,
  // and the actual ExternalURL is still true, but the server serves requests
  // under a different route prefix. For example for use with `kubectl proxy`.
  optional string route_prefix = 32 [(dev.f110.kubeproto.field) = { go_name: "RoutePrefix", api_field_name: "routePrefix", inline: false }];
  // QuerySpec defines the query command line flags when starting Prometheus.
  optional QuerySpec query = 33 [(dev.f110.kubeproto.field) = { go_name: "Query", api_field_name: "query", inline: false }];
  // Storage spec to specify how storage shall be used.
  optional StorageSpec storage = 34 [(dev.f110.kubeproto.field) = { go_name: "Storage", api_field_name: "storage", inline: false }];
  // Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will
  // be appended to other volumes that are generated as a result of StorageSpec objects.
  repeated .k8s.io.api.core.v1.Volume volumes = 35 [(dev.f110.kubeproto.field) = { go_name: "Volumes", api_field_name: "volumes", inline: false }];
  // VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
  // VolumeMounts specified will be appended to other VolumeMounts in the prometheus container,
  // that are generated as a result of StorageSpec objects.
  repeated .k8s.io.api.core.v1.VolumeMount volume_mounts = 36 [(dev.f110.kubeproto.field) = { go_name: "VolumeMounts", api_field_name: "volumeMounts", inline: false }];
  // WebSpec defines the web command line flags when starting Prometheus.
  optional WebSpec web = 37 [(dev.f110.kubeproto.field) = { go_name: "Web", api_field_name: "web", inline: false }];
  // A selector to select which PrometheusRules to mount for loading alerting/recording
  // rules from. Until (excluding) Prometheus Operator v0.24.0 Prometheus
  // Operator will migrate any legacy rule ConfigMaps to PrometheusRule custom
  // resources selected by RuleSelector. Make sure it does not match any config
  // maps that you do not want to be migrated.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector rule_selector = 38 [(dev.f110.kubeproto.field) = { go_name: "RuleSelector", api_field_name: "ruleSelector", inline: false }];
  // Namespaces to be selected for PrometheusRules discovery. If unspecified, only
  // the same namespace as the Prometheus object is in is used.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector rule_namespace_selector = 39 [(dev.f110.kubeproto.field) = { go_name: "RuleNamespaceSelector", api_field_name: "ruleNamespaceSelector", inline: false }];
  // Define details regarding alerting.
  optional AlertingSpec alerting = 40 [(dev.f110.kubeproto.field) = { go_name: "Alerting", api_field_name: "alerting", inline: false }];
  // Define resources requests and limits for single Pods.
  optional .k8s.io.api.core.v1.ResourceRequirements resources = 41 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
  // Define which Nodes the Pods are scheduled on.
  map<string, string> node_selector = 42 [(dev.f110.kubeproto.field) = { go_name: "NodeSelector", api_field_name: "nodeSelector", inline: false }];
  // ServiceAccountName is the name of the ServiceAccount to use to run the
  // Prometheus Pods.
  optional string service_account_name = 43 [(dev.f110.kubeproto.field) = { go_name: "ServiceAccountName", api_field_name: "serviceAccountName", inline: false }];
  // Secrets is a list of Secrets in the same namespace as the Prometheus
  // object, which shall be mounted into the Prometheus Pods.
  // The Secrets are mounted into /etc/prometheus/secrets/<secret-name>.
  repeated string secrets = 44 [(dev.f110.kubeproto.field) = { go_name: "Secrets", api_field_name: "secrets", inline: false }];
  // ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus
  // object, which shall be mounted into the Prometheus Pods.
  // The ConfigMaps are mounted into /etc/prometheus/configmaps/<configmap-name>.
  repeated string config_maps = 45 [(dev.f110.kubeproto.field) = { go_name: "ConfigMaps", api_field_name: "configMaps", inline: false }];
  // If specified, the pod's scheduling constraints.
  optional .k8s.io.api.core.v1.Affinity affinity = 46 [(dev.f110.kubeproto.field) = { go_name: "Affinity", api_field_name: "affinity", inline: false }];
  // If specified, the pod's tolerations.
  repeated .k8s.io.api.core.v1.Toleration tolerations = 47 [(dev.f110.kubeproto.field) = { go_name: "Tolerations", api_field_name: "tolerations", inline: false }];
  // If specified, the pod's topology spread constraints.
  repeated .k8s.io.api.core.v1.TopologySpreadConstraint topology_spread_constraints = 48 [(dev.f110.kubeproto.field) = { go_name: "TopologySpreadConstraints", api_field_name: "topologySpreadConstraints", inline: false }];
  // If specified, the remote_write spec. This is an experimental feature, it may change in any upcoming release in a breaking way.
  repeated RemoteWriteSpec remote_write = 49 [(dev.f110.kubeproto.field) = { go_name: "RemoteWrite", api_field_name: "remoteWrite", inline: false }];
  // If specified, the remote_read spec. This is an experimental feature, it may change in any upcoming release in a breaking way.
  repeated RemoteReadSpec remote_read = 50 [(dev.f110.kubeproto.field) = { go_name: "RemoteRead", api_field_name: "remoteRead", inline: false }];
  // SecurityContext holds pod-level security attributes and common container settings.
  // This defaults to the default PodSecurityContext.
  optional .k8s.io.api.core.v1.PodSecurityContext security_context = 51 [(dev.f110.kubeproto.field) = { go_name: "SecurityContext", api_field_name: "securityContext", inline: false }];
  // ListenLocal makes the Prometheus server listen on loopback, so that it
  // does not bind against the Pod IP.
  optional bool listen_local = 52 [(dev.f110.kubeproto.field) = { go_name: "ListenLocal", api_field_name: "listenLocal", inline: false }];
  // Containers allows injecting additional containers or modifying operator
  // generated containers. This can be used to allow adding an authentication
  // proxy to a Prometheus pod or to change the behavior of an operator
  // generated container. Containers described here modify an operator
  // generated container if they share the same name and modifications are
  // done via a strategic merge patch. The current container names are:
  // `prometheus`, `config-reloader`, and `thanos-sidecar`. Overriding
  // containers is entirely outside the scope of what the maintainers will
  // support and by doing so, you accept that this behaviour may break at any
  // time without notice.
  repeated .k8s.io.api.core.v1.Container containers = 53 [(dev.f110.kubeproto.field) = { go_name: "Containers", api_field_name: "containers", inline: false }];
  // InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
  // fetch secrets for injection into the Prometheus configuration from external sources. Any errors
  // during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // Using initContainers for any use case other then secret fetching is entirely outside the scope
  // of what the maintainers will support and by doing so, you accept that this behaviour may break
  // at any time without notice.
  repeated .k8s.io.api.core.v1.Container init_containers = 54 [(dev.f110.kubeproto.field) = { go_name: "InitContainers", api_field_name: "initContainers", inline: false }];
  // AdditionalScrapeConfigs allows specifying a key of a Secret containing
  // additional Prometheus scrape configurations. Scrape configurations
  // specified are appended to the configurations generated by the Prometheus
  // Operator. Job configurations specified must have the form as specified
  // in the official Prometheus documentation:
  // https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
  // As scrape configs are appended, the user is responsible to make sure it
  // is valid. Note that using this feature may expose the possibility to
  // break upgrades of Prometheus. It is advised to review Prometheus release
  // notes to ensure that no incompatible scrape configs are going to break
  // Prometheus after the upgrade.
  optional .k8s.io.api.core.v1.SecretKeySelector additional_scrape_configs = 55 [(dev.f110.kubeproto.field) = { go_name: "AdditionalScrapeConfigs", api_field_name: "additionalScrapeConfigs", inline: false }];
  // AdditionalAlertRelabelConfigs allows specifying a key of a Secret containing
  // additional Prometheus alert relabel configurations. Alert relabel configurations
  // specified are appended to the configurations generated by the Prometheus
  // Operator. Alert relabel configurations specified must have the form as specified
  // in the official Prometheus documentation:
  // https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs.
  // As alert relabel configs are appended, the user is responsible to make sure it
  // is valid. Note that using this feature may expose the possibility to
  // break upgrades of Prometheus. It is advised to review Prometheus release
  // notes to ensure that no incompatible alert relabel configs are going to break
  // Prometheus after the upgrade.
  optional .k8s.io.api.core.v1.SecretKeySelector additional_alert_relabel_configs = 56 [(dev.f110.kubeproto.field) = { go_name: "AdditionalAlertRelabelConfigs", api_field_name: "additionalAlertRelabelConfigs", inline: false }];
  // AdditionalAlertManagerConfigs allows specifying a key of a Secret containing
  // additional Prometheus AlertManager configurations. AlertManager configurations
  // specified are appended to the configurations generated by the Prometheus
  // Operator. Job configurations specified must have the form as specified
  // in the official Prometheus documentation:
  // https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config.
  // As AlertManager configs are appended, the user is responsible to make sure it
  // is valid. Note that using this feature may expose the possibility to
  // break upgrades of Prometheus. It is advised to review Prometheus release
  // notes to ensure that no incompatible AlertManager configs are going to break
  // Prometheus after the upgrade.
  optional .k8s.io.api.core.v1.SecretKeySelector additional_alert_manager_configs = 57 [(dev.f110.kubeproto.field) = { go_name: "AdditionalAlertManagerConfigs", api_field_name: "additionalAlertManagerConfigs", inline: false }];
  // APIServerConfig allows specifying a host and auth methods to access apiserver.
  // If left empty, Prometheus is assumed to run inside of the cluster
  // and will discover API servers automatically and use the pod's CA certificate
  // and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
  optional APIServerConfig api_server_config = 58 [(dev.f110.kubeproto.field) = { go_name: "APIServerConfig", api_field_name: "apiserverConfig", inline: false }];
  // Thanos configuration allows configuring various aspects of a Prometheus
  // server in a Thanos environment.
  // This section is experimental, it may change significantly without
  // deprecation notice in any release.
  // This is experimental and may change significantly without backward
  // compatibility in any release.
  optional ThanosSpec thanos = 59 [(dev.f110.kubeproto.field) = { go_name: "Thanos", api_field_name: "thanos", inline: false }];
  // Priority class assigned to the Pods
  optional string priority_class_name = 60 [(dev.f110.kubeproto.field) = { go_name: "PriorityClassName", api_field_name: "priorityClassName", inline: false }];
  // Port name used for the pods and governing service.
  // This defaults to web
  optional string port_name = 61 [(dev.f110.kubeproto.field) = { go_name: "PortName", api_field_name: "portName", inline: false }];
  // ArbitraryFSAccessThroughSMs configures whether configuration
  // based on a service monitor can access arbitrary files on the file system
  // of the Prometheus container e.g. bearer token files.
  optional ArbitraryFSAccessThroughSMsConfig arbitrary_fs_access_through_s_ms = 62 [(dev.f110.kubeproto.field) = { go_name: "ArbitraryFSAccessThroughSMs", api_field_name: "arbitraryFSAccessThroughSMs", inline: false }];
  // OverrideHonorLabels if set to true overrides all user configured honor_labels.
  // If HonorLabels is set in ServiceMonitor or PodMonitor to true, this overrides honor_labels to false.
  optional bool override_honor_labels = 63 [(dev.f110.kubeproto.field) = { go_name: "OverrideHonorLabels", api_field_name: "overrideHonorLabels", inline: false }];
  // OverrideHonorTimestamps allows to globally enforce honoring timestamps in all scrape configs.
  optional bool override_honor_timestamps = 64 [(dev.f110.kubeproto.field) = { go_name: "OverrideHonorTimestamps", api_field_name: "overrideHonorTimestamps", inline: false }];
  // IgnoreNamespaceSelectors if set to true will ignore NamespaceSelector settings from
  // the podmonitor and servicemonitor configs, and they will only discover endpoints
  // within their current namespace.  Defaults to false.
  optional bool ignore_namespace_selectors = 65 [(dev.f110.kubeproto.field) = { go_name: "IgnoreNamespaceSelectors", api_field_name: "ignoreNamespaceSelectors", inline: false }];
  // EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert
  // and metric that is user created. The label value will always be the namespace of the object that is
  // being created.
  optional string enforced_namespace_label = 66 [(dev.f110.kubeproto.field) = { go_name: "EnforcedNamespaceLabel", api_field_name: "enforcedNamespaceLabel", inline: false }];
  // PrometheusRulesExcludedFromEnforce - list of prometheus rules to be excluded from enforcing
  // of adding namespace labels. Works only if enforcedNamespaceLabel set to true.
  // Make sure both ruleNamespace and ruleName are set for each pair
  repeated PrometheusRuleExcludeConfig prometheus_rules_excluded_from_enforce = 67 [(dev.f110.kubeproto.field) = { go_name: "PrometheusRulesExcludedFromEnforce", api_field_name: "prometheusRulesExcludedFromEnforce", inline: false }];
  // QueryLogFile specifies the file to which PromQL queries are logged.
  // Note that this location must be writable, and can be persisted using an attached volume.
  // Alternatively, the location can be set to a stdout location such as `/dev/stdout` to log
  // querie information to the default Prometheus log stream.
  // This is only available in versions of Prometheus >= 2.16.0.
  // For more details, see the Prometheus docs (https://prometheus.io/docs/guides/query-log/)
  optional string query_log_file = 68 [(dev.f110.kubeproto.field) = { go_name: "QueryLogFile", api_field_name: "queryLogFile", inline: false }];
  // EnforcedSampleLimit defines global limit on number of scraped samples
  // that will be accepted. This overrides any SampleLimit set per
  // ServiceMonitor or/and PodMonitor. It is meant to be used by admins to
  // enforce the SampleLimit to keep overall number of samples/series under
  // the desired limit.
  // Note that if SampleLimit is lower that value will be taken instead.
  optional uint64 enforced_sample_limit = 69 [(dev.f110.kubeproto.field) = { go_name: "EnforcedSampleLimit", api_field_name: "enforcedSampleLimit", inline: false }];
  // AllowOverlappingBlocks enables vertical compaction and vertical query merge in Prometheus.
  // This is still experimental in Prometheus so it may change in any upcoming release.
  optional bool allow_overlapping_blocks = 70 [(dev.f110.kubeproto.field) = { go_name: "AllowOverlappingBlocks", api_field_name: "allowOverlappingBlocks", inline: false }];
  // EnforcedTargetLimit defines a global limit on the number of scraped targets.
  // This overrides any TargetLimit set per ServiceMonitor or/and PodMonitor.
  // It is meant to be used by admins to
  // enforce the TargetLimit to keep overall number of targets under
  // the desired limit.
  // Note that if TargetLimit is higher that value will be taken instead.
  optional uint64 enforced_target_limit = 71 [(dev.f110.kubeproto.field) = { go_name: "EnforcedTargetLimit", api_field_name: "enforcedTargetLimit", inline: false }];
}

message PrometheusStatus {
  // Represents whether any actions on the underlying managed objects are
  // being performed. Only delete actions will be performed.
  bool paused = 1 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // Total number of non-terminated pods targeted by this Prometheus deployment
  // (their labels match the selector).
  int32 replicas = 2 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Total number of non-terminated pods targeted by this Prometheus deployment
  // that have the desired version spec.
  int32 updated_replicas = 3 [(dev.f110.kubeproto.field) = { go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false }];
  // Total number of available pods (ready for at least minReadySeconds)
  // targeted by this Prometheus deployment.
  int32 available_replicas = 4 [(dev.f110.kubeproto.field) = { go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false }];
  // Total number of unavailable pods targeted by this Prometheus deployment.
  int32 unavailable_replicas = 5 [(dev.f110.kubeproto.field) = { go_name: "UnavailableReplicas", api_field_name: "unavailableReplicas", inline: false }];
}

message QuerySpec {
  // The delta difference allowed for retrieving metrics during expression evaluations.
  optional string lookback_delta = 1 [(dev.f110.kubeproto.field) = { go_name: "LookbackDelta", api_field_name: "lookbackDelta", inline: false }];
  // Number of concurrent queries that can be run at once.
  optional int32 max_concurrency = 2 [(dev.f110.kubeproto.field) = { go_name: "MaxConcurrency", api_field_name: "maxConcurrency", inline: false }];
  // Maximum number of samples a single query can load into memory. Note that queries will fail if they would load more samples than this into memory, so this also limits the number of samples a query can return.
  optional int32 max_samples = 3 [(dev.f110.kubeproto.field) = { go_name: "MaxSamples", api_field_name: "maxSamples", inline: false }];
  // Maximum time a query may take before being aborted.
  optional string timeout = 4 [(dev.f110.kubeproto.field) = { go_name: "Timeout", api_field_name: "timeout", inline: false }];
}

message QueueConfig {
  // Capacity is the number of samples to buffer per shard before we start dropping them.
  optional int32 capacity = 1 [(dev.f110.kubeproto.field) = { go_name: "Capacity", api_field_name: "capacity", inline: false }];
  // MinShards is the minimum number of shards, i.e. amount of concurrency.
  optional int32 min_shards = 2 [(dev.f110.kubeproto.field) = { go_name: "MinShards", api_field_name: "minShards", inline: false }];
  // MaxShards is the maximum number of shards, i.e. amount of concurrency.
  optional int32 max_shards = 3 [(dev.f110.kubeproto.field) = { go_name: "MaxShards", api_field_name: "maxShards", inline: false }];
  // MaxSamplesPerSend is the maximum number of samples per send.
  optional int32 max_samples_per_send = 4 [(dev.f110.kubeproto.field) = { go_name: "MaxSamplesPerSend", api_field_name: "maxSamplesPerSend", inline: false }];
  // BatchSendDeadline is the maximum time a sample will wait in buffer.
  optional string batch_send_deadline = 5 [(dev.f110.kubeproto.field) = { go_name: "BatchSendDeadline", api_field_name: "batchSendDeadline", inline: false }];
  // MaxRetries is the maximum number of times to retry a batch on recoverable errors.
  optional int32 max_retries = 6 [(dev.f110.kubeproto.field) = { go_name: "MaxRetries", api_field_name: "maxRetries", inline: false }];
  // MinBackoff is the initial retry delay. Gets doubled for every retry.
  optional string min_backoff = 7 [(dev.f110.kubeproto.field) = { go_name: "MinBackoff", api_field_name: "minBackoff", inline: false }];
  // MaxBackoff is the maximum retry delay.
  optional string max_backoff = 8 [(dev.f110.kubeproto.field) = { go_name: "MaxBackoff", api_field_name: "maxBackoff", inline: false }];
}

message RelabelConfig {
  // The source labels select values from existing labels. Their content is concatenated
  // using the configured separator and matched against the configured regular expression
  // for the replace, keep, and drop actions.
  repeated string source_labels = 1 [(dev.f110.kubeproto.field) = { go_name: "SourceLabels", api_field_name: "sourceLabels", inline: false }];
  // Separator placed between concatenated source label values. default is ';'.
  optional string separator = 2 [(dev.f110.kubeproto.field) = { go_name: "Separator", api_field_name: "separator", inline: false }];
  // Label to which the resulting value is written in a replace action.
  // It is mandatory for replace actions. Regex capture groups are available.
  optional string target_label = 3 [(dev.f110.kubeproto.field) = { go_name: "TargetLabel", api_field_name: "targetLabel", inline: false }];
  // Regular expression against which the extracted value is matched. Default is '(.*)'
  optional string regex = 4 [(dev.f110.kubeproto.field) = { go_name: "Regex", api_field_name: "regex", inline: false }];
  // Modulus to take of the hash of the source label values.
  optional uint64 modulus = 5 [(dev.f110.kubeproto.field) = { go_name: "Modulus", api_field_name: "modulus", inline: false }];
  // Replacement value against which a regex replace is performed if the
  // regular expression matches. Regex capture groups are available. Default is '$1'
  optional string replacement = 6 [(dev.f110.kubeproto.field) = { go_name: "Replacement", api_field_name: "replacement", inline: false }];
  // Action to perform based on regex matching. Default is 'replace'
  optional string action = 7 [(dev.f110.kubeproto.field) = { go_name: "Action", api_field_name: "action", inline: false }];
}

message RemoteReadSpec {
  // The URL of the endpoint to send samples to.
  string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // The name of the remote read queue, must be unique if specified. The name
  // is used in metrics and logging in order to differentiate read
  // configurations.  Only valid in Prometheus versions 2.15.0 and newer.
  optional string name = 2 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // An optional list of equality matchers which have to be present
  // in a selector to query the remote read endpoint.
  map<string, string> required_matchers = 3 [(dev.f110.kubeproto.field) = { go_name: "RequiredMatchers", api_field_name: "requiredMatchers", inline: false }];
  // Timeout for requests to the remote read endpoint.
  optional string remote_timeout = 4 [(dev.f110.kubeproto.field) = { go_name: "RemoteTimeout", api_field_name: "remoteTimeout", inline: false }];
  // Whether reads should be made for queries for time ranges that
  // the local storage should have complete data for.
  optional bool read_recent = 5 [(dev.f110.kubeproto.field) = { go_name: "ReadRecent", api_field_name: "readRecent", inline: false }];
  // BasicAuth for the URL.
  optional BasicAuth basic_auth = 6 [(dev.f110.kubeproto.field) = { go_name: "BasicAuth", api_field_name: "basicAuth", inline: false }];
  // bearer token for remote read.
  optional string bearer_token = 7 [(dev.f110.kubeproto.field) = { go_name: "BearerToken", api_field_name: "bearerToken", inline: false }];
  // File to read bearer token for remote read.
  optional string bearer_token_file = 8 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false }];
  // TLS Config to use for remote read.
  optional TLSConfig tls_config = 9 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // Optional ProxyURL
  optional string proxy_url = 10 [(dev.f110.kubeproto.field) = { go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false }];
}

message RemoteWriteSpec {
  // The URL of the endpoint to send samples to.
  string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // The name of the remote write queue, must be unique if specified. The
  // name is used in metrics and logging in order to differentiate queues.
  // Only valid in Prometheus versions 2.15.0 and newer.
  optional string name = 2 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Timeout for requests to the remote write endpoint.
  optional string remote_timeout = 3 [(dev.f110.kubeproto.field) = { go_name: "RemoteTimeout", api_field_name: "remoteTimeout", inline: false }];
  // Custom HTTP headers to be sent along with each remote write request.
  // Be aware that headers that are set by Prometheus itself can't be overwritten.
  // Only valid in Prometheus versions 2.25.0 and newer.
  map<string, string> headers = 4 [(dev.f110.kubeproto.field) = { go_name: "Headers", api_field_name: "headers", inline: false }];
  // The list of remote write relabel configurations.
  repeated RelabelConfig write_relabel_configs = 5 [(dev.f110.kubeproto.field) = { go_name: "WriteRelabelConfigs", api_field_name: "writeRelabelConfigs", inline: false }];
  // BasicAuth for the URL.
  optional BasicAuth basic_auth = 6 [(dev.f110.kubeproto.field) = { go_name: "BasicAuth", api_field_name: "basicAuth", inline: false }];
  // File to read bearer token for remote write.
  optional string bearer_token = 7 [(dev.f110.kubeproto.field) = { go_name: "BearerToken", api_field_name: "bearerToken", inline: false }];
  // File to read bearer token for remote write.
  optional string bearer_token_file = 8 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false }];
  // TLS Config to use for remote write.
  optional TLSConfig tls_config = 9 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // Optional ProxyURL
  optional string proxy_url = 10 [(dev.f110.kubeproto.field) = { go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false }];
  // QueueConfig allows tuning of the remote write queue parameters.
  optional QueueConfig queue_config = 11 [(dev.f110.kubeproto.field) = { go_name: "QueueConfig", api_field_name: "queueConfig", inline: false }];
}

message Rule {
  optional string                                  record      = 1 [(dev.f110.kubeproto.field) = { go_name: "Record", api_field_name: "record", inline: false }];
  optional string                                  alert       = 2 [(dev.f110.kubeproto.field) = { go_name: "Alert", api_field_name: "alert", inline: false }];
  .k8s.io.apimachinery.pkg.util.intstr.IntOrString expr        = 3 [(dev.f110.kubeproto.field) = { go_name: "Expr", api_field_name: "expr", inline: false }];
optional string for = 4 [(dev.f110.kubeproto.field) = {go_name: "For", api_field_name: "for", inline: false}];
map<string, string>                                labels      = 5 [(dev.f110.kubeproto.field) = { go_name: "Labels", api_field_name: "labels", inline: false }];
map<string, string>                                annotations = 6 [(dev.f110.kubeproto.field) = { go_name: "Annotations", api_field_name: "annotations", inline: false }];
}

message RuleGroup {
  string          name                      = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  optional string interval                  = 2 [(dev.f110.kubeproto.field) = { go_name: "Interval", api_field_name: "interval", inline: false }];
  repeated Rule   rules                     = 3 [(dev.f110.kubeproto.field) = { go_name: "Rules", api_field_name: "rules", inline: false }];
  optional string partial_response_strategy = 4 [(dev.f110.kubeproto.field) = { go_name: "PartialResponseStrategy", api_field_name: "partial_response_strategy", inline: false }];
}

message Rules {
  optional RulesAlert alert = 1 [(dev.f110.kubeproto.field) = { go_name: "Alert", api_field_name: "alert", inline: false }];
}

message RulesAlert {
  // Max time to tolerate prometheus outage for restoring 'for' state of alert.
  optional string for_outage_tolerance = 1 [(dev.f110.kubeproto.field) = { go_name: "ForOutageTolerance", api_field_name: "forOutageTolerance", inline: false }];
  // Minimum duration between alert and restored 'for' state.
  // This is maintained only for alerts with configured 'for' time greater than grace period.
  optional string for_grace_period = 2 [(dev.f110.kubeproto.field) = { go_name: "ForGracePeriod", api_field_name: "forGracePeriod", inline: false }];
  // Minimum amount of time to wait before resending an alert to Alertmanager.
  optional string resend_delay = 3 [(dev.f110.kubeproto.field) = { go_name: "ResendDelay", api_field_name: "resendDelay", inline: false }];
}

message SafeTLSConfig {
  // Struct containing the CA cert to use for the targets.
  optional SecretOrConfigMap c_a = 1 [(dev.f110.kubeproto.field) = { go_name: "CA", api_field_name: "ca", inline: false }];
  // Struct containing the client cert file for the targets.
  optional SecretOrConfigMap cert = 2 [(dev.f110.kubeproto.field) = { go_name: "Cert", api_field_name: "cert", inline: false }];
  // Secret containing the client key file for the targets.
  optional .k8s.io.api.core.v1.SecretKeySelector key_secret = 3 [(dev.f110.kubeproto.field) = { go_name: "KeySecret", api_field_name: "keySecret", inline: false }];
  // Used to verify the hostname for the targets.
  optional string server_name = 4 [(dev.f110.kubeproto.field) = { go_name: "ServerName", api_field_name: "serverName", inline: false }];
  // Disable target certificate validation.
  optional bool insecure_skip_verify = 5 [(dev.f110.kubeproto.field) = { go_name: "InsecureSkipVerify", api_field_name: "insecureSkipVerify", inline: false }];
}

message SecretOrConfigMap {
  // Secret containing data to use for the targets.
  optional .k8s.io.api.core.v1.SecretKeySelector secret = 1 [(dev.f110.kubeproto.field) = { go_name: "Secret", api_field_name: "secret", inline: false }];
  // ConfigMap containing data to use for the targets.
  optional .k8s.io.api.core.v1.ConfigMapKeySelector config_map = 2 [(dev.f110.kubeproto.field) = { go_name: "ConfigMap", api_field_name: "configMap", inline: false }];
}

message SecretOrConfigMapValidationError {
}

message ServiceMonitor {
  // Specification of desired Service selection for target discovery by
  // Prometheus.
  ServiceMonitorSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ServiceMonitorList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of ServiceMonitors
  repeated ServiceMonitor items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ServiceMonitorSpec {
  // The label to use to retrieve the job name from.
  optional string job_label = 1 [(dev.f110.kubeproto.field) = { go_name: "JobLabel", api_field_name: "jobLabel", inline: false }];
  // TargetLabels transfers labels on the Kubernetes Service onto the target.
  repeated string target_labels = 2 [(dev.f110.kubeproto.field) = { go_name: "TargetLabels", api_field_name: "targetLabels", inline: false }];
  // PodTargetLabels transfers labels on the Kubernetes Pod onto the target.
  repeated string pod_target_labels = 3 [(dev.f110.kubeproto.field) = { go_name: "PodTargetLabels", api_field_name: "podTargetLabels", inline: false }];
  // A list of endpoints allowed as part of this ServiceMonitor.
  repeated Endpoint endpoints = 4 [(dev.f110.kubeproto.field) = { go_name: "Endpoints", api_field_name: "endpoints", inline: false }];
  // Selector to select Endpoints objects.
  .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 5 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // Selector to select which namespaces the Endpoints objects are discovered from.
  optional NamespaceSelector namespace_selector = 6 [(dev.f110.kubeproto.field) = { go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false }];
  // SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
  optional uint64 sample_limit = 7 [(dev.f110.kubeproto.field) = { go_name: "SampleLimit", api_field_name: "sampleLimit", inline: false }];
  // TargetLimit defines a limit on the number of scraped targets that will be accepted.
  optional uint64 target_limit = 8 [(dev.f110.kubeproto.field) = { go_name: "TargetLimit", api_field_name: "targetLimit", inline: false }];
}

message StorageSpec {
  // Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
  // DisableMountSubPath allows to remove any subPath usage in volume mounts.
  optional bool disable_mount_sub_path = 1 [(dev.f110.kubeproto.field) = { go_name: "DisableMountSubPath", api_field_name: "disableMountSubPath", inline: false }];
  // EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
  // info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
  optional .k8s.io.api.core.v1.EmptyDirVolumeSource empty_dir = 2 [(dev.f110.kubeproto.field) = { go_name: "EmptyDir", api_field_name: "emptyDir", inline: false }];
  // A PVC spec to be used by the Prometheus StatefulSets.
  optional EmbeddedPersistentVolumeClaim volume_claim_template = 3 [(dev.f110.kubeproto.field) = { go_name: "VolumeClaimTemplate", api_field_name: "volumeClaimTemplate", inline: false }];
}

message TLSConfig {
  SafeTLSConfig safe_tls_config = 1 [(dev.f110.kubeproto.field) = { go_name: "SafeTLSConfig", inline: true }];
  // Path to the CA cert in the Prometheus container to use for the targets.
  optional string c_a_file = 2 [(dev.f110.kubeproto.field) = { go_name: "CAFile", api_field_name: "caFile", inline: false }];
  // Path to the client cert file in the Prometheus container for the targets.
  optional string cert_file = 3 [(dev.f110.kubeproto.field) = { go_name: "CertFile", api_field_name: "certFile", inline: false }];
  // Path to the client key file in the Prometheus container for the targets.
  optional string key_file = 4 [(dev.f110.kubeproto.field) = { go_name: "KeyFile", api_field_name: "keyFile", inline: false }];
}

message TLSConfigValidationError {
}

message ThanosRuler {
  // Specification of the desired behavior of the ThanosRuler cluster. More info:
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  ThanosRulerSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Most recent observed status of the ThanosRuler cluster. Read-only. Not
  // included when requesting from the apiserver, only from the ThanosRuler
  // Operator API itself. More info:
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional ThanosRulerStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ThanosRulerList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of Prometheuses
  repeated ThanosRuler items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ThanosRulerSpec {
  // PodMetadata contains Labels and Annotations gets propagated to the thanos ruler pods.
  optional EmbeddedObjectMetadata pod_metadata = 1 [(dev.f110.kubeproto.field) = { go_name: "PodMetadata", api_field_name: "podMetadata", inline: false }];
  // Thanos container image URL.
  optional string image = 2 [(dev.f110.kubeproto.field) = { go_name: "Image", api_field_name: "image", inline: false }];
  // An optional list of references to secrets in the same namespace
  // to use for pulling thanos images from registries
  // see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
  repeated .k8s.io.api.core.v1.LocalObjectReference image_pull_secrets = 3 [(dev.f110.kubeproto.field) = { go_name: "ImagePullSecrets", api_field_name: "imagePullSecrets", inline: false }];
  // When a ThanosRuler deployment is paused, no actions except for deletion
  // will be performed on the underlying objects.
  optional bool paused = 4 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // Number of thanos ruler instances to deploy.
  optional int32 replicas = 5 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Define which Nodes the Pods are scheduled on.
  map<string, string> node_selector = 6 [(dev.f110.kubeproto.field) = { go_name: "NodeSelector", api_field_name: "nodeSelector", inline: false }];
  // Resources defines the resource requirements for single Pods.
  // If not provided, no requests/limits will be set
  optional .k8s.io.api.core.v1.ResourceRequirements resources = 7 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
  // If specified, the pod's scheduling constraints.
  optional .k8s.io.api.core.v1.Affinity affinity = 8 [(dev.f110.kubeproto.field) = { go_name: "Affinity", api_field_name: "affinity", inline: false }];
  // If specified, the pod's tolerations.
  repeated .k8s.io.api.core.v1.Toleration tolerations = 9 [(dev.f110.kubeproto.field) = { go_name: "Tolerations", api_field_name: "tolerations", inline: false }];
  // If specified, the pod's topology spread constraints.
  repeated .k8s.io.api.core.v1.TopologySpreadConstraint topology_spread_constraints = 10 [(dev.f110.kubeproto.field) = { go_name: "TopologySpreadConstraints", api_field_name: "topologySpreadConstraints", inline: false }];
  // SecurityContext holds pod-level security attributes and common container settings.
  // This defaults to the default PodSecurityContext.
  optional .k8s.io.api.core.v1.PodSecurityContext security_context = 11 [(dev.f110.kubeproto.field) = { go_name: "SecurityContext", api_field_name: "securityContext", inline: false }];
  // Priority class assigned to the Pods
  optional string priority_class_name = 12 [(dev.f110.kubeproto.field) = { go_name: "PriorityClassName", api_field_name: "priorityClassName", inline: false }];
  // ServiceAccountName is the name of the ServiceAccount to use to run the
  // Thanos Ruler Pods.
  optional string service_account_name = 13 [(dev.f110.kubeproto.field) = { go_name: "ServiceAccountName", api_field_name: "serviceAccountName", inline: false }];
  // Storage spec to specify how storage shall be used.
  optional StorageSpec storage = 14 [(dev.f110.kubeproto.field) = { go_name: "Storage", api_field_name: "storage", inline: false }];
  // Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will
  // be appended to other volumes that are generated as a result of StorageSpec objects.
  repeated .k8s.io.api.core.v1.Volume volumes = 15 [(dev.f110.kubeproto.field) = { go_name: "Volumes", api_field_name: "volumes", inline: false }];
  // ObjectStorageConfig configures object storage in Thanos.
  // Alternative to ObjectStorageConfigFile, and lower order priority.
  optional .k8s.io.api.core.v1.SecretKeySelector object_storage_config = 16 [(dev.f110.kubeproto.field) = { go_name: "ObjectStorageConfig", api_field_name: "objectStorageConfig", inline: false }];
  // ObjectStorageConfigFile specifies the path of the object storage configuration file.
  // When used alongside with ObjectStorageConfig, ObjectStorageConfigFile takes precedence.
  optional string object_storage_config_file = 17 [(dev.f110.kubeproto.field) = { go_name: "ObjectStorageConfigFile", api_field_name: "objectStorageConfigFile", inline: false }];
  // ListenLocal makes the Thanos ruler listen on loopback, so that it
  // does not bind against the Pod IP.
  optional bool listen_local = 18 [(dev.f110.kubeproto.field) = { go_name: "ListenLocal", api_field_name: "listenLocal", inline: false }];
  // QueryEndpoints defines Thanos querier endpoints from which to query metrics.
  // Maps to the --query flag of thanos ruler.
  repeated string query_endpoints = 19 [(dev.f110.kubeproto.field) = { go_name: "QueryEndpoints", api_field_name: "queryEndpoints", inline: false }];
  // Define configuration for connecting to thanos query instances.
  // If this is defined, the QueryEndpoints field will be ignored.
  // Maps to the `query.config` CLI argument.
  // Only available with thanos v0.11.0 and higher.
  optional .k8s.io.api.core.v1.SecretKeySelector query_config = 20 [(dev.f110.kubeproto.field) = { go_name: "QueryConfig", api_field_name: "queryConfig", inline: false }];
  // Define URLs to send alerts to Alertmanager.  For Thanos v0.10.0 and higher,
  // AlertManagersConfig should be used instead.  Note: this field will be ignored
  // if AlertManagersConfig is specified.
  // Maps to the `alertmanagers.url` arg.
  repeated string alert_managers_url = 21 [(dev.f110.kubeproto.field) = { go_name: "AlertManagersURL", api_field_name: "alertmanagersUrl", inline: false }];
  // Define configuration for connecting to alertmanager.  Only available with thanos v0.10.0
  // and higher.  Maps to the `alertmanagers.config` arg.
  optional .k8s.io.api.core.v1.SecretKeySelector alert_managers_config = 22 [(dev.f110.kubeproto.field) = { go_name: "AlertManagersConfig", api_field_name: "alertmanagersConfig", inline: false }];
  // A label selector to select which PrometheusRules to mount for alerting and
  // recording.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector rule_selector = 23 [(dev.f110.kubeproto.field) = { go_name: "RuleSelector", api_field_name: "ruleSelector", inline: false }];
  // Namespaces to be selected for Rules discovery. If unspecified, only
  // the same namespace as the ThanosRuler object is in is used.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector rule_namespace_selector = 24 [(dev.f110.kubeproto.field) = { go_name: "RuleNamespaceSelector", api_field_name: "ruleNamespaceSelector", inline: false }];
  // EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert
  // and metric that is user created. The label value will always be the namespace of the object that is
  // being created.
  optional string enforced_namespace_label = 25 [(dev.f110.kubeproto.field) = { go_name: "EnforcedNamespaceLabel", api_field_name: "enforcedNamespaceLabel", inline: false }];
  // PrometheusRulesExcludedFromEnforce - list of Prometheus rules to be excluded from enforcing
  // of adding namespace labels. Works only if enforcedNamespaceLabel set to true.
  // Make sure both ruleNamespace and ruleName are set for each pair
  repeated PrometheusRuleExcludeConfig prometheus_rules_excluded_from_enforce = 26 [(dev.f110.kubeproto.field) = { go_name: "PrometheusRulesExcludedFromEnforce", api_field_name: "prometheusRulesExcludedFromEnforce", inline: false }];
  // Log level for ThanosRuler to be configured with.
  optional string log_level = 27 [(dev.f110.kubeproto.field) = { go_name: "LogLevel", api_field_name: "logLevel", inline: false }];
  // Log format for ThanosRuler to be configured with.
  optional string log_format = 28 [(dev.f110.kubeproto.field) = { go_name: "LogFormat", api_field_name: "logFormat", inline: false }];
  // Port name used for the pods and governing service.
  // This defaults to web
  optional string port_name = 29 [(dev.f110.kubeproto.field) = { go_name: "PortName", api_field_name: "portName", inline: false }];
  // Interval between consecutive evaluations.
  optional string evaluation_interval = 30 [(dev.f110.kubeproto.field) = { go_name: "EvaluationInterval", api_field_name: "evaluationInterval", inline: false }];
  // Time duration ThanosRuler shall retain data for. Default is '24h',
  // and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)` (milliseconds seconds minutes hours days weeks years).
  optional string retention = 31 [(dev.f110.kubeproto.field) = { go_name: "Retention", api_field_name: "retention", inline: false }];
  // Containers allows injecting additional containers or modifying operator generated
  // containers. This can be used to allow adding an authentication proxy to a ThanosRuler pod or
  // to change the behavior of an operator generated container. Containers described here modify
  // an operator generated container if they share the same name and modifications are done via a
  // strategic merge patch. The current container names are: `thanos-ruler` and `config-reloader`.
  // Overriding containers is entirely outside the scope of what the maintainers will support and by doing
  // so, you accept that this behaviour may break at any time without notice.
  repeated .k8s.io.api.core.v1.Container containers = 32 [(dev.f110.kubeproto.field) = { go_name: "Containers", api_field_name: "containers", inline: false }];
  // InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
  // fetch secrets for injection into the ThanosRuler configuration from external sources. Any
  // errors during the execution of an initContainer will lead to a restart of the Pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // Using initContainers for any use case other then secret fetching is entirely outside the scope
  // of what the maintainers will support and by doing so, you accept that this behaviour may break
  // at any time without notice.
  repeated .k8s.io.api.core.v1.Container init_containers = 33 [(dev.f110.kubeproto.field) = { go_name: "InitContainers", api_field_name: "initContainers", inline: false }];
  // TracingConfig configures tracing in Thanos. This is an experimental feature, it may change in any upcoming release in a breaking way.
  optional .k8s.io.api.core.v1.SecretKeySelector tracing_config = 34 [(dev.f110.kubeproto.field) = { go_name: "TracingConfig", api_field_name: "tracingConfig", inline: false }];
  // Labels configure the external label pairs to ThanosRuler. If not provided, default replica label
  // `thanos_ruler_replica` will be added as a label and be dropped in alerts.
  map<string, string> labels = 35 [(dev.f110.kubeproto.field) = { go_name: "Labels", api_field_name: "labels", inline: false }];
  // AlertDropLabels configure the label names which should be dropped in ThanosRuler alerts.
  // If `labels` field is not provided, `thanos_ruler_replica` will be dropped in alerts by default.
  repeated string alert_drop_labels = 36 [(dev.f110.kubeproto.field) = { go_name: "AlertDropLabels", api_field_name: "alertDropLabels", inline: false }];
  // The external URL the Thanos Ruler instances will be available under. This is
  // necessary to generate correct URLs. This is necessary if Thanos Ruler is not
  // served from root of a DNS name.
  optional string external_prefix = 37 [(dev.f110.kubeproto.field) = { go_name: "ExternalPrefix", api_field_name: "externalPrefix", inline: false }];
  // The route prefix ThanosRuler registers HTTP handlers for. This allows thanos UI to be served on a sub-path.
  optional string route_prefix = 38 [(dev.f110.kubeproto.field) = { go_name: "RoutePrefix", api_field_name: "routePrefix", inline: false }];
  // GRPCServerTLSConfig configures the gRPC server from which Thanos Querier reads
  // recorded rule data.
  // Note: Currently only the CAFile, CertFile, and KeyFile fields are supported.
  // Maps to the '--grpc-server-tls-*' CLI args.
  optional TLSConfig g_r_p_c_server_tls_config = 39 [(dev.f110.kubeproto.field) = { go_name: "GRPCServerTLSConfig", api_field_name: "grpcServerTlsConfig", inline: false }];
  // The external Query URL the Thanos Ruler will set in the 'Source' field
  // of all alerts.
  // Maps to the '--alert.query-url' CLI arg.
  optional string alert_query_url = 40 [(dev.f110.kubeproto.field) = { go_name: "AlertQueryURL", api_field_name: "alertQueryUrl", inline: false }];
}

message ThanosRulerStatus {
  // Represents whether any actions on the underlying managed objects are
  // being performed. Only delete actions will be performed.
  bool paused = 1 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // Total number of non-terminated pods targeted by this ThanosRuler deployment
  // (their labels match the selector).
  int32 replicas = 2 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Total number of non-terminated pods targeted by this ThanosRuler deployment
  // that have the desired version spec.
  int32 updated_replicas = 3 [(dev.f110.kubeproto.field) = { go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false }];
  // Total number of available pods (ready for at least minReadySeconds)
  // targeted by this ThanosRuler deployment.
  int32 available_replicas = 4 [(dev.f110.kubeproto.field) = { go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false }];
  // Total number of unavailable pods targeted by this ThanosRuler deployment.
  int32 unavailable_replicas = 5 [(dev.f110.kubeproto.field) = { go_name: "UnavailableReplicas", api_field_name: "unavailableReplicas", inline: false }];
}

message ThanosSpec {
  // Image if specified has precedence over baseImage, tag and sha
  // combinations. Specifying the version is still necessary to ensure the
  // Prometheus Operator knows what version of Thanos is being
  // configured.
  optional string image = 1 [(dev.f110.kubeproto.field) = { go_name: "Image", api_field_name: "image", inline: false }];
  // Version describes the version of Thanos to use.
  optional string version = 2 [(dev.f110.kubeproto.field) = { go_name: "Version", api_field_name: "version", inline: false }];
  // Tag of Thanos sidecar container image to be deployed. Defaults to the value of `version`.
  // Version is ignored if Tag is set.
  // Deprecated: use 'image' instead.  The image tag can be specified
  // as part of the image URL.
  optional string tag = 3 [(dev.f110.kubeproto.field) = { go_name: "Tag", api_field_name: "tag", inline: false }];
  // SHA of Thanos container image to be deployed. Defaults to the value of `version`.
  // Similar to a tag, but the SHA explicitly deploys an immutable container image.
  // Version and Tag are ignored if SHA is set.
  // Deprecated: use 'image' instead.  The image digest can be specified
  // as part of the image URL.
  optional string s_h_a = 4 [(dev.f110.kubeproto.field) = { go_name: "SHA", api_field_name: "sha", inline: false }];
  // Thanos base image if other than default.
  // Deprecated: use 'image' instead
  optional string base_image = 5 [(dev.f110.kubeproto.field) = { go_name: "BaseImage", api_field_name: "baseImage", inline: false }];
  // Resources defines the resource requirements for the Thanos sidecar.
  // If not provided, no requests/limits will be set
  optional .k8s.io.api.core.v1.ResourceRequirements resources = 6 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
  // ObjectStorageConfig configures object storage in Thanos.
  // Alternative to ObjectStorageConfigFile, and lower order priority.
  optional .k8s.io.api.core.v1.SecretKeySelector object_storage_config = 7 [(dev.f110.kubeproto.field) = { go_name: "ObjectStorageConfig", api_field_name: "objectStorageConfig", inline: false }];
  // ObjectStorageConfigFile specifies the path of the object storage configuration file.
  // When used alongside with ObjectStorageConfig, ObjectStorageConfigFile takes precedence.
  optional string object_storage_config_file = 8 [(dev.f110.kubeproto.field) = { go_name: "ObjectStorageConfigFile", api_field_name: "objectStorageConfigFile", inline: false }];
  // ListenLocal makes the Thanos sidecar listen on loopback, so that it
  // does not bind against the Pod IP.
  optional bool listen_local = 9 [(dev.f110.kubeproto.field) = { go_name: "ListenLocal", api_field_name: "listenLocal", inline: false }];
  // TracingConfig configures tracing in Thanos. This is an experimental feature, it may change in any upcoming release in a breaking way.
  optional .k8s.io.api.core.v1.SecretKeySelector tracing_config = 10 [(dev.f110.kubeproto.field) = { go_name: "TracingConfig", api_field_name: "tracingConfig", inline: false }];
  // TracingConfig specifies the path of the tracing configuration file.
  // When used alongside with TracingConfig, TracingConfigFile takes precedence.
  optional string tracing_config_file = 11 [(dev.f110.kubeproto.field) = { go_name: "TracingConfigFile", api_field_name: "tracingConfigFile", inline: false }];
  // GRPCServerTLSConfig configures the gRPC server from which Thanos Querier reads
  // recorded rule data.
  // Note: Currently only the CAFile, CertFile, and KeyFile fields are supported.
  // Maps to the '--grpc-server-tls-*' CLI args.
  optional TLSConfig g_r_p_c_server_tls_config = 12 [(dev.f110.kubeproto.field) = { go_name: "GRPCServerTLSConfig", api_field_name: "grpcServerTlsConfig", inline: false }];
  // LogLevel for Thanos sidecar to be configured with.
  optional string log_level = 13 [(dev.f110.kubeproto.field) = { go_name: "LogLevel", api_field_name: "logLevel", inline: false }];
  // LogFormat for Thanos sidecar to be configured with.
  optional string log_format = 14 [(dev.f110.kubeproto.field) = { go_name: "LogFormat", api_field_name: "logFormat", inline: false }];
  // MinTime for Thanos sidecar to be configured with. Option can be a constant time in RFC3339 format or time duration relative to current time, such as -1d or 2h45m. Valid duration units are ms, s, m, h, d, w, y.
  optional string min_time = 15 [(dev.f110.kubeproto.field) = { go_name: "MinTime", api_field_name: "minTime", inline: false }];
}

message WebSpec {
  // The prometheus web page title
  optional string page_title = 1 [(dev.f110.kubeproto.field) = { go_name: "PageTitle", api_field_name: "pageTitle", inline: false }];
}
