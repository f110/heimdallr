// Generated by: gen-go-to-protobuf
syntax = "proto3";
package github.com.prometheus_operator.prometheus_operator.pkg.apis.monitoringv1;
option go_package = "go.f110.dev/heimdallr/pkg/k8s/thirdpartyapi/prometheus-operator/monitoringv1";
option (dev.f110.kubeproto.k8s) = {
domain: "monitoring.coreos.com",
version: "v1",
};

import "kube.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

enum PrometheusConditionStatus {
PROMETHEUS_CONDITION_STATUS_TRUE = 0 [(dev.f110.kubeproto.value) = {value: "True"}];
PROMETHEUS_CONDITION_STATUS_DEGRADED = 1 [(dev.f110.kubeproto.value) = {value: "Degraded"}];
PROMETHEUS_CONDITION_STATUS_FALSE = 2 [(dev.f110.kubeproto.value) = {value: "False"}];
PROMETHEUS_CONDITION_STATUS_UNKNOWN = 3 [(dev.f110.kubeproto.value) = {value: "Unknown"}];
}

enum PrometheusConditionType {
PROMETHEUS_CONDITION_TYPE_AVAILABLE = 0 [(dev.f110.kubeproto.value) = {value: "Available"}];
PROMETHEUS_CONDITION_TYPE_RECONCILED = 1 [(dev.f110.kubeproto.value) = {value: "Reconciled"}];
}

message APIServerConfig {
// Host of apiserver.
// A valid string consisting of a hostname or IP followed by an optional port number
string host = 1 [(dev.f110.kubeproto.field) = {go_name: "Host", api_field_name: "host", inline: false}];
// BasicAuth allow an endpoint to authenticate over basic authentication
optional BasicAuth basic_auth = 2 [(dev.f110.kubeproto.field) = {go_name: "BasicAuth", api_field_name: "basicAuth", inline: false}];
// Bearer token for accessing apiserver.
optional string bearer_token = 3 [(dev.f110.kubeproto.field) = {go_name: "BearerToken", api_field_name: "bearerToken", inline: false}];
// File to read bearer token for accessing apiserver.
optional string bearer_token_file = 4 [(dev.f110.kubeproto.field) = {go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false}];
// TLS Config to use for accessing apiserver.
optional TLSConfig tls_config = 5 [(dev.f110.kubeproto.field) = {go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false}];
// Authorization section for accessing apiserver
optional Authorization authorization = 6 [(dev.f110.kubeproto.field) = {go_name: "Authorization", api_field_name: "authorization", inline: false}];
}

message AlertingSpec {
// AlertmanagerEndpoints Prometheus should fire alerts against.
repeated AlertmanagerEndpoints alertmanagers = 1 [(dev.f110.kubeproto.field) = {go_name: "Alertmanagers", api_field_name: "alertmanagers", inline: false}];
}

message Alertmanager {
// Specification of the desired behavior of the Alertmanager cluster. More info:
// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
AlertmanagerSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];
// Most recent observed status of the Alertmanager cluster. Read-only. Not
// included when requesting from the apiserver, only from the Prometheus
// Operator API itself. More info:
// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
optional AlertmanagerStatus status = 4 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", sub_resource: true, inline: false}];

option (dev.f110.kubeproto.kind) = {
};
}

message AlertmanagerConfiguration {
// The name of the AlertmanagerConfig resource which is used to generate the Alertmanager configuration.
// It must be defined in the same namespace as the Alertmanager object.
// The operator will not enforce a `namespace` label for routes and inhibition rules.
optional string name = 1 [(dev.f110.kubeproto.field) = {go_name: "Name", api_field_name: "name", inline: false}];
// Defines the global parameters of the Alertmanager configuration.
optional AlertmanagerGlobalConfig global = 2 [(dev.f110.kubeproto.field) = {go_name: "Global", api_field_name: "global", inline: false}];
}

message AlertmanagerEndpoints {
// Namespace of Endpoints object.
string namespace = 1 [(dev.f110.kubeproto.field) = {go_name: "Namespace", api_field_name: "namespace", inline: false}];
// Name of Endpoints object in Namespace.
string name = 2 [(dev.f110.kubeproto.field) = {go_name: "Name", api_field_name: "name", inline: false}];
// Port the Alertmanager API is exposed on.
.k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 3 [(dev.f110.kubeproto.field) = {go_name: "Port", api_field_name: "port", inline: false}];
// Scheme to use when firing alerts.
optional string scheme = 4 [(dev.f110.kubeproto.field) = {go_name: "Scheme", api_field_name: "scheme", inline: false}];
// Prefix for the HTTP path alerts are pushed to.
optional string path_prefix = 5 [(dev.f110.kubeproto.field) = {go_name: "PathPrefix", api_field_name: "pathPrefix", inline: false}];
// TLS Config to use for alertmanager connection.
optional TLSConfig tls_config = 6 [(dev.f110.kubeproto.field) = {go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false}];
// BearerTokenFile to read from filesystem to use when authenticating to
// Alertmanager.
optional string bearer_token_file = 7 [(dev.f110.kubeproto.field) = {go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false}];
// Authorization section for this alertmanager endpoint
optional SafeAuthorization authorization = 8 [(dev.f110.kubeproto.field) = {go_name: "Authorization", api_field_name: "authorization", inline: false}];
// Version of the Alertmanager API that Prometheus uses to send alerts. It
// can be "v1" or "v2".
optional string api_version = 9 [(dev.f110.kubeproto.field) = {go_name: "APIVersion", api_field_name: "apiVersion", inline: false}];
// Timeout is a per-target Alertmanager timeout when pushing alerts.
string timeout = 10 [(dev.f110.kubeproto.field) = {go_name: "Timeout", api_field_name: "timeout", inline: false}];
}

message AlertmanagerGlobalConfig {
// ResolveTimeout is the default value used by alertmanager if the alert does
// not include EndsAt, after this time passes it can declare the alert as resolved if it has not been updated.
// This has no impact on alerts from Prometheus, as they always include EndsAt.
string resolve_timeout = 1 [(dev.f110.kubeproto.field) = {go_name: "ResolveTimeout", api_field_name: "resolveTimeout", inline: false}];
// HTTP client configuration.
optional HTTPConfig http_config = 2 [(dev.f110.kubeproto.field) = {go_name: "HTTPConfig", api_field_name: "httpConfig", inline: false}];
}

message AlertmanagerList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
// Standard list metadata
// More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
// List of Alertmanagers
repeated Alertmanager items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message AlertmanagerSpec {
// PodMetadata configures Labels and Annotations which are propagated to the alertmanager pods.
optional EmbeddedObjectMetadata pod_metadata = 1 [(dev.f110.kubeproto.field) = {go_name: "PodMetadata", api_field_name: "podMetadata", inline: false}];
// Image if specified has precedence over baseImage, tag and sha
// combinations. Specifying the version is still necessary to ensure the
// Prometheus Operator knows what version of Alertmanager is being
// configured.
optional string image = 2 [(dev.f110.kubeproto.field) = {go_name: "Image", api_field_name: "image", inline: false}];
// Version the cluster should be on.
optional string version = 3 [(dev.f110.kubeproto.field) = {go_name: "Version", api_field_name: "version", inline: false}];
// Tag of Alertmanager container image to be deployed. Defaults to the value of `version`.
// Version is ignored if Tag is set.
// Deprecated: use 'image' instead.  The image tag can be specified
// as part of the image URL.
optional string tag = 4 [(dev.f110.kubeproto.field) = {go_name: "Tag", api_field_name: "tag", inline: false}];
// SHA of Alertmanager container image to be deployed. Defaults to the value of `version`.
// Similar to a tag, but the SHA explicitly deploys an immutable container image.
// Version and Tag are ignored if SHA is set.
// Deprecated: use 'image' instead.  The image digest can be specified
// as part of the image URL.
optional string s_h_a = 5 [(dev.f110.kubeproto.field) = {go_name: "SHA", api_field_name: "sha", inline: false}];
// Base image that is used to deploy pods, without tag.
// Deprecated: use 'image' instead
optional string base_image = 6 [(dev.f110.kubeproto.field) = {go_name: "BaseImage", api_field_name: "baseImage", inline: false}];
// An optional list of references to secrets in the same namespace
// to use for pulling prometheus and alertmanager images from registries
// see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
repeated .k8s.io.api.core.v1.LocalObjectReference image_pull_secrets = 7 [(dev.f110.kubeproto.field) = {go_name: "ImagePullSecrets", api_field_name: "imagePullSecrets", inline: false}];
// Secrets is a list of Secrets in the same namespace as the Alertmanager
// object, which shall be mounted into the Alertmanager Pods.
// The Secrets are mounted into /etc/alertmanager/secrets/<secret-name>.
repeated string secrets = 8 [(dev.f110.kubeproto.field) = {go_name: "Secrets", api_field_name: "secrets", inline: false}];
// ConfigMaps is a list of ConfigMaps in the same namespace as the Alertmanager
// object, which shall be mounted into the Alertmanager Pods.
// The ConfigMaps are mounted into /etc/alertmanager/configmaps/<configmap-name>.
repeated string config_maps = 9 [(dev.f110.kubeproto.field) = {go_name: "ConfigMaps", api_field_name: "configMaps", inline: false}];
// ConfigSecret is the name of a Kubernetes Secret in the same namespace as the
// Alertmanager object, which contains the configuration for this Alertmanager
// instance. If empty, it defaults to 'alertmanager-<alertmanager-name>'.
// The Alertmanager configuration should be available under the
// `alertmanager.yaml` key. Additional keys from the original secret are
// copied to the generated secret.
// If either the secret or the `alertmanager.yaml` key is missing, the
// operator provisions an Alertmanager configuration with one empty
// receiver (effectively dropping alert notifications).
optional string config_secret = 10 [(dev.f110.kubeproto.field) = {go_name: "ConfigSecret", api_field_name: "configSecret", inline: false}];
// Log level for Alertmanager to be configured with.
optional string log_level = 11 [(dev.f110.kubeproto.field) = {go_name: "LogLevel", api_field_name: "logLevel", inline: false}];
// Log format for Alertmanager to be configured with.
optional string log_format = 12 [(dev.f110.kubeproto.field) = {go_name: "LogFormat", api_field_name: "logFormat", inline: false}];
// Size is the expected size of the alertmanager cluster. The controller will
// eventually make the size of the running cluster equal to the expected
// size.
optional int32 replicas = 13 [(dev.f110.kubeproto.field) = {go_name: "Replicas", api_field_name: "replicas", inline: false}];
// Time duration Alertmanager shall retain data for. Default is '120h',
// and must match the regular expression `[0-9]+(ms|s|m|h)` (milliseconds seconds minutes hours).
string retention = 14 [(dev.f110.kubeproto.field) = {go_name: "Retention", api_field_name: "retention", inline: false}];
// Storage is the definition of how storage will be used by the Alertmanager
// instances.
optional StorageSpec storage = 15 [(dev.f110.kubeproto.field) = {go_name: "Storage", api_field_name: "storage", inline: false}];
// Volumes allows configuration of additional volumes on the output StatefulSet definition.
// Volumes specified will be appended to other volumes that are generated as a result of
// StorageSpec objects.
repeated .k8s.io.api.core.v1.Volume volumes = 16 [(dev.f110.kubeproto.field) = {go_name: "Volumes", api_field_name: "volumes", inline: false}];
// VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
// VolumeMounts specified will be appended to other VolumeMounts in the alertmanager container,
// that are generated as a result of StorageSpec objects.
repeated .k8s.io.api.core.v1.VolumeMount volume_mounts = 17 [(dev.f110.kubeproto.field) = {go_name: "VolumeMounts", api_field_name: "volumeMounts", inline: false}];
// The external URL the Alertmanager instances will be available under. This is
// necessary to generate correct URLs. This is necessary if Alertmanager is not
// served from root of a DNS name.
optional string external_url = 18 [(dev.f110.kubeproto.field) = {go_name: "ExternalURL", api_field_name: "externalUrl", inline: false}];
// The route prefix Alertmanager registers HTTP handlers for. This is useful,
// if using ExternalURL and a proxy is rewriting HTTP routes of a request,
// and the actual ExternalURL is still true, but the server serves requests
// under a different route prefix. For example for use with `kubectl proxy`.
optional string route_prefix = 19 [(dev.f110.kubeproto.field) = {go_name: "RoutePrefix", api_field_name: "routePrefix", inline: false}];
// If set to true all actions on the underlying managed objects are not
// goint to be performed, except for delete actions.
optional bool paused = 20 [(dev.f110.kubeproto.field) = {go_name: "Paused", api_field_name: "paused", inline: false}];
// Define which Nodes the Pods are scheduled on.
map<string, string> node_selector = 21 [(dev.f110.kubeproto.field) = {go_name: "NodeSelector", api_field_name: "nodeSelector", inline: false}];
// Define resources requests and limits for single Pods.
optional .k8s.io.api.core.v1.ResourceRequirements resources = 22 [(dev.f110.kubeproto.field) = {go_name: "Resources", api_field_name: "resources", inline: false}];
// If specified, the pod's scheduling constraints.
optional .k8s.io.api.core.v1.Affinity affinity = 23 [(dev.f110.kubeproto.field) = {go_name: "Affinity", api_field_name: "affinity", inline: false}];
// If specified, the pod's tolerations.
repeated .k8s.io.api.core.v1.Toleration tolerations = 24 [(dev.f110.kubeproto.field) = {go_name: "Tolerations", api_field_name: "tolerations", inline: false}];
// If specified, the pod's topology spread constraints.
repeated .k8s.io.api.core.v1.TopologySpreadConstraint topology_spread_constraints = 25 [(dev.f110.kubeproto.field) = {go_name: "TopologySpreadConstraints", api_field_name: "topologySpreadConstraints", inline: false}];
// SecurityContext holds pod-level security attributes and common container settings.
// This defaults to the default PodSecurityContext.
optional .k8s.io.api.core.v1.PodSecurityContext security_context = 26 [(dev.f110.kubeproto.field) = {go_name: "SecurityContext", api_field_name: "securityContext", inline: false}];
// ServiceAccountName is the name of the ServiceAccount to use to run the
// Prometheus Pods.
optional string service_account_name = 27 [(dev.f110.kubeproto.field) = {go_name: "ServiceAccountName", api_field_name: "serviceAccountName", inline: false}];
// ListenLocal makes the Alertmanager server listen on loopback, so that it
// does not bind against the Pod IP. Note this is only for the Alertmanager
// UI, not the gossip communication.
optional bool listen_local = 28 [(dev.f110.kubeproto.field) = {go_name: "ListenLocal", api_field_name: "listenLocal", inline: false}];
// Containers allows injecting additional containers. This is meant to
// allow adding an authentication proxy to an Alertmanager pod.
// Containers described here modify an operator generated container if they
// share the same name and modifications are done via a strategic merge
// patch. The current container names are: `alertmanager` and
// `config-reloader`. Overriding containers is entirely outside the scope
// of what the maintainers will support and by doing so, you accept that
// this behaviour may break at any time without notice.
repeated .k8s.io.api.core.v1.Container containers = 29 [(dev.f110.kubeproto.field) = {go_name: "Containers", api_field_name: "containers", inline: false}];
// InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
// fetch secrets for injection into the Alertmanager configuration from external sources. Any
// errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
// Using initContainers for any use case other then secret fetching is entirely outside the scope
// of what the maintainers will support and by doing so, you accept that this behaviour may break
// at any time without notice.
repeated .k8s.io.api.core.v1.Container init_containers = 30 [(dev.f110.kubeproto.field) = {go_name: "InitContainers", api_field_name: "initContainers", inline: false}];
// Priority class assigned to the Pods
optional string priority_class_name = 31 [(dev.f110.kubeproto.field) = {go_name: "PriorityClassName", api_field_name: "priorityClassName", inline: false}];
// AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.
repeated string additional_peers = 32 [(dev.f110.kubeproto.field) = {go_name: "AdditionalPeers", api_field_name: "additionalPeers", inline: false}];
// ClusterAdvertiseAddress is the explicit address to advertise in cluster.
// Needs to be provided for non RFC1918 [1] (public) addresses.
// [1] RFC1918: https://tools.ietf.org/html/rfc1918
optional string cluster_advertise_address = 33 [(dev.f110.kubeproto.field) = {go_name: "ClusterAdvertiseAddress", api_field_name: "clusterAdvertiseAddress", inline: false}];
// Interval between gossip attempts.
string cluster_gossip_interval = 34 [(dev.f110.kubeproto.field) = {go_name: "ClusterGossipInterval", api_field_name: "clusterGossipInterval", inline: false}];
// Interval between pushpull attempts.
string cluster_pushpull_interval = 35 [(dev.f110.kubeproto.field) = {go_name: "ClusterPushpullInterval", api_field_name: "clusterPushpullInterval", inline: false}];
// Timeout for cluster peering.
string cluster_peer_timeout = 36 [(dev.f110.kubeproto.field) = {go_name: "ClusterPeerTimeout", api_field_name: "clusterPeerTimeout", inline: false}];
// Port name used for the pods and governing service.
// This defaults to web
optional string port_name = 37 [(dev.f110.kubeproto.field) = {go_name: "PortName", api_field_name: "portName", inline: false}];
// ForceEnableClusterMode ensures Alertmanager does not deactivate the cluster mode when running with a single replica.
// Use case is e.g. spanning an Alertmanager cluster across Kubernetes clusters with a single replica in each.
optional bool force_enable_cluster_mode = 38 [(dev.f110.kubeproto.field) = {go_name: "ForceEnableClusterMode", api_field_name: "forceEnableClusterMode", inline: false}];
// AlertmanagerConfigs to be selected for to merge and configure Alertmanager with.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector alertmanager_config_selector = 39 [(dev.f110.kubeproto.field) = {go_name: "AlertmanagerConfigSelector", api_field_name: "alertmanagerConfigSelector", inline: false}];
// Namespaces to be selected for AlertmanagerConfig discovery. If nil, only
// check own namespace.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector alertmanager_config_namespace_selector = 40 [(dev.f110.kubeproto.field) = {go_name: "AlertmanagerConfigNamespaceSelector", api_field_name: "alertmanagerConfigNamespaceSelector", inline: false}];
// Minimum number of seconds for which a newly created pod should be ready
// without any of its container crashing for it to be considered available.
// Defaults to 0 (pod will be considered available as soon as it is ready)
// This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
optional uint32 min_ready_seconds = 41 [(dev.f110.kubeproto.field) = {go_name: "MinReadySeconds", api_field_name: "minReadySeconds", inline: false}];
// Pods' hostAliases configuration
repeated HostAlias host_aliases = 42 [(dev.f110.kubeproto.field) = {go_name: "HostAliases", api_field_name: "hostAliases", inline: false}];
// Defines the web command line flags when starting Alertmanager.
optional AlertmanagerWebSpec web = 43 [(dev.f110.kubeproto.field) = {go_name: "Web", api_field_name: "web", inline: false}];
// EXPERIMENTAL: alertmanagerConfiguration specifies the configuration of Alertmanager.
// If defined, it takes precedence over the `configSecret` field.
// This field may change in future releases.
optional AlertmanagerConfiguration alertmanager_configuration = 44 [(dev.f110.kubeproto.field) = {go_name: "AlertmanagerConfiguration", api_field_name: "alertmanagerConfiguration", inline: false}];
}

message AlertmanagerStatus {
// Represents whether any actions on the underlying managed objects are
// being performed. Only delete actions will be performed.
bool paused = 1 [(dev.f110.kubeproto.field) = {go_name: "Paused", api_field_name: "paused", inline: false}];
// Total number of non-terminated pods targeted by this Alertmanager
// cluster (their labels match the selector).
int32 replicas = 2 [(dev.f110.kubeproto.field) = {go_name: "Replicas", api_field_name: "replicas", inline: false}];
// Total number of non-terminated pods targeted by this Alertmanager
// cluster that have the desired version spec.
int32 updated_replicas = 3 [(dev.f110.kubeproto.field) = {go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false}];
// Total number of available pods (ready for at least minReadySeconds)
// targeted by this Alertmanager cluster.
int32 available_replicas = 4 [(dev.f110.kubeproto.field) = {go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false}];
// Total number of unavailable pods targeted by this Alertmanager cluster.
int32 unavailable_replicas = 5 [(dev.f110.kubeproto.field) = {go_name: "UnavailableReplicas", api_field_name: "unavailableReplicas", inline: false}];
}

message AlertmanagerWebSpec {
WebConfigFileFields web_config_file_fields = 1 [(dev.f110.kubeproto.field) = {go_name: "WebConfigFileFields", inline: true}];
}

message ArbitraryFSAccessThroughSMsConfig {
optional bool deny = 1 [(dev.f110.kubeproto.field) = {go_name: "Deny", api_field_name: "deny", inline: false}];
}

message Argument {
// Name of the argument, e.g. "scrape.discovery-reload-interval".
string name = 1 [(dev.f110.kubeproto.field) = {go_name: "Name", api_field_name: "name", inline: false}];
// Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
optional string value = 2 [(dev.f110.kubeproto.field) = {go_name: "Value", api_field_name: "value", inline: false}];
}

message AttachMetadata {
// When set to true, Prometheus must have permissions to get Nodes.
optional bool node = 1 [(dev.f110.kubeproto.field) = {go_name: "Node", api_field_name: "node", inline: false}];
}

message Authorization {
SafeAuthorization safe_authorization = 1 [(dev.f110.kubeproto.field) = {go_name: "SafeAuthorization", inline: true}];
// File to read a secret from, mutually exclusive with Credentials (from SafeAuthorization)
optional string credentials_file = 2 [(dev.f110.kubeproto.field) = {go_name: "CredentialsFile", api_field_name: "credentialsFile", inline: false}];
}

message AuthorizationValidationError {
}

message BasicAuth {
// The secret in the service monitor namespace that contains the username
// for authentication.
optional .k8s.io.api.core.v1.SecretKeySelector username = 1 [(dev.f110.kubeproto.field) = {go_name: "Username", api_field_name: "username", inline: false}];
// The secret in the service monitor namespace that contains the password
// for authentication.
optional .k8s.io.api.core.v1.SecretKeySelector password = 2 [(dev.f110.kubeproto.field) = {go_name: "Password", api_field_name: "password", inline: false}];
}

message CommonPrometheusFields {
// PodMetadata configures Labels and Annotations which are propagated to the prometheus pods.
optional EmbeddedObjectMetadata pod_metadata = 1 [(dev.f110.kubeproto.field) = {go_name: "PodMetadata", api_field_name: "podMetadata", inline: false}];
// ServiceMonitors to be selected for target discovery. *Deprecated:* if
// neither this nor podMonitorSelector are specified, configuration is
// unmanaged.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector service_monitor_selector = 2 [(dev.f110.kubeproto.field) = {go_name: "ServiceMonitorSelector", api_field_name: "serviceMonitorSelector", inline: false}];
// Namespace's labels to match for ServiceMonitor discovery. If nil, only
// check own namespace.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector service_monitor_namespace_selector = 3 [(dev.f110.kubeproto.field) = {go_name: "ServiceMonitorNamespaceSelector", api_field_name: "serviceMonitorNamespaceSelector", inline: false}];
// *Experimental* PodMonitors to be selected for target discovery.
// *Deprecated:* if neither this nor serviceMonitorSelector are specified,
// configuration is unmanaged.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector pod_monitor_selector = 4 [(dev.f110.kubeproto.field) = {go_name: "PodMonitorSelector", api_field_name: "podMonitorSelector", inline: false}];
// Namespace's labels to match for PodMonitor discovery. If nil, only
// check own namespace.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector pod_monitor_namespace_selector = 5 [(dev.f110.kubeproto.field) = {go_name: "PodMonitorNamespaceSelector", api_field_name: "podMonitorNamespaceSelector", inline: false}];
// *Experimental* Probes to be selected for target discovery.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector probe_selector = 6 [(dev.f110.kubeproto.field) = {go_name: "ProbeSelector", api_field_name: "probeSelector", inline: false}];
// *Experimental* Namespaces to be selected for Probe discovery. If nil, only check own namespace.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector probe_namespace_selector = 7 [(dev.f110.kubeproto.field) = {go_name: "ProbeNamespaceSelector", api_field_name: "probeNamespaceSelector", inline: false}];
// Version of Prometheus to be deployed.
optional string version = 8 [(dev.f110.kubeproto.field) = {go_name: "Version", api_field_name: "version", inline: false}];
// When a Prometheus deployment is paused, no actions except for deletion
// will be performed on the underlying objects.
optional bool paused = 9 [(dev.f110.kubeproto.field) = {go_name: "Paused", api_field_name: "paused", inline: false}];
// Image if specified has precedence over baseImage, tag and sha
// combinations. Specifying the version is still necessary to ensure the
// Prometheus Operator knows what version of Prometheus is being
// configured.
optional string image = 10 [(dev.f110.kubeproto.field) = {go_name: "Image", api_field_name: "image", inline: false}];
// An optional list of references to secrets in the same namespace
// to use for pulling prometheus and alertmanager images from registries
// see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
repeated .k8s.io.api.core.v1.LocalObjectReference image_pull_secrets = 11 [(dev.f110.kubeproto.field) = {go_name: "ImagePullSecrets", api_field_name: "imagePullSecrets", inline: false}];
// Number of replicas of each shard to deploy for a Prometheus deployment.
// Number of replicas multiplied by shards is the total number of Pods
// created.
optional int32 replicas = 12 [(dev.f110.kubeproto.field) = {go_name: "Replicas", api_field_name: "replicas", inline: false}];
// EXPERIMENTAL: Number of shards to distribute targets onto. Number of
// replicas multiplied by shards is the total number of Pods created. Note
// that scaling down shards will not reshard data onto remaining instances,
// it must be manually moved. Increasing shards will not reshard data
// either but it will continue to be available from the same instances. To
// query globally use Thanos sidecar and Thanos querier or remote write
// data to a central location. Sharding is done on the content of the
// `__address__` target meta-label.
optional int32 shards = 13 [(dev.f110.kubeproto.field) = {go_name: "Shards", api_field_name: "shards", inline: false}];
// Name of Prometheus external label used to denote replica name.
// Defaults to the value of `prometheus_replica`. External label will
// _not_ be added when value is set to empty string (`""`).
optional string replica_external_label_name = 14 [(dev.f110.kubeproto.field) = {go_name: "ReplicaExternalLabelName", api_field_name: "replicaExternalLabelName", inline: false}];
// Name of Prometheus external label used to denote Prometheus instance
// name. Defaults to the value of `prometheus`. External label will
// _not_ be added when value is set to empty string (`""`).
optional string prometheus_external_label_name = 15 [(dev.f110.kubeproto.field) = {go_name: "PrometheusExternalLabelName", api_field_name: "prometheusExternalLabelName", inline: false}];
// Log level for Prometheus to be configured with.
optional string log_level = 16 [(dev.f110.kubeproto.field) = {go_name: "LogLevel", api_field_name: "logLevel", inline: false}];
// Log format for Prometheus to be configured with.
optional string log_format = 17 [(dev.f110.kubeproto.field) = {go_name: "LogFormat", api_field_name: "logFormat", inline: false}];
// Interval between consecutive scrapes. Default: `30s`
string scrape_interval = 18 [(dev.f110.kubeproto.field) = {go_name: "ScrapeInterval", api_field_name: "scrapeInterval", inline: false}];
// Number of seconds to wait for target to respond before erroring.
string scrape_timeout = 19 [(dev.f110.kubeproto.field) = {go_name: "ScrapeTimeout", api_field_name: "scrapeTimeout", inline: false}];
// The labels to add to any time series or alerts when communicating with
// external systems (federation, remote storage, Alertmanager).
map<string, string> external_labels = 20 [(dev.f110.kubeproto.field) = {go_name: "ExternalLabels", api_field_name: "externalLabels", inline: false}];
// Enable Prometheus to be used as a receiver for the Prometheus remote write protocol. Defaults to the value of `false`.
// WARNING: This is not considered an efficient way of ingesting samples.
// Use it with caution for specific low-volume use cases.
// It is not suitable for replacing the ingestion via scraping and turning
// Prometheus into a push-based metrics collection system.
// For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#remote-write-receiver
// Only valid in Prometheus versions 2.33.0 and newer.
optional bool enable_remote_write_receiver = 21 [(dev.f110.kubeproto.field) = {go_name: "EnableRemoteWriteReceiver", api_field_name: "enableRemoteWriteReceiver", inline: false}];
// Enable access to Prometheus disabled features. By default, no features are enabled.
// Enabling disabled features is entirely outside the scope of what the maintainers will
// support and by doing so, you accept that this behaviour may break at any
// time without notice.
// For more information see https://prometheus.io/docs/prometheus/latest/disabled_features/
repeated string enable_features = 22 [(dev.f110.kubeproto.field) = {go_name: "EnableFeatures", api_field_name: "enableFeatures", inline: false}];
// The external URL the Prometheus instances will be available under. This is
// necessary to generate correct URLs. This is necessary if Prometheus is not
// served from root of a DNS name.
optional string external_url = 23 [(dev.f110.kubeproto.field) = {go_name: "ExternalURL", api_field_name: "externalUrl", inline: false}];
// The route prefix Prometheus registers HTTP handlers for. This is useful,
// if using ExternalURL and a proxy is rewriting HTTP routes of a request,
// and the actual ExternalURL is still true, but the server serves requests
// under a different route prefix. For example for use with `kubectl proxy`.
optional string route_prefix = 24 [(dev.f110.kubeproto.field) = {go_name: "RoutePrefix", api_field_name: "routePrefix", inline: false}];
// Storage spec to specify how storage shall be used.
optional StorageSpec storage = 25 [(dev.f110.kubeproto.field) = {go_name: "Storage", api_field_name: "storage", inline: false}];
// Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will
// be appended to other volumes that are generated as a result of StorageSpec objects.
repeated .k8s.io.api.core.v1.Volume volumes = 26 [(dev.f110.kubeproto.field) = {go_name: "Volumes", api_field_name: "volumes", inline: false}];
// VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
// VolumeMounts specified will be appended to other VolumeMounts in the prometheus container,
// that are generated as a result of StorageSpec objects.
repeated .k8s.io.api.core.v1.VolumeMount volume_mounts = 27 [(dev.f110.kubeproto.field) = {go_name: "VolumeMounts", api_field_name: "volumeMounts", inline: false}];
// Defines the web command line flags when starting Prometheus.
optional PrometheusWebSpec web = 28 [(dev.f110.kubeproto.field) = {go_name: "Web", api_field_name: "web", inline: false}];
// Define resources requests and limits for single Pods.
optional .k8s.io.api.core.v1.ResourceRequirements resources = 29 [(dev.f110.kubeproto.field) = {go_name: "Resources", api_field_name: "resources", inline: false}];
// Define which Nodes the Pods are scheduled on.
map<string, string> node_selector = 30 [(dev.f110.kubeproto.field) = {go_name: "NodeSelector", api_field_name: "nodeSelector", inline: false}];
// ServiceAccountName is the name of the ServiceAccount to use to run the
// Prometheus Pods.
optional string service_account_name = 31 [(dev.f110.kubeproto.field) = {go_name: "ServiceAccountName", api_field_name: "serviceAccountName", inline: false}];
// Secrets is a list of Secrets in the same namespace as the Prometheus
// object, which shall be mounted into the Prometheus Pods.
// The Secrets are mounted into /etc/prometheus/secrets/<secret-name>.
repeated string secrets = 32 [(dev.f110.kubeproto.field) = {go_name: "Secrets", api_field_name: "secrets", inline: false}];
// ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus
// object, which shall be mounted into the Prometheus Pods.
// The ConfigMaps are mounted into /etc/prometheus/configmaps/<configmap-name>.
repeated string config_maps = 33 [(dev.f110.kubeproto.field) = {go_name: "ConfigMaps", api_field_name: "configMaps", inline: false}];
// If specified, the pod's scheduling constraints.
optional .k8s.io.api.core.v1.Affinity affinity = 34 [(dev.f110.kubeproto.field) = {go_name: "Affinity", api_field_name: "affinity", inline: false}];
// If specified, the pod's tolerations.
repeated .k8s.io.api.core.v1.Toleration tolerations = 35 [(dev.f110.kubeproto.field) = {go_name: "Tolerations", api_field_name: "tolerations", inline: false}];
// If specified, the pod's topology spread constraints.
repeated .k8s.io.api.core.v1.TopologySpreadConstraint topology_spread_constraints = 36 [(dev.f110.kubeproto.field) = {go_name: "TopologySpreadConstraints", api_field_name: "topologySpreadConstraints", inline: false}];
// remoteWrite is the list of remote write configurations.
repeated RemoteWriteSpec remote_write = 37 [(dev.f110.kubeproto.field) = {go_name: "RemoteWrite", api_field_name: "remoteWrite", inline: false}];
// SecurityContext holds pod-level security attributes and common container settings.
// This defaults to the default PodSecurityContext.
optional .k8s.io.api.core.v1.PodSecurityContext security_context = 38 [(dev.f110.kubeproto.field) = {go_name: "SecurityContext", api_field_name: "securityContext", inline: false}];
// ListenLocal makes the Prometheus server listen on loopback, so that it
// does not bind against the Pod IP.
optional bool listen_local = 39 [(dev.f110.kubeproto.field) = {go_name: "ListenLocal", api_field_name: "listenLocal", inline: false}];
// Containers allows injecting additional containers or modifying operator
// generated containers. This can be used to allow adding an authentication
// proxy to a Prometheus pod or to change the behavior of an operator
// generated container. Containers described here modify an operator
// generated container if they share the same name and modifications are
// done via a strategic merge patch. The current container names are:
// `prometheus`, `config-reloader`, and `thanos-sidecar`. Overriding
// containers is entirely outside the scope of what the maintainers will
// support and by doing so, you accept that this behaviour may break at any
// time without notice.
repeated .k8s.io.api.core.v1.Container containers = 40 [(dev.f110.kubeproto.field) = {go_name: "Containers", api_field_name: "containers", inline: false}];
// InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
// fetch secrets for injection into the Prometheus configuration from external sources. Any errors
// during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
// InitContainers described here modify an operator
// generated init containers if they share the same name and modifications are
// done via a strategic merge patch. The current init container name is:
// `init-config-reloader`. Overriding init containers is entirely outside the
// scope of what the maintainers will support and by doing so, you accept that
// this behaviour may break at any time without notice.
repeated .k8s.io.api.core.v1.Container init_containers = 41 [(dev.f110.kubeproto.field) = {go_name: "InitContainers", api_field_name: "initContainers", inline: false}];
// AdditionalScrapeConfigs allows specifying a key of a Secret containing
// additional Prometheus scrape configurations. Scrape configurations
// specified are appended to the configurations generated by the Prometheus
// Operator. Job configurations specified must have the form as specified
// in the official Prometheus documentation:
// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
// As scrape configs are appended, the user is responsible to make sure it
// is valid. Note that using this feature may expose the possibility to
// break upgrades of Prometheus. It is advised to review Prometheus release
// notes to ensure that no incompatible scrape configs are going to break
// Prometheus after the upgrade.
optional .k8s.io.api.core.v1.SecretKeySelector additional_scrape_configs = 42 [(dev.f110.kubeproto.field) = {go_name: "AdditionalScrapeConfigs", api_field_name: "additionalScrapeConfigs", inline: false}];
// APIServerConfig allows specifying a host and auth methods to access apiserver.
// If left empty, Prometheus is assumed to run inside of the cluster
// and will discover API servers automatically and use the pod's CA certificate
// and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
optional APIServerConfig api_server_config = 43 [(dev.f110.kubeproto.field) = {go_name: "APIServerConfig", api_field_name: "apiserverConfig", inline: false}];
// Priority class assigned to the Pods
optional string priority_class_name = 44 [(dev.f110.kubeproto.field) = {go_name: "PriorityClassName", api_field_name: "priorityClassName", inline: false}];
// Port name used for the pods and governing service.
// This defaults to web
optional string port_name = 45 [(dev.f110.kubeproto.field) = {go_name: "PortName", api_field_name: "portName", inline: false}];
// ArbitraryFSAccessThroughSMs configures whether configuration
// based on a service monitor can access arbitrary files on the file system
// of the Prometheus container e.g. bearer token files.
optional ArbitraryFSAccessThroughSMsConfig arbitrary_fs_access_through_s_ms = 46 [(dev.f110.kubeproto.field) = {go_name: "ArbitraryFSAccessThroughSMs", api_field_name: "arbitraryFSAccessThroughSMs", inline: false}];
// When true, Prometheus resolves label conflicts by renaming the labels in
// the scraped data to "exported_<label value>" for all targets created
// from service and pod monitors.
// Otherwise the HonorLabels field of the service or pod monitor applies.
optional bool override_honor_labels = 47 [(dev.f110.kubeproto.field) = {go_name: "OverrideHonorLabels", api_field_name: "overrideHonorLabels", inline: false}];
// When true, Prometheus ignores the timestamps for all the targets created
// from service and pod monitors.
// Otherwise the HonorTimestamps field of the service or pod monitor applies.
optional bool override_honor_timestamps = 48 [(dev.f110.kubeproto.field) = {go_name: "OverrideHonorTimestamps", api_field_name: "overrideHonorTimestamps", inline: false}];
// IgnoreNamespaceSelectors if set to true will ignore NamespaceSelector
// settings from all PodMonitor, ServiceMonitor and Probe objects. They will
// only discover endpoints within the namespace of the PodMonitor,
// ServiceMonitor and Probe objects.
// Defaults to false.
optional bool ignore_namespace_selectors = 49 [(dev.f110.kubeproto.field) = {go_name: "IgnoreNamespaceSelectors", api_field_name: "ignoreNamespaceSelectors", inline: false}];
// EnforcedNamespaceLabel If set, a label will be added to
// 1. all user-metrics (created by `ServiceMonitor`, `PodMonitor` and `Probe` objects) and
// 2. in all `PrometheusRule` objects (except the ones excluded in `prometheusRulesExcludedFromEnforce`) to
//    * alerting & recording rules and
//    * the metrics used in their expressions (`expr`).
// Label name is this field's value.
// Label value is the namespace of the created object (mentioned above).
optional string enforced_namespace_label = 50 [(dev.f110.kubeproto.field) = {go_name: "EnforcedNamespaceLabel", api_field_name: "enforcedNamespaceLabel", inline: false}];
// EnforcedSampleLimit defines global limit on number of scraped samples
// that will be accepted. This overrides any SampleLimit set per
// ServiceMonitor or/and PodMonitor. It is meant to be used by admins to
// enforce the SampleLimit to keep overall number of samples/series under
// the desired limit.
// Note that if SampleLimit is lower that value will be taken instead.
optional uint64 enforced_sample_limit = 51 [(dev.f110.kubeproto.field) = {go_name: "EnforcedSampleLimit", api_field_name: "enforcedSampleLimit", inline: false}];
// EnforcedTargetLimit defines a global limit on the number of scraped
// targets.  This overrides any TargetLimit set per ServiceMonitor or/and
// PodMonitor.  It is meant to be used by admins to enforce the TargetLimit
// to keep the overall number of targets under the desired limit.
// Note that if TargetLimit is lower, that value will be taken instead,
// except if either value is zero, in which case the non-zero value will be
// used.  If both values are zero, no limit is enforced.
optional uint64 enforced_target_limit = 52 [(dev.f110.kubeproto.field) = {go_name: "EnforcedTargetLimit", api_field_name: "enforcedTargetLimit", inline: false}];
// Per-scrape limit on number of labels that will be accepted for a sample. If
// more than this number of labels are present post metric-relabeling, the
// entire scrape will be treated as failed. 0 means no limit.
// Only valid in Prometheus versions 2.27.0 and newer.
optional uint64 enforced_label_limit = 53 [(dev.f110.kubeproto.field) = {go_name: "EnforcedLabelLimit", api_field_name: "enforcedLabelLimit", inline: false}];
// Per-scrape limit on length of labels name that will be accepted for a sample.
// If a label name is longer than this number post metric-relabeling, the entire
// scrape will be treated as failed. 0 means no limit.
// Only valid in Prometheus versions 2.27.0 and newer.
optional uint64 enforced_label_name_length_limit = 54 [(dev.f110.kubeproto.field) = {go_name: "EnforcedLabelNameLengthLimit", api_field_name: "enforcedLabelNameLengthLimit", inline: false}];
// Per-scrape limit on length of labels value that will be accepted for a sample.
// If a label value is longer than this number post metric-relabeling, the
// entire scrape will be treated as failed. 0 means no limit.
// Only valid in Prometheus versions 2.27.0 and newer.
optional uint64 enforced_label_value_length_limit = 55 [(dev.f110.kubeproto.field) = {go_name: "EnforcedLabelValueLengthLimit", api_field_name: "enforcedLabelValueLengthLimit", inline: false}];
// EnforcedBodySizeLimit defines the maximum size of uncompressed response body
// that will be accepted by Prometheus. Targets responding with a body larger than this many bytes
// will cause the scrape to fail. Example: 100MB.
// If defined, the limit will apply to all service/pod monitors and probes.
// This is an experimental feature, this behaviour could
// change or be removed in the future.
// Only valid in Prometheus versions 2.28.0 and newer.
string enforced_body_size_limit = 56 [(dev.f110.kubeproto.field) = {go_name: "EnforcedBodySizeLimit", api_field_name: "enforcedBodySizeLimit", inline: false}];
// Minimum number of seconds for which a newly created pod should be ready
// without any of its container crashing for it to be considered available.
// Defaults to 0 (pod will be considered available as soon as it is ready)
// This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
optional uint32 min_ready_seconds = 57 [(dev.f110.kubeproto.field) = {go_name: "MinReadySeconds", api_field_name: "minReadySeconds", inline: false}];
// Pods' hostAliases configuration
repeated HostAlias host_aliases = 58 [(dev.f110.kubeproto.field) = {go_name: "HostAliases", api_field_name: "hostAliases", inline: false}];
// AdditionalArgs allows setting additional arguments for the Prometheus container.
// It is intended for e.g. activating hidden flags which are not supported by
// the dedicated configuration options yet. The arguments are passed as-is to the
// Prometheus container which may cause issues if they are invalid or not supporeted
// by the given Prometheus version.
// In case of an argument conflict (e.g. an argument which is already set by the
// operator itself) or when providing an invalid argument the reconciliation will
// fail and an error will be logged.
repeated Argument additional_args = 59 [(dev.f110.kubeproto.field) = {go_name: "AdditionalArgs", api_field_name: "additionalArgs", inline: false}];
// Enable compression of the write-ahead log using Snappy. This flag is
// only available in versions of Prometheus >= 2.11.0.
optional bool w_a_l_compression = 60 [(dev.f110.kubeproto.field) = {go_name: "WALCompression", api_field_name: "walCompression", inline: false}];
// List of references to PodMonitor, ServiceMonitor, Probe and PrometheusRule objects
// to be excluded from enforcing a namespace label of origin.
// Applies only if enforcedNamespaceLabel set to true.
repeated ObjectReference excluded_from_enforcement = 61 [(dev.f110.kubeproto.field) = {go_name: "ExcludedFromEnforcement", api_field_name: "excludedFromEnforcement", inline: false}];
}

message EmbeddedObjectMetadata {
// Name must be unique within a namespace. Is required when creating resources, although
// some resources may allow a client to request the generation of an appropriate name
// automatically. Name is primarily intended for creation idempotence and configuration
// definition.
// Cannot be updated.
// More info: http://kubernetes.io/docs/user-guide/identifiers#names
optional string name = 1 [(dev.f110.kubeproto.field) = {go_name: "Name", api_field_name: "name", inline: false}];
// Map of string keys and values that can be used to organize and categorize
// (scope and select) objects. May match selectors of replication controllers
// and services.
// More info: http://kubernetes.io/docs/user-guide/labels
map<string, string> labels = 2 [(dev.f110.kubeproto.field) = {go_name: "Labels", api_field_name: "labels", inline: false}];
// Annotations is an unstructured key value map stored with a resource that may be
// set by external tools to store and retrieve arbitrary metadata. They are not
// queryable and should be preserved when modifying objects.
// More info: http://kubernetes.io/docs/user-guide/annotations
map<string, string> annotations = 3 [(dev.f110.kubeproto.field) = {go_name: "Annotations", api_field_name: "annotations", inline: false}];
}

message EmbeddedPersistentVolumeClaim {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
// EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
optional EmbeddedObjectMetadata embedded_object_metadata = 2 [(dev.f110.kubeproto.field) = {go_name: "EmbeddedObjectMetadata", api_field_name: "metadata", inline: false}];
// Spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
optional .k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];
// Status represents the current information/status of a persistent volume claim.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
optional .k8s.io.api.core.v1.PersistentVolumeClaimStatus status = 4 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", inline: false}];
}

message Endpoint {
// Name of the service port this endpoint refers to. Mutually exclusive with targetPort.
optional string port = 1 [(dev.f110.kubeproto.field) = {go_name: "Port", api_field_name: "port", inline: false}];
// Name or number of the target port of the Pod behind the Service, the port must be specified with container port property. Mutually exclusive with port.
optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString target_port = 2 [(dev.f110.kubeproto.field) = {go_name: "TargetPort", api_field_name: "targetPort", inline: false}];
// HTTP path to scrape for metrics.
// If empty, Prometheus uses the default value (e.g. `/metrics`).
optional string path = 3 [(dev.f110.kubeproto.field) = {go_name: "Path", api_field_name: "path", inline: false}];
// HTTP scheme to use for scraping.
optional string scheme = 4 [(dev.f110.kubeproto.field) = {go_name: "Scheme", api_field_name: "scheme", inline: false}];
// Optional HTTP URL parameters
// This field can not be represented by protobuf.
// map<string, > params = 5 [(dev.f110.kubeproto.field) = {go_name: "Params", api_field_name: "params", inline: false}];
// Interval at which metrics should be scraped
// If not specified Prometheus' global scrape interval is used.
string interval = 6 [(dev.f110.kubeproto.field) = {go_name: "Interval", api_field_name: "interval", inline: false}];
// Timeout after which the scrape is ended
// If not specified, the Prometheus global scrape timeout is used unless it is less than `Interval` in which the latter is used.
string scrape_timeout = 7 [(dev.f110.kubeproto.field) = {go_name: "ScrapeTimeout", api_field_name: "scrapeTimeout", inline: false}];
// TLS configuration to use when scraping the endpoint
optional TLSConfig tls_config = 8 [(dev.f110.kubeproto.field) = {go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false}];
// File to read bearer token for scraping targets.
optional string bearer_token_file = 9 [(dev.f110.kubeproto.field) = {go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false}];
// Secret to mount to read bearer token for scraping targets. The secret
// needs to be in the same namespace as the service monitor and accessible by
// the Prometheus Operator.
optional .k8s.io.api.core.v1.SecretKeySelector bearer_token_secret = 10 [(dev.f110.kubeproto.field) = {go_name: "BearerTokenSecret", api_field_name: "bearerTokenSecret", inline: false}];
// Authorization section for this endpoint
optional SafeAuthorization authorization = 11 [(dev.f110.kubeproto.field) = {go_name: "Authorization", api_field_name: "authorization", inline: false}];
// HonorLabels chooses the metric's labels on collisions with target labels.
optional bool honor_labels = 12 [(dev.f110.kubeproto.field) = {go_name: "HonorLabels", api_field_name: "honorLabels", inline: false}];
// HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
optional bool honor_timestamps = 13 [(dev.f110.kubeproto.field) = {go_name: "HonorTimestamps", api_field_name: "honorTimestamps", inline: false}];
// BasicAuth allow an endpoint to authenticate over basic authentication
// More info: https://prometheus.io/docs/operating/configuration/#endpoints
optional BasicAuth basic_auth = 14 [(dev.f110.kubeproto.field) = {go_name: "BasicAuth", api_field_name: "basicAuth", inline: false}];
// OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
optional OAuth2 o_auth2 = 15 [(dev.f110.kubeproto.field) = {go_name: "OAuth2", api_field_name: "oauth2", inline: false}];
// MetricRelabelConfigs to apply to samples before ingestion.
repeated RelabelConfig metric_relabel_configs = 16 [(dev.f110.kubeproto.field) = {go_name: "MetricRelabelConfigs", api_field_name: "metricRelabelings", inline: false}];
// RelabelConfigs to apply to samples before scraping.
// Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields.
// The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
repeated RelabelConfig relabel_configs = 17 [(dev.f110.kubeproto.field) = {go_name: "RelabelConfigs", api_field_name: "relabelings", inline: false}];
// ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
optional string proxy_url = 18 [(dev.f110.kubeproto.field) = {go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false}];
// FollowRedirects configures whether scrape requests follow HTTP 3xx redirects.
optional bool follow_redirects = 19 [(dev.f110.kubeproto.field) = {go_name: "FollowRedirects", api_field_name: "followRedirects", inline: false}];
// Whether to enable HTTP2.
optional bool enable_http2 = 20 [(dev.f110.kubeproto.field) = {go_name: "EnableHttp2", api_field_name: "enableHttp2", inline: false}];
}

message Exemplars {
// Maximum number of exemplars stored in memory for all series.
// If not set, Prometheus uses its default value.
// A value of zero or less than zero disables the storage.
optional int64 max_size = 1 [(dev.f110.kubeproto.field) = {go_name: "MaxSize", api_field_name: "maxSize", inline: false}];
}

message HTTPConfig {
// Authorization header configuration for the client.
// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
optional SafeAuthorization authorization = 1 [(dev.f110.kubeproto.field) = {go_name: "Authorization", api_field_name: "authorization", inline: false}];
// BasicAuth for the client.
// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
optional BasicAuth basic_auth = 2 [(dev.f110.kubeproto.field) = {go_name: "BasicAuth", api_field_name: "basicAuth", inline: false}];
// OAuth2 client credentials used to fetch a token for the targets.
optional OAuth2 o_auth2 = 3 [(dev.f110.kubeproto.field) = {go_name: "OAuth2", api_field_name: "oauth2", inline: false}];
// The secret's key that contains the bearer token to be used by the client
// for authentication.
// The secret needs to be in the same namespace as the Alertmanager
// object and accessible by the Prometheus Operator.
optional .k8s.io.api.core.v1.SecretKeySelector bearer_token_secret = 4 [(dev.f110.kubeproto.field) = {go_name: "BearerTokenSecret", api_field_name: "bearerTokenSecret", inline: false}];
// TLS configuration for the client.
optional SafeTLSConfig tls_config = 5 [(dev.f110.kubeproto.field) = {go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false}];
// Optional proxy URL.
optional string proxy_url = 6 [(dev.f110.kubeproto.field) = {go_name: "ProxyURL", api_field_name: "proxyURL", inline: false}];
// FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
optional bool follow_redirects = 7 [(dev.f110.kubeproto.field) = {go_name: "FollowRedirects", api_field_name: "followRedirects", inline: false}];
}

message HostAlias {
// IP address of the host file entry.
string ip = 1 [(dev.f110.kubeproto.field) = {go_name: "IP", api_field_name: "ip", inline: false}];
// Hostnames for the above IP address.
repeated string hostnames = 2 [(dev.f110.kubeproto.field) = {go_name: "Hostnames", api_field_name: "hostnames", inline: false}];
}

message MetadataConfig {
// Whether metric metadata is sent to the remote storage or not.
optional bool send = 1 [(dev.f110.kubeproto.field) = {go_name: "Send", api_field_name: "send", inline: false}];
// How frequently metric metadata is sent to the remote storage.
string send_interval = 2 [(dev.f110.kubeproto.field) = {go_name: "SendInterval", api_field_name: "sendInterval", inline: false}];
}

message NamespaceSelector {
// Boolean describing whether all namespaces are selected in contrast to a
// list restricting them.
optional bool any = 1 [(dev.f110.kubeproto.field) = {go_name: "Any", api_field_name: "any", inline: false}];
// List of namespace names to select from.
repeated string match_names = 2 [(dev.f110.kubeproto.field) = {go_name: "MatchNames", api_field_name: "matchNames", inline: false}];
}

message OAuth2 {
// The secret or configmap containing the OAuth2 client id
SecretOrConfigMap client_id = 1 [(dev.f110.kubeproto.field) = {go_name: "ClientID", api_field_name: "clientId", inline: false}];
// The secret containing the OAuth2 client secret
.k8s.io.api.core.v1.SecretKeySelector client_secret = 2 [(dev.f110.kubeproto.field) = {go_name: "ClientSecret", api_field_name: "clientSecret", inline: false}];
// The URL to fetch the token from
string token_url = 3 [(dev.f110.kubeproto.field) = {go_name: "TokenURL", api_field_name: "tokenUrl", inline: false}];
// OAuth2 scopes used for the token request
repeated string scopes = 4 [(dev.f110.kubeproto.field) = {go_name: "Scopes", api_field_name: "scopes", inline: false}];
// Parameters to append to the token URL
map<string, string> endpoint_params = 5 [(dev.f110.kubeproto.field) = {go_name: "EndpointParams", api_field_name: "endpointParams", inline: false}];
}

message OAuth2ValidationError {
}

message ObjectReference {
// Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
string group = 1 [(dev.f110.kubeproto.field) = {go_name: "Group", api_field_name: "group", inline: false}];
// Resource of the referent.
string resource = 2 [(dev.f110.kubeproto.field) = {go_name: "Resource", api_field_name: "resource", inline: false}];
// Namespace of the referent.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
string namespace = 3 [(dev.f110.kubeproto.field) = {go_name: "Namespace", api_field_name: "namespace", inline: false}];
// Name of the referent. When not set, all resources are matched.
optional string name = 4 [(dev.f110.kubeproto.field) = {go_name: "Name", api_field_name: "name", inline: false}];
}

message PodMetricsEndpoint {
// Name of the pod port this endpoint refers to. Mutually exclusive with targetPort.
optional string port = 1 [(dev.f110.kubeproto.field) = {go_name: "Port", api_field_name: "port", inline: false}];
// Deprecated: Use 'port' instead.
optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString target_port = 2 [(dev.f110.kubeproto.field) = {go_name: "TargetPort", api_field_name: "targetPort", inline: false}];
// HTTP path to scrape for metrics.
// If empty, Prometheus uses the default value (e.g. `/metrics`).
optional string path = 3 [(dev.f110.kubeproto.field) = {go_name: "Path", api_field_name: "path", inline: false}];
// HTTP scheme to use for scraping.
optional string scheme = 4 [(dev.f110.kubeproto.field) = {go_name: "Scheme", api_field_name: "scheme", inline: false}];
// Optional HTTP URL parameters
// This field can not be represented by protobuf.
// map<string, > params = 5 [(dev.f110.kubeproto.field) = {go_name: "Params", api_field_name: "params", inline: false}];
// Interval at which metrics should be scraped
// If not specified Prometheus' global scrape interval is used.
string interval = 6 [(dev.f110.kubeproto.field) = {go_name: "Interval", api_field_name: "interval", inline: false}];
// Timeout after which the scrape is ended
// If not specified, the Prometheus global scrape interval is used.
string scrape_timeout = 7 [(dev.f110.kubeproto.field) = {go_name: "ScrapeTimeout", api_field_name: "scrapeTimeout", inline: false}];
// TLS configuration to use when scraping the endpoint.
optional PodMetricsEndpointTLSConfig tls_config = 8 [(dev.f110.kubeproto.field) = {go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false}];
// Secret to mount to read bearer token for scraping targets. The secret
// needs to be in the same namespace as the pod monitor and accessible by
// the Prometheus Operator.
optional .k8s.io.api.core.v1.SecretKeySelector bearer_token_secret = 9 [(dev.f110.kubeproto.field) = {go_name: "BearerTokenSecret", api_field_name: "bearerTokenSecret", inline: false}];
// HonorLabels chooses the metric's labels on collisions with target labels.
optional bool honor_labels = 10 [(dev.f110.kubeproto.field) = {go_name: "HonorLabels", api_field_name: "honorLabels", inline: false}];
// HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
optional bool honor_timestamps = 11 [(dev.f110.kubeproto.field) = {go_name: "HonorTimestamps", api_field_name: "honorTimestamps", inline: false}];
// BasicAuth allow an endpoint to authenticate over basic authentication.
// More info: https://prometheus.io/docs/operating/configuration/#endpoint
optional BasicAuth basic_auth = 12 [(dev.f110.kubeproto.field) = {go_name: "BasicAuth", api_field_name: "basicAuth", inline: false}];
// OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
optional OAuth2 o_auth2 = 13 [(dev.f110.kubeproto.field) = {go_name: "OAuth2", api_field_name: "oauth2", inline: false}];
// Authorization section for this endpoint
optional SafeAuthorization authorization = 14 [(dev.f110.kubeproto.field) = {go_name: "Authorization", api_field_name: "authorization", inline: false}];
// MetricRelabelConfigs to apply to samples before ingestion.
repeated RelabelConfig metric_relabel_configs = 15 [(dev.f110.kubeproto.field) = {go_name: "MetricRelabelConfigs", api_field_name: "metricRelabelings", inline: false}];
// RelabelConfigs to apply to samples before scraping.
// Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields.
// The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
repeated RelabelConfig relabel_configs = 16 [(dev.f110.kubeproto.field) = {go_name: "RelabelConfigs", api_field_name: "relabelings", inline: false}];
// ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
optional string proxy_url = 17 [(dev.f110.kubeproto.field) = {go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false}];
// FollowRedirects configures whether scrape requests follow HTTP 3xx redirects.
optional bool follow_redirects = 18 [(dev.f110.kubeproto.field) = {go_name: "FollowRedirects", api_field_name: "followRedirects", inline: false}];
// Whether to enable HTTP2.
optional bool enable_http2 = 19 [(dev.f110.kubeproto.field) = {go_name: "EnableHttp2", api_field_name: "enableHttp2", inline: false}];
}

message PodMetricsEndpointTLSConfig {
SafeTLSConfig safe_tls_config = 1 [(dev.f110.kubeproto.field) = {go_name: "SafeTLSConfig", inline: true}];
}

message PodMonitor {
// Specification of desired Pod selection for target discovery by Prometheus.
PodMonitorSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];

option (dev.f110.kubeproto.kind) = {
};
}

message PodMonitorList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
// Standard list metadata
// More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
// List of PodMonitors
repeated PodMonitor items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message PodMonitorSpec {
// The label to use to retrieve the job name from.
optional string job_label = 1 [(dev.f110.kubeproto.field) = {go_name: "JobLabel", api_field_name: "jobLabel", inline: false}];
// PodTargetLabels transfers labels on the Kubernetes Pod onto the target.
repeated string pod_target_labels = 2 [(dev.f110.kubeproto.field) = {go_name: "PodTargetLabels", api_field_name: "podTargetLabels", inline: false}];
// A list of endpoints allowed as part of this PodMonitor.
repeated PodMetricsEndpoint pod_metrics_endpoints = 3 [(dev.f110.kubeproto.field) = {go_name: "PodMetricsEndpoints", api_field_name: "podMetricsEndpoints", inline: false}];
// Selector to select Pod objects.
.k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4 [(dev.f110.kubeproto.field) = {go_name: "Selector", api_field_name: "selector", inline: false}];
// Selector to select which namespaces the Endpoints objects are discovered from.
optional NamespaceSelector namespace_selector = 5 [(dev.f110.kubeproto.field) = {go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false}];
// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
optional uint64 sample_limit = 6 [(dev.f110.kubeproto.field) = {go_name: "SampleLimit", api_field_name: "sampleLimit", inline: false}];
// TargetLimit defines a limit on the number of scraped targets that will be accepted.
optional uint64 target_limit = 7 [(dev.f110.kubeproto.field) = {go_name: "TargetLimit", api_field_name: "targetLimit", inline: false}];
// Per-scrape limit on number of labels that will be accepted for a sample.
// Only valid in Prometheus versions 2.27.0 and newer.
optional uint64 label_limit = 8 [(dev.f110.kubeproto.field) = {go_name: "LabelLimit", api_field_name: "labelLimit", inline: false}];
// Per-scrape limit on length of labels name that will be accepted for a sample.
// Only valid in Prometheus versions 2.27.0 and newer.
optional uint64 label_name_length_limit = 9 [(dev.f110.kubeproto.field) = {go_name: "LabelNameLengthLimit", api_field_name: "labelNameLengthLimit", inline: false}];
// Per-scrape limit on length of labels value that will be accepted for a sample.
// Only valid in Prometheus versions 2.27.0 and newer.
optional uint64 label_value_length_limit = 10 [(dev.f110.kubeproto.field) = {go_name: "LabelValueLengthLimit", api_field_name: "labelValueLengthLimit", inline: false}];
// Attaches node metadata to discovered targets. Only valid for role: pod.
// Only valid in Prometheus versions 2.35.0 and newer.
optional AttachMetadata attach_metadata = 11 [(dev.f110.kubeproto.field) = {go_name: "AttachMetadata", api_field_name: "attachMetadata", inline: false}];
}

message Probe {
// Specification of desired Ingress selection for target discovery by Prometheus.
ProbeSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];

option (dev.f110.kubeproto.kind) = {
};
}

message ProbeList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
// Standard list metadata
// More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
// List of Probes
repeated Probe items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message ProbeSpec {
// The job name assigned to scraped metrics by default.
optional string job_name = 1 [(dev.f110.kubeproto.field) = {go_name: "JobName", api_field_name: "jobName", inline: false}];
// Specification for the prober to use for probing targets.
// The prober.URL parameter is required. Targets cannot be probed if left empty.
optional ProberSpec prober_spec = 2 [(dev.f110.kubeproto.field) = {go_name: "ProberSpec", api_field_name: "prober", inline: false}];
// The module to use for probing specifying how to probe the target.
// Example module configuring in the blackbox exporter:
// https://github.com/prometheus/blackbox_exporter/blob/master/example.yml
optional string module = 3 [(dev.f110.kubeproto.field) = {go_name: "Module", api_field_name: "module", inline: false}];
// Targets defines a set of static or dynamically discovered targets to probe.
optional ProbeTargets targets = 4 [(dev.f110.kubeproto.field) = {go_name: "Targets", api_field_name: "targets", inline: false}];
// Interval at which targets are probed using the configured prober.
// If not specified Prometheus' global scrape interval is used.
string interval = 5 [(dev.f110.kubeproto.field) = {go_name: "Interval", api_field_name: "interval", inline: false}];
// Timeout for scraping metrics from the Prometheus exporter.
// If not specified, the Prometheus global scrape interval is used.
string scrape_timeout = 6 [(dev.f110.kubeproto.field) = {go_name: "ScrapeTimeout", api_field_name: "scrapeTimeout", inline: false}];
// TLS configuration to use when scraping the endpoint.
optional ProbeTLSConfig tls_config = 7 [(dev.f110.kubeproto.field) = {go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false}];
// Secret to mount to read bearer token for scraping targets. The secret
// needs to be in the same namespace as the probe and accessible by
// the Prometheus Operator.
optional .k8s.io.api.core.v1.SecretKeySelector bearer_token_secret = 8 [(dev.f110.kubeproto.field) = {go_name: "BearerTokenSecret", api_field_name: "bearerTokenSecret", inline: false}];
// BasicAuth allow an endpoint to authenticate over basic authentication.
// More info: https://prometheus.io/docs/operating/configuration/#endpoint
optional BasicAuth basic_auth = 9 [(dev.f110.kubeproto.field) = {go_name: "BasicAuth", api_field_name: "basicAuth", inline: false}];
// OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
optional OAuth2 o_auth2 = 10 [(dev.f110.kubeproto.field) = {go_name: "OAuth2", api_field_name: "oauth2", inline: false}];
// MetricRelabelConfigs to apply to samples before ingestion.
repeated RelabelConfig metric_relabel_configs = 11 [(dev.f110.kubeproto.field) = {go_name: "MetricRelabelConfigs", api_field_name: "metricRelabelings", inline: false}];
// Authorization section for this endpoint
optional SafeAuthorization authorization = 12 [(dev.f110.kubeproto.field) = {go_name: "Authorization", api_field_name: "authorization", inline: false}];
// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
optional uint64 sample_limit = 13 [(dev.f110.kubeproto.field) = {go_name: "SampleLimit", api_field_name: "sampleLimit", inline: false}];
// TargetLimit defines a limit on the number of scraped targets that will be accepted.
optional uint64 target_limit = 14 [(dev.f110.kubeproto.field) = {go_name: "TargetLimit", api_field_name: "targetLimit", inline: false}];
// Per-scrape limit on number of labels that will be accepted for a sample.
// Only valid in Prometheus versions 2.27.0 and newer.
optional uint64 label_limit = 15 [(dev.f110.kubeproto.field) = {go_name: "LabelLimit", api_field_name: "labelLimit", inline: false}];
// Per-scrape limit on length of labels name that will be accepted for a sample.
// Only valid in Prometheus versions 2.27.0 and newer.
optional uint64 label_name_length_limit = 16 [(dev.f110.kubeproto.field) = {go_name: "LabelNameLengthLimit", api_field_name: "labelNameLengthLimit", inline: false}];
// Per-scrape limit on length of labels value that will be accepted for a sample.
// Only valid in Prometheus versions 2.27.0 and newer.
optional uint64 label_value_length_limit = 17 [(dev.f110.kubeproto.field) = {go_name: "LabelValueLengthLimit", api_field_name: "labelValueLengthLimit", inline: false}];
}

message ProbeTLSConfig {
SafeTLSConfig safe_tls_config = 1 [(dev.f110.kubeproto.field) = {go_name: "SafeTLSConfig", inline: true}];
}

message ProbeTargetIngress {
// Selector to select the Ingress objects.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1 [(dev.f110.kubeproto.field) = {go_name: "Selector", api_field_name: "selector", inline: false}];
// From which namespaces to select Ingress objects.
optional NamespaceSelector namespace_selector = 2 [(dev.f110.kubeproto.field) = {go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false}];
// RelabelConfigs to apply to the label set of the target before it gets
// scraped.
// The original ingress address is available via the
// `__tmp_prometheus_ingress_address` label. It can be used to customize the
// probed URL.
// The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
repeated RelabelConfig relabel_configs = 3 [(dev.f110.kubeproto.field) = {go_name: "RelabelConfigs", api_field_name: "relabelingConfigs", inline: false}];
}

message ProbeTargetStaticConfig {
// The list of hosts to probe.
repeated string targets = 1 [(dev.f110.kubeproto.field) = {go_name: "Targets", api_field_name: "static", inline: false}];
// Labels assigned to all metrics scraped from the targets.
map<string, string> labels = 2 [(dev.f110.kubeproto.field) = {go_name: "Labels", api_field_name: "labels", inline: false}];
// RelabelConfigs to apply to the label set of the targets before it gets
// scraped.
// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
repeated RelabelConfig relabel_configs = 3 [(dev.f110.kubeproto.field) = {go_name: "RelabelConfigs", api_field_name: "relabelingConfigs", inline: false}];
}

message ProbeTargets {
// staticConfig defines the static list of targets to probe and the
// relabeling configuration.
// If `ingress` is also defined, `staticConfig` takes precedence.
// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
optional ProbeTargetStaticConfig static_config = 1 [(dev.f110.kubeproto.field) = {go_name: "StaticConfig", api_field_name: "staticConfig", inline: false}];
// ingress defines the Ingress objects to probe and the relabeling
// configuration.
// If `staticConfig` is also defined, `staticConfig` takes precedence.
optional ProbeTargetIngress ingress = 2 [(dev.f110.kubeproto.field) = {go_name: "Ingress", api_field_name: "ingress", inline: false}];
}

message ProbeTargetsValidationError {
}

message ProberSpec {
// Mandatory URL of the prober.
string url = 1 [(dev.f110.kubeproto.field) = {go_name: "URL", api_field_name: "url", inline: false}];
// HTTP scheme to use for scraping.
// Defaults to `http`.
optional string scheme = 2 [(dev.f110.kubeproto.field) = {go_name: "Scheme", api_field_name: "scheme", inline: false}];
// Path to collect metrics from.
// Defaults to `/probe`.
optional string path = 3 [(dev.f110.kubeproto.field) = {go_name: "Path", api_field_name: "path", inline: false}];
// Optional ProxyURL.
optional string proxy_url = 4 [(dev.f110.kubeproto.field) = {go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false}];
}

message Prometheus {
// Specification of the desired behavior of the Prometheus cluster. More info:
// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
PrometheusSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];
// Most recent observed status of the Prometheus cluster. Read-only.
// More info:
// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
optional PrometheusStatus status = 4 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", sub_resource: true, inline: false}];

option (dev.f110.kubeproto.kind) = {
};
}

message PrometheusCondition {
// Type of the condition being reported.
PrometheusConditionType type = 1 [(dev.f110.kubeproto.field) = {go_name: "Type", api_field_name: "type", inline: false}];
// status of the condition.
PrometheusConditionStatus status = 2 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", inline: false}];
// lastTransitionTime is the time of the last update to the current status property.
.k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = {go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false}];
// Reason for the condition's last transition.
optional string reason = 4 [(dev.f110.kubeproto.field) = {go_name: "Reason", api_field_name: "reason", inline: false}];
// Human-readable message indicating details for the condition's last transition.
optional string message = 5 [(dev.f110.kubeproto.field) = {go_name: "Message", api_field_name: "message", inline: false}];
}

message PrometheusList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
// Standard list metadata
// More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
// List of Prometheuses
repeated Prometheus items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message PrometheusRule {
// Specification of desired alerting rule definitions for Prometheus.
PrometheusRuleSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];

option (dev.f110.kubeproto.kind) = {
};
}

message PrometheusRuleExcludeConfig {
// RuleNamespace - namespace of excluded rule
string rule_namespace = 1 [(dev.f110.kubeproto.field) = {go_name: "RuleNamespace", api_field_name: "ruleNamespace", inline: false}];
// RuleNamespace - name of excluded rule
string rule_name = 2 [(dev.f110.kubeproto.field) = {go_name: "RuleName", api_field_name: "ruleName", inline: false}];
}

message PrometheusRuleList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
// Standard list metadata
// More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
// List of Rules
repeated PrometheusRule items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message PrometheusRuleSpec {
// Content of Prometheus rule file
repeated RuleGroup groups = 1 [(dev.f110.kubeproto.field) = {go_name: "Groups", api_field_name: "groups", inline: false}];
}

message PrometheusSpec {
CommonPrometheusFields common_prometheus_fields = 1 [(dev.f110.kubeproto.field) = {go_name: "CommonPrometheusFields", inline: true}];
// Base image to use for a Prometheus deployment.
// Deprecated: use 'image' instead
optional string base_image = 2 [(dev.f110.kubeproto.field) = {go_name: "BaseImage", api_field_name: "baseImage", inline: false}];
// Tag of Prometheus container image to be deployed. Defaults to the value of `version`.
// Version is ignored if Tag is set.
// Deprecated: use 'image' instead.  The image tag can be specified
// as part of the image URL.
optional string tag = 3 [(dev.f110.kubeproto.field) = {go_name: "Tag", api_field_name: "tag", inline: false}];
// SHA of Prometheus container image to be deployed. Defaults to the value of `version`.
// Similar to a tag, but the SHA explicitly deploys an immutable container image.
// Version and Tag are ignored if SHA is set.
// Deprecated: use 'image' instead.  The image digest can be specified
// as part of the image URL.
optional string s_h_a = 4 [(dev.f110.kubeproto.field) = {go_name: "SHA", api_field_name: "sha", inline: false}];
// Time duration Prometheus shall retain data for. Default is '24h' if
// retentionSize is not set, and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)`
// (milliseconds seconds minutes hours days weeks years).
string retention = 5 [(dev.f110.kubeproto.field) = {go_name: "Retention", api_field_name: "retention", inline: false}];
// Maximum amount of disk space used by blocks.
string retention_size = 6 [(dev.f110.kubeproto.field) = {go_name: "RetentionSize", api_field_name: "retentionSize", inline: false}];
// Disable prometheus compaction.
optional bool disable_compaction = 7 [(dev.f110.kubeproto.field) = {go_name: "DisableCompaction", api_field_name: "disableCompaction", inline: false}];
// /--rules.*/ command-line arguments.
optional Rules rules = 8 [(dev.f110.kubeproto.field) = {go_name: "Rules", api_field_name: "rules", inline: false}];
// PrometheusRulesExcludedFromEnforce - list of prometheus rules to be excluded from enforcing
// of adding namespace labels. Works only if enforcedNamespaceLabel set to true.
// Make sure both ruleNamespace and ruleName are set for each pair.
// Deprecated: use excludedFromEnforcement instead.
repeated PrometheusRuleExcludeConfig prometheus_rules_excluded_from_enforce = 9 [(dev.f110.kubeproto.field) = {go_name: "PrometheusRulesExcludedFromEnforce", api_field_name: "prometheusRulesExcludedFromEnforce", inline: false}];
// QuerySpec defines the query command line flags when starting Prometheus.
optional QuerySpec query = 10 [(dev.f110.kubeproto.field) = {go_name: "Query", api_field_name: "query", inline: false}];
// A selector to select which PrometheusRules to mount for loading alerting/recording
// rules from. Until (excluding) Prometheus Operator v0.24.0 Prometheus
// Operator will migrate any legacy rule ConfigMaps to PrometheusRule custom
// resources selected by RuleSelector. Make sure it does not match any config
// maps that you do not want to be migrated.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector rule_selector = 11 [(dev.f110.kubeproto.field) = {go_name: "RuleSelector", api_field_name: "ruleSelector", inline: false}];
// Namespaces to be selected for PrometheusRules discovery. If unspecified, only
// the same namespace as the Prometheus object is in is used.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector rule_namespace_selector = 12 [(dev.f110.kubeproto.field) = {go_name: "RuleNamespaceSelector", api_field_name: "ruleNamespaceSelector", inline: false}];
// Define details regarding alerting.
optional AlertingSpec alerting = 13 [(dev.f110.kubeproto.field) = {go_name: "Alerting", api_field_name: "alerting", inline: false}];
// remoteRead is the list of remote read configurations.
repeated RemoteReadSpec remote_read = 14 [(dev.f110.kubeproto.field) = {go_name: "RemoteRead", api_field_name: "remoteRead", inline: false}];
// AdditionalAlertRelabelConfigs allows specifying a key of a Secret containing
// additional Prometheus alert relabel configurations. Alert relabel configurations
// specified are appended to the configurations generated by the Prometheus
// Operator. Alert relabel configurations specified must have the form as specified
// in the official Prometheus documentation:
// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs.
// As alert relabel configs are appended, the user is responsible to make sure it
// is valid. Note that using this feature may expose the possibility to
// break upgrades of Prometheus. It is advised to review Prometheus release
// notes to ensure that no incompatible alert relabel configs are going to break
// Prometheus after the upgrade.
optional .k8s.io.api.core.v1.SecretKeySelector additional_alert_relabel_configs = 15 [(dev.f110.kubeproto.field) = {go_name: "AdditionalAlertRelabelConfigs", api_field_name: "additionalAlertRelabelConfigs", inline: false}];
// AdditionalAlertManagerConfigs allows specifying a key of a Secret containing
// additional Prometheus AlertManager configurations. AlertManager configurations
// specified are appended to the configurations generated by the Prometheus
// Operator. Job configurations specified must have the form as specified
// in the official Prometheus documentation:
// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config.
// As AlertManager configs are appended, the user is responsible to make sure it
// is valid. Note that using this feature may expose the possibility to
// break upgrades of Prometheus. It is advised to review Prometheus release
// notes to ensure that no incompatible AlertManager configs are going to break
// Prometheus after the upgrade.
optional .k8s.io.api.core.v1.SecretKeySelector additional_alert_manager_configs = 16 [(dev.f110.kubeproto.field) = {go_name: "AdditionalAlertManagerConfigs", api_field_name: "additionalAlertManagerConfigs", inline: false}];
// Thanos configuration allows configuring various aspects of a Prometheus
// server in a Thanos environment.
// This section is experimental, it may change significantly without
// deprecation notice in any release.
// This is experimental and may change significantly without backward
// compatibility in any release.
optional ThanosSpec thanos = 17 [(dev.f110.kubeproto.field) = {go_name: "Thanos", api_field_name: "thanos", inline: false}];
// QueryLogFile specifies the file to which PromQL queries are logged.
// If the filename has an empty path, e.g. 'query.log', prometheus-operator will mount the file into an
// emptyDir volume at `/var/log/prometheus`. If a full path is provided, e.g. /var/log/prometheus/query.log, you must mount a volume
// in the specified directory and it must be writable. This is because the prometheus container runs with a read-only root filesystem for security reasons.
// Alternatively, the location can be set to a stdout location such as `/dev/stdout` to log
// query information to the default Prometheus log stream.
// This is only available in versions of Prometheus >= 2.16.0.
// For more details, see the Prometheus docs (https://prometheus.io/docs/guides/query-log/)
optional string query_log_file = 18 [(dev.f110.kubeproto.field) = {go_name: "QueryLogFile", api_field_name: "queryLogFile", inline: false}];
// AllowOverlappingBlocks enables vertical compaction and vertical query merge in Prometheus.
// This is still experimental in Prometheus so it may change in any upcoming release.
optional bool allow_overlapping_blocks = 19 [(dev.f110.kubeproto.field) = {go_name: "AllowOverlappingBlocks", api_field_name: "allowOverlappingBlocks", inline: false}];
// Exemplars related settings that are runtime reloadable.
// It requires to enable the exemplar storage feature to be effective.
optional Exemplars exemplars = 20 [(dev.f110.kubeproto.field) = {go_name: "Exemplars", api_field_name: "exemplars", inline: false}];
// Interval between consecutive evaluations. Default: `30s`
string evaluation_interval = 21 [(dev.f110.kubeproto.field) = {go_name: "EvaluationInterval", api_field_name: "evaluationInterval", inline: false}];
// Enable access to prometheus web admin API. Defaults to the value of `false`.
// WARNING: Enabling the admin APIs enables mutating endpoints, to delete data,
// shutdown Prometheus, and more. Enabling this should be done with care and the
// user is advised to add additional authentication authorization via a proxy to
// ensure only clients authorized to perform these actions can do so.
// For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis
optional bool enable_admin_api = 22 [(dev.f110.kubeproto.field) = {go_name: "EnableAdminAPI", api_field_name: "enableAdminAPI", inline: false}];
}

message PrometheusStatus {
// Represents whether any actions on the underlying managed objects are
// being performed. Only delete actions will be performed.
bool paused = 1 [(dev.f110.kubeproto.field) = {go_name: "Paused", api_field_name: "paused", inline: false}];
// Total number of non-terminated pods targeted by this Prometheus deployment
// (their labels match the selector).
int32 replicas = 2 [(dev.f110.kubeproto.field) = {go_name: "Replicas", api_field_name: "replicas", inline: false}];
// Total number of non-terminated pods targeted by this Prometheus deployment
// that have the desired version spec.
int32 updated_replicas = 3 [(dev.f110.kubeproto.field) = {go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false}];
// Total number of available pods (ready for at least minReadySeconds)
// targeted by this Prometheus deployment.
int32 available_replicas = 4 [(dev.f110.kubeproto.field) = {go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false}];
// Total number of unavailable pods targeted by this Prometheus deployment.
int32 unavailable_replicas = 5 [(dev.f110.kubeproto.field) = {go_name: "UnavailableReplicas", api_field_name: "unavailableReplicas", inline: false}];
// The current state of the Prometheus deployment.
repeated PrometheusCondition conditions = 6 [(dev.f110.kubeproto.field) = {go_name: "Conditions", api_field_name: "conditions", inline: false}];
// The list has one entry per shard. Each entry provides a summary of the shard status.
repeated ShardStatus shard_statuses = 7 [(dev.f110.kubeproto.field) = {go_name: "ShardStatuses", api_field_name: "shardStatuses", inline: false}];
}

message PrometheusWebSpec {
WebConfigFileFields web_config_file_fields = 1 [(dev.f110.kubeproto.field) = {go_name: "WebConfigFileFields", inline: true}];
// The prometheus web page title
optional string page_title = 2 [(dev.f110.kubeproto.field) = {go_name: "PageTitle", api_field_name: "pageTitle", inline: false}];
}

message QuerySpec {
// The delta difference allowed for retrieving metrics during expression evaluations.
optional string lookback_delta = 1 [(dev.f110.kubeproto.field) = {go_name: "LookbackDelta", api_field_name: "lookbackDelta", inline: false}];
// Number of concurrent queries that can be run at once.
optional int32 max_concurrency = 2 [(dev.f110.kubeproto.field) = {go_name: "MaxConcurrency", api_field_name: "maxConcurrency", inline: false}];
// Maximum number of samples a single query can load into memory. Note that queries will fail if they would load more samples than this into memory, so this also limits the number of samples a query can return.
optional int32 max_samples = 3 [(dev.f110.kubeproto.field) = {go_name: "MaxSamples", api_field_name: "maxSamples", inline: false}];
// Maximum time a query may take before being aborted.
string timeout = 4 [(dev.f110.kubeproto.field) = {go_name: "Timeout", api_field_name: "timeout", inline: false}];
}

message QueueConfig {
// Capacity is the number of samples to buffer per shard before we start dropping them.
optional int32 capacity = 1 [(dev.f110.kubeproto.field) = {go_name: "Capacity", api_field_name: "capacity", inline: false}];
// MinShards is the minimum number of shards, i.e. amount of concurrency.
optional int32 min_shards = 2 [(dev.f110.kubeproto.field) = {go_name: "MinShards", api_field_name: "minShards", inline: false}];
// MaxShards is the maximum number of shards, i.e. amount of concurrency.
optional int32 max_shards = 3 [(dev.f110.kubeproto.field) = {go_name: "MaxShards", api_field_name: "maxShards", inline: false}];
// MaxSamplesPerSend is the maximum number of samples per send.
optional int32 max_samples_per_send = 4 [(dev.f110.kubeproto.field) = {go_name: "MaxSamplesPerSend", api_field_name: "maxSamplesPerSend", inline: false}];
// BatchSendDeadline is the maximum time a sample will wait in buffer.
optional string batch_send_deadline = 5 [(dev.f110.kubeproto.field) = {go_name: "BatchSendDeadline", api_field_name: "batchSendDeadline", inline: false}];
// MaxRetries is the maximum number of times to retry a batch on recoverable errors.
optional int32 max_retries = 6 [(dev.f110.kubeproto.field) = {go_name: "MaxRetries", api_field_name: "maxRetries", inline: false}];
// MinBackoff is the initial retry delay. Gets doubled for every retry.
optional string min_backoff = 7 [(dev.f110.kubeproto.field) = {go_name: "MinBackoff", api_field_name: "minBackoff", inline: false}];
// MaxBackoff is the maximum retry delay.
optional string max_backoff = 8 [(dev.f110.kubeproto.field) = {go_name: "MaxBackoff", api_field_name: "maxBackoff", inline: false}];
// Retry upon receiving a 429 status code from the remote-write storage.
// This is experimental feature and might change in the future.
optional bool retry_on_rate_limit = 9 [(dev.f110.kubeproto.field) = {go_name: "RetryOnRateLimit", api_field_name: "retryOnRateLimit", inline: false}];
}

message RelabelConfig {
// The source labels select values from existing labels. Their content is concatenated
// using the configured separator and matched against the configured regular expression
// for the replace, keep, and drop actions.
repeated string source_labels = 1 [(dev.f110.kubeproto.field) = {go_name: "SourceLabels", api_field_name: "sourceLabels", inline: false}];
// Separator placed between concatenated source label values. default is ';'.
optional string separator = 2 [(dev.f110.kubeproto.field) = {go_name: "Separator", api_field_name: "separator", inline: false}];
// Label to which the resulting value is written in a replace action.
// It is mandatory for replace actions. Regex capture groups are available.
optional string target_label = 3 [(dev.f110.kubeproto.field) = {go_name: "TargetLabel", api_field_name: "targetLabel", inline: false}];
// Regular expression against which the extracted value is matched. Default is '(.*)'
optional string regex = 4 [(dev.f110.kubeproto.field) = {go_name: "Regex", api_field_name: "regex", inline: false}];
// Modulus to take of the hash of the source label values.
optional uint64 modulus = 5 [(dev.f110.kubeproto.field) = {go_name: "Modulus", api_field_name: "modulus", inline: false}];
// Replacement value against which a regex replace is performed if the
// regular expression matches. Regex capture groups are available. Default is '$1'
optional string replacement = 6 [(dev.f110.kubeproto.field) = {go_name: "Replacement", api_field_name: "replacement", inline: false}];
// Action to perform based on regex matching. Default is 'replace'.
// uppercase and lowercase actions require Prometheus >= 2.36.
optional string action = 7 [(dev.f110.kubeproto.field) = {go_name: "Action", api_field_name: "action", inline: false}];
}

message RemoteReadSpec {
// The URL of the endpoint to query from.
string url = 1 [(dev.f110.kubeproto.field) = {go_name: "URL", api_field_name: "url", inline: false}];
// The name of the remote read queue, it must be unique if specified. The name
// is used in metrics and logging in order to differentiate read
// configurations.  Only valid in Prometheus versions 2.15.0 and newer.
optional string name = 2 [(dev.f110.kubeproto.field) = {go_name: "Name", api_field_name: "name", inline: false}];
// An optional list of equality matchers which have to be present
// in a selector to query the remote read endpoint.
map<string, string> required_matchers = 3 [(dev.f110.kubeproto.field) = {go_name: "RequiredMatchers", api_field_name: "requiredMatchers", inline: false}];
// Timeout for requests to the remote read endpoint.
string remote_timeout = 4 [(dev.f110.kubeproto.field) = {go_name: "RemoteTimeout", api_field_name: "remoteTimeout", inline: false}];
// Custom HTTP headers to be sent along with each remote read request.
// Be aware that headers that are set by Prometheus itself can't be overwritten.
// Only valid in Prometheus versions 2.26.0 and newer.
map<string, string> headers = 5 [(dev.f110.kubeproto.field) = {go_name: "Headers", api_field_name: "headers", inline: false}];
// Whether reads should be made for queries for time ranges that
// the local storage should have complete data for.
optional bool read_recent = 6 [(dev.f110.kubeproto.field) = {go_name: "ReadRecent", api_field_name: "readRecent", inline: false}];
// BasicAuth for the URL.
optional BasicAuth basic_auth = 7 [(dev.f110.kubeproto.field) = {go_name: "BasicAuth", api_field_name: "basicAuth", inline: false}];
// OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
optional OAuth2 o_auth2 = 8 [(dev.f110.kubeproto.field) = {go_name: "OAuth2", api_field_name: "oauth2", inline: false}];
// Bearer token for remote read.
optional string bearer_token = 9 [(dev.f110.kubeproto.field) = {go_name: "BearerToken", api_field_name: "bearerToken", inline: false}];
// File to read bearer token for remote read.
optional string bearer_token_file = 10 [(dev.f110.kubeproto.field) = {go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false}];
// Authorization section for remote read
optional Authorization authorization = 11 [(dev.f110.kubeproto.field) = {go_name: "Authorization", api_field_name: "authorization", inline: false}];
// TLS Config to use for remote read.
optional TLSConfig tls_config = 12 [(dev.f110.kubeproto.field) = {go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false}];
// Optional ProxyURL.
optional string proxy_url = 13 [(dev.f110.kubeproto.field) = {go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false}];
}

message RemoteWriteSpec {
// The URL of the endpoint to send samples to.
string url = 1 [(dev.f110.kubeproto.field) = {go_name: "URL", api_field_name: "url", inline: false}];
// The name of the remote write queue, it must be unique if specified. The
// name is used in metrics and logging in order to differentiate queues.
// Only valid in Prometheus versions 2.15.0 and newer.
optional string name = 2 [(dev.f110.kubeproto.field) = {go_name: "Name", api_field_name: "name", inline: false}];
// Enables sending of exemplars over remote write. Note that
// exemplar-storage itself must be enabled using the enableFeature option
// for exemplars to be scraped in the first place.  Only valid in
// Prometheus versions 2.27.0 and newer.
optional bool send_exemplars = 3 [(dev.f110.kubeproto.field) = {go_name: "SendExemplars", api_field_name: "sendExemplars", inline: false}];
// Timeout for requests to the remote write endpoint.
string remote_timeout = 4 [(dev.f110.kubeproto.field) = {go_name: "RemoteTimeout", api_field_name: "remoteTimeout", inline: false}];
// Custom HTTP headers to be sent along with each remote write request.
// Be aware that headers that are set by Prometheus itself can't be overwritten.
// Only valid in Prometheus versions 2.25.0 and newer.
map<string, string> headers = 5 [(dev.f110.kubeproto.field) = {go_name: "Headers", api_field_name: "headers", inline: false}];
// The list of remote write relabel configurations.
repeated RelabelConfig write_relabel_configs = 6 [(dev.f110.kubeproto.field) = {go_name: "WriteRelabelConfigs", api_field_name: "writeRelabelConfigs", inline: false}];
// OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
optional OAuth2 o_auth2 = 7 [(dev.f110.kubeproto.field) = {go_name: "OAuth2", api_field_name: "oauth2", inline: false}];
// BasicAuth for the URL.
optional BasicAuth basic_auth = 8 [(dev.f110.kubeproto.field) = {go_name: "BasicAuth", api_field_name: "basicAuth", inline: false}];
// Bearer token for remote write.
optional string bearer_token = 9 [(dev.f110.kubeproto.field) = {go_name: "BearerToken", api_field_name: "bearerToken", inline: false}];
// File to read bearer token for remote write.
optional string bearer_token_file = 10 [(dev.f110.kubeproto.field) = {go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false}];
// Authorization section for remote write
optional Authorization authorization = 11 [(dev.f110.kubeproto.field) = {go_name: "Authorization", api_field_name: "authorization", inline: false}];
// Sigv4 allows to configures AWS's Signature Verification 4
optional Sigv4 sigv4 = 12 [(dev.f110.kubeproto.field) = {go_name: "Sigv4", api_field_name: "sigv4", inline: false}];
// TLS Config to use for remote write.
optional TLSConfig tls_config = 13 [(dev.f110.kubeproto.field) = {go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false}];
// Optional ProxyURL.
optional string proxy_url = 14 [(dev.f110.kubeproto.field) = {go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false}];
// QueueConfig allows tuning of the remote write queue parameters.
optional QueueConfig queue_config = 15 [(dev.f110.kubeproto.field) = {go_name: "QueueConfig", api_field_name: "queueConfig", inline: false}];
// MetadataConfig configures the sending of series metadata to the remote storage.
optional MetadataConfig metadata_config = 16 [(dev.f110.kubeproto.field) = {go_name: "MetadataConfig", api_field_name: "metadataConfig", inline: false}];
}

message Rule {
optional string record = 1 [(dev.f110.kubeproto.field) = {go_name: "Record", api_field_name: "record", inline: false}];
optional string alert = 2 [(dev.f110.kubeproto.field) = {go_name: "Alert", api_field_name: "alert", inline: false}];
.k8s.io.apimachinery.pkg.util.intstr.IntOrString expr = 3 [(dev.f110.kubeproto.field) = {go_name: "Expr", api_field_name: "expr", inline: false}];
optional string for = 4 [(dev.f110.kubeproto.field) = {go_name: "For", api_field_name: "for", inline: false}];
map<string, string> labels = 5 [(dev.f110.kubeproto.field) = {go_name: "Labels", api_field_name: "labels", inline: false}];
map<string, string> annotations = 6 [(dev.f110.kubeproto.field) = {go_name: "Annotations", api_field_name: "annotations", inline: false}];
}

message RuleGroup {
string name = 1 [(dev.f110.kubeproto.field) = {go_name: "Name", api_field_name: "name", inline: false}];
optional string interval = 2 [(dev.f110.kubeproto.field) = {go_name: "Interval", api_field_name: "interval", inline: false}];
repeated Rule rules = 3 [(dev.f110.kubeproto.field) = {go_name: "Rules", api_field_name: "rules", inline: false}];
optional string partial_response_strategy = 4 [(dev.f110.kubeproto.field) = {go_name: "PartialResponseStrategy", api_field_name: "partial_response_strategy", inline: false}];
}

message Rules {
optional RulesAlert alert = 1 [(dev.f110.kubeproto.field) = {go_name: "Alert", api_field_name: "alert", inline: false}];
}

message RulesAlert {
// Max time to tolerate prometheus outage for restoring 'for' state of alert.
optional string for_outage_tolerance = 1 [(dev.f110.kubeproto.field) = {go_name: "ForOutageTolerance", api_field_name: "forOutageTolerance", inline: false}];
// Minimum duration between alert and restored 'for' state.
// This is maintained only for alerts with configured 'for' time greater than grace period.
optional string for_grace_period = 2 [(dev.f110.kubeproto.field) = {go_name: "ForGracePeriod", api_field_name: "forGracePeriod", inline: false}];
// Minimum amount of time to wait before resending an alert to Alertmanager.
optional string resend_delay = 3 [(dev.f110.kubeproto.field) = {go_name: "ResendDelay", api_field_name: "resendDelay", inline: false}];
}

message SafeAuthorization {
// Set the authentication type. Defaults to Bearer, Basic will cause an
// error
optional string type = 1 [(dev.f110.kubeproto.field) = {go_name: "Type", api_field_name: "type", inline: false}];
// The secret's key that contains the credentials of the request
optional .k8s.io.api.core.v1.SecretKeySelector credentials = 2 [(dev.f110.kubeproto.field) = {go_name: "Credentials", api_field_name: "credentials", inline: false}];
}

message SafeTLSConfig {
// Struct containing the CA cert to use for the targets.
optional SecretOrConfigMap c_a = 1 [(dev.f110.kubeproto.field) = {go_name: "CA", api_field_name: "ca", inline: false}];
// Struct containing the client cert file for the targets.
optional SecretOrConfigMap cert = 2 [(dev.f110.kubeproto.field) = {go_name: "Cert", api_field_name: "cert", inline: false}];
// Secret containing the client key file for the targets.
optional .k8s.io.api.core.v1.SecretKeySelector key_secret = 3 [(dev.f110.kubeproto.field) = {go_name: "KeySecret", api_field_name: "keySecret", inline: false}];
// Used to verify the hostname for the targets.
optional string server_name = 4 [(dev.f110.kubeproto.field) = {go_name: "ServerName", api_field_name: "serverName", inline: false}];
// Disable target certificate validation.
optional bool insecure_skip_verify = 5 [(dev.f110.kubeproto.field) = {go_name: "InsecureSkipVerify", api_field_name: "insecureSkipVerify", inline: false}];
}

message SecretOrConfigMap {
// Secret containing data to use for the targets.
optional .k8s.io.api.core.v1.SecretKeySelector secret = 1 [(dev.f110.kubeproto.field) = {go_name: "Secret", api_field_name: "secret", inline: false}];
// ConfigMap containing data to use for the targets.
optional .k8s.io.api.core.v1.ConfigMapKeySelector config_map = 2 [(dev.f110.kubeproto.field) = {go_name: "ConfigMap", api_field_name: "configMap", inline: false}];
}

message SecretOrConfigMapValidationError {
}

message ServiceMonitor {
// Specification of desired Service selection for target discovery by
// Prometheus.
ServiceMonitorSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];

option (dev.f110.kubeproto.kind) = {
};
}

message ServiceMonitorList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
// Standard list metadata
// More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
// List of ServiceMonitors
repeated ServiceMonitor items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message ServiceMonitorSpec {
// JobLabel selects the label from the associated Kubernetes service which will be used as the `job` label for all metrics.
// For example:
// If in `ServiceMonitor.spec.jobLabel: foo` and in `Service.metadata.labels.foo: bar`,
// then the `job="bar"` label is added to all metrics.
// If the value of this field is empty or if the label doesn't exist for the given Service, the `job` label of the metrics defaults to the name of the Kubernetes Service.
optional string job_label = 1 [(dev.f110.kubeproto.field) = {go_name: "JobLabel", api_field_name: "jobLabel", inline: false}];
// TargetLabels transfers labels from the Kubernetes `Service` onto the created metrics.
repeated string target_labels = 2 [(dev.f110.kubeproto.field) = {go_name: "TargetLabels", api_field_name: "targetLabels", inline: false}];
// PodTargetLabels transfers labels on the Kubernetes `Pod` onto the created metrics.
repeated string pod_target_labels = 3 [(dev.f110.kubeproto.field) = {go_name: "PodTargetLabels", api_field_name: "podTargetLabels", inline: false}];
// A list of endpoints allowed as part of this ServiceMonitor.
repeated Endpoint endpoints = 4 [(dev.f110.kubeproto.field) = {go_name: "Endpoints", api_field_name: "endpoints", inline: false}];
// Selector to select Endpoints objects.
.k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 5 [(dev.f110.kubeproto.field) = {go_name: "Selector", api_field_name: "selector", inline: false}];
// Selector to select which namespaces the Kubernetes Endpoints objects are discovered from.
optional NamespaceSelector namespace_selector = 6 [(dev.f110.kubeproto.field) = {go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false}];
// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
optional uint64 sample_limit = 7 [(dev.f110.kubeproto.field) = {go_name: "SampleLimit", api_field_name: "sampleLimit", inline: false}];
// TargetLimit defines a limit on the number of scraped targets that will be accepted.
optional uint64 target_limit = 8 [(dev.f110.kubeproto.field) = {go_name: "TargetLimit", api_field_name: "targetLimit", inline: false}];
// Per-scrape limit on number of labels that will be accepted for a sample.
// Only valid in Prometheus versions 2.27.0 and newer.
optional uint64 label_limit = 9 [(dev.f110.kubeproto.field) = {go_name: "LabelLimit", api_field_name: "labelLimit", inline: false}];
// Per-scrape limit on length of labels name that will be accepted for a sample.
// Only valid in Prometheus versions 2.27.0 and newer.
optional uint64 label_name_length_limit = 10 [(dev.f110.kubeproto.field) = {go_name: "LabelNameLengthLimit", api_field_name: "labelNameLengthLimit", inline: false}];
// Per-scrape limit on length of labels value that will be accepted for a sample.
// Only valid in Prometheus versions 2.27.0 and newer.
optional uint64 label_value_length_limit = 11 [(dev.f110.kubeproto.field) = {go_name: "LabelValueLengthLimit", api_field_name: "labelValueLengthLimit", inline: false}];
}

message ShardStatus {
// Identifier of the shard.
string shard_id = 1 [(dev.f110.kubeproto.field) = {go_name: "ShardID", api_field_name: "shardID", inline: false}];
// Total number of pods targeted by this shard.
int32 replicas = 2 [(dev.f110.kubeproto.field) = {go_name: "Replicas", api_field_name: "replicas", inline: false}];
// Total number of non-terminated pods targeted by this shard
// that have the desired spec.
int32 updated_replicas = 3 [(dev.f110.kubeproto.field) = {go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false}];
// Total number of available pods (ready for at least minReadySeconds)
// targeted by this shard.
int32 available_replicas = 4 [(dev.f110.kubeproto.field) = {go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false}];
// Total number of unavailable pods targeted by this shard.
int32 unavailable_replicas = 5 [(dev.f110.kubeproto.field) = {go_name: "UnavailableReplicas", api_field_name: "unavailableReplicas", inline: false}];
}

message Sigv4 {
// Region is the AWS region. If blank, the region from the default credentials chain used.
optional string region = 1 [(dev.f110.kubeproto.field) = {go_name: "Region", api_field_name: "region", inline: false}];
// AccessKey is the AWS API key. If blank, the environment variable `AWS_ACCESS_KEY_ID` is used.
optional .k8s.io.api.core.v1.SecretKeySelector access_key = 2 [(dev.f110.kubeproto.field) = {go_name: "AccessKey", api_field_name: "accessKey", inline: false}];
// SecretKey is the AWS API secret. If blank, the environment variable `AWS_SECRET_ACCESS_KEY` is used.
optional .k8s.io.api.core.v1.SecretKeySelector secret_key = 3 [(dev.f110.kubeproto.field) = {go_name: "SecretKey", api_field_name: "secretKey", inline: false}];
// Profile is the named AWS profile used to authenticate.
optional string profile = 4 [(dev.f110.kubeproto.field) = {go_name: "Profile", api_field_name: "profile", inline: false}];
// RoleArn is the named AWS profile used to authenticate.
optional string role_arn = 5 [(dev.f110.kubeproto.field) = {go_name: "RoleArn", api_field_name: "roleArn", inline: false}];
}

message StorageSpec {
// Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
// DisableMountSubPath allows to remove any subPath usage in volume mounts.
optional bool disable_mount_sub_path = 1 [(dev.f110.kubeproto.field) = {go_name: "DisableMountSubPath", api_field_name: "disableMountSubPath", inline: false}];
// EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
// info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
optional .k8s.io.api.core.v1.EmptyDirVolumeSource empty_dir = 2 [(dev.f110.kubeproto.field) = {go_name: "EmptyDir", api_field_name: "emptyDir", inline: false}];
// EphemeralVolumeSource to be used by the Prometheus StatefulSets.
// This is a beta field in k8s 1.21, for lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate.
// More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
optional .k8s.io.api.core.v1.EphemeralVolumeSource ephemeral = 3 [(dev.f110.kubeproto.field) = {go_name: "Ephemeral", api_field_name: "ephemeral", inline: false}];
// A PVC spec to be used by the Prometheus StatefulSets.
optional EmbeddedPersistentVolumeClaim volume_claim_template = 4 [(dev.f110.kubeproto.field) = {go_name: "VolumeClaimTemplate", api_field_name: "volumeClaimTemplate", inline: false}];
}

message TLSConfig {
SafeTLSConfig safe_tls_config = 1 [(dev.f110.kubeproto.field) = {go_name: "SafeTLSConfig", inline: true}];
// Path to the CA cert in the Prometheus container to use for the targets.
optional string c_a_file = 2 [(dev.f110.kubeproto.field) = {go_name: "CAFile", api_field_name: "caFile", inline: false}];
// Path to the client cert file in the Prometheus container for the targets.
optional string cert_file = 3 [(dev.f110.kubeproto.field) = {go_name: "CertFile", api_field_name: "certFile", inline: false}];
// Path to the client key file in the Prometheus container for the targets.
optional string key_file = 4 [(dev.f110.kubeproto.field) = {go_name: "KeyFile", api_field_name: "keyFile", inline: false}];
}

message TLSConfigValidationError {
}

message ThanosRuler {
// Specification of the desired behavior of the ThanosRuler cluster. More info:
// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
ThanosRulerSpec spec = 3 [(dev.f110.kubeproto.field) = {go_name: "Spec", api_field_name: "spec", inline: false}];
// Most recent observed status of the ThanosRuler cluster. Read-only. Not
// included when requesting from the apiserver, only from the ThanosRuler
// Operator API itself. More info:
// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
optional ThanosRulerStatus status = 4 [(dev.f110.kubeproto.field) = {go_name: "Status", api_field_name: "status", sub_resource: true, inline: false}];

option (dev.f110.kubeproto.kind) = {
};
}

message ThanosRulerList {
.k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = {go_name: "TypeMeta", inline: true}];
// Standard list metadata
// More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = {go_name: "ListMeta", api_field_name: "metadata", inline: false}];
// List of Prometheuses
repeated ThanosRuler items = 3 [(dev.f110.kubeproto.field) = {go_name: "Items", api_field_name: "items", inline: false}];
}

message ThanosRulerSpec {
// PodMetadata contains Labels and Annotations gets propagated to the thanos ruler pods.
optional EmbeddedObjectMetadata pod_metadata = 1 [(dev.f110.kubeproto.field) = {go_name: "PodMetadata", api_field_name: "podMetadata", inline: false}];
// Thanos container image URL.
optional string image = 2 [(dev.f110.kubeproto.field) = {go_name: "Image", api_field_name: "image", inline: false}];
// An optional list of references to secrets in the same namespace
// to use for pulling thanos images from registries
// see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
repeated .k8s.io.api.core.v1.LocalObjectReference image_pull_secrets = 3 [(dev.f110.kubeproto.field) = {go_name: "ImagePullSecrets", api_field_name: "imagePullSecrets", inline: false}];
// When a ThanosRuler deployment is paused, no actions except for deletion
// will be performed on the underlying objects.
optional bool paused = 4 [(dev.f110.kubeproto.field) = {go_name: "Paused", api_field_name: "paused", inline: false}];
// Number of thanos ruler instances to deploy.
optional int32 replicas = 5 [(dev.f110.kubeproto.field) = {go_name: "Replicas", api_field_name: "replicas", inline: false}];
// Define which Nodes the Pods are scheduled on.
map<string, string> node_selector = 6 [(dev.f110.kubeproto.field) = {go_name: "NodeSelector", api_field_name: "nodeSelector", inline: false}];
// Resources defines the resource requirements for single Pods.
// If not provided, no requests/limits will be set
optional .k8s.io.api.core.v1.ResourceRequirements resources = 7 [(dev.f110.kubeproto.field) = {go_name: "Resources", api_field_name: "resources", inline: false}];
// If specified, the pod's scheduling constraints.
optional .k8s.io.api.core.v1.Affinity affinity = 8 [(dev.f110.kubeproto.field) = {go_name: "Affinity", api_field_name: "affinity", inline: false}];
// If specified, the pod's tolerations.
repeated .k8s.io.api.core.v1.Toleration tolerations = 9 [(dev.f110.kubeproto.field) = {go_name: "Tolerations", api_field_name: "tolerations", inline: false}];
// If specified, the pod's topology spread constraints.
repeated .k8s.io.api.core.v1.TopologySpreadConstraint topology_spread_constraints = 10 [(dev.f110.kubeproto.field) = {go_name: "TopologySpreadConstraints", api_field_name: "topologySpreadConstraints", inline: false}];
// SecurityContext holds pod-level security attributes and common container settings.
// This defaults to the default PodSecurityContext.
optional .k8s.io.api.core.v1.PodSecurityContext security_context = 11 [(dev.f110.kubeproto.field) = {go_name: "SecurityContext", api_field_name: "securityContext", inline: false}];
// Priority class assigned to the Pods
optional string priority_class_name = 12 [(dev.f110.kubeproto.field) = {go_name: "PriorityClassName", api_field_name: "priorityClassName", inline: false}];
// ServiceAccountName is the name of the ServiceAccount to use to run the
// Thanos Ruler Pods.
optional string service_account_name = 13 [(dev.f110.kubeproto.field) = {go_name: "ServiceAccountName", api_field_name: "serviceAccountName", inline: false}];
// Storage spec to specify how storage shall be used.
optional StorageSpec storage = 14 [(dev.f110.kubeproto.field) = {go_name: "Storage", api_field_name: "storage", inline: false}];
// Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will
// be appended to other volumes that are generated as a result of StorageSpec objects.
repeated .k8s.io.api.core.v1.Volume volumes = 15 [(dev.f110.kubeproto.field) = {go_name: "Volumes", api_field_name: "volumes", inline: false}];
// ObjectStorageConfig configures object storage in Thanos.
// Alternative to ObjectStorageConfigFile, and lower order priority.
optional .k8s.io.api.core.v1.SecretKeySelector object_storage_config = 16 [(dev.f110.kubeproto.field) = {go_name: "ObjectStorageConfig", api_field_name: "objectStorageConfig", inline: false}];
// ObjectStorageConfigFile specifies the path of the object storage configuration file.
// When used alongside with ObjectStorageConfig, ObjectStorageConfigFile takes precedence.
optional string object_storage_config_file = 17 [(dev.f110.kubeproto.field) = {go_name: "ObjectStorageConfigFile", api_field_name: "objectStorageConfigFile", inline: false}];
// ListenLocal makes the Thanos ruler listen on loopback, so that it
// does not bind against the Pod IP.
optional bool listen_local = 18 [(dev.f110.kubeproto.field) = {go_name: "ListenLocal", api_field_name: "listenLocal", inline: false}];
// QueryEndpoints defines Thanos querier endpoints from which to query metrics.
// Maps to the --query flag of thanos ruler.
repeated string query_endpoints = 19 [(dev.f110.kubeproto.field) = {go_name: "QueryEndpoints", api_field_name: "queryEndpoints", inline: false}];
// Define configuration for connecting to thanos query instances.
// If this is defined, the QueryEndpoints field will be ignored.
// Maps to the `query.config` CLI argument.
// Only available with thanos v0.11.0 and higher.
optional .k8s.io.api.core.v1.SecretKeySelector query_config = 20 [(dev.f110.kubeproto.field) = {go_name: "QueryConfig", api_field_name: "queryConfig", inline: false}];
// Define URLs to send alerts to Alertmanager.  For Thanos v0.10.0 and higher,
// AlertManagersConfig should be used instead.  Note: this field will be ignored
// if AlertManagersConfig is specified.
// Maps to the `alertmanagers.url` arg.
repeated string alert_managers_url = 21 [(dev.f110.kubeproto.field) = {go_name: "AlertManagersURL", api_field_name: "alertmanagersUrl", inline: false}];
// Define configuration for connecting to alertmanager.  Only available with thanos v0.10.0
// and higher.  Maps to the `alertmanagers.config` arg.
optional .k8s.io.api.core.v1.SecretKeySelector alert_managers_config = 22 [(dev.f110.kubeproto.field) = {go_name: "AlertManagersConfig", api_field_name: "alertmanagersConfig", inline: false}];
// A label selector to select which PrometheusRules to mount for alerting and
// recording.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector rule_selector = 23 [(dev.f110.kubeproto.field) = {go_name: "RuleSelector", api_field_name: "ruleSelector", inline: false}];
// Namespaces to be selected for Rules discovery. If unspecified, only
// the same namespace as the ThanosRuler object is in is used.
optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector rule_namespace_selector = 24 [(dev.f110.kubeproto.field) = {go_name: "RuleNamespaceSelector", api_field_name: "ruleNamespaceSelector", inline: false}];
// EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert
// and metric that is user created. The label value will always be the namespace of the object that is
// being created.
optional string enforced_namespace_label = 25 [(dev.f110.kubeproto.field) = {go_name: "EnforcedNamespaceLabel", api_field_name: "enforcedNamespaceLabel", inline: false}];
// List of references to PrometheusRule objects
// to be excluded from enforcing a namespace label of origin.
// Applies only if enforcedNamespaceLabel set to true.
repeated ObjectReference excluded_from_enforcement = 26 [(dev.f110.kubeproto.field) = {go_name: "ExcludedFromEnforcement", api_field_name: "excludedFromEnforcement", inline: false}];
// PrometheusRulesExcludedFromEnforce - list of Prometheus rules to be excluded from enforcing
// of adding namespace labels. Works only if enforcedNamespaceLabel set to true.
// Make sure both ruleNamespace and ruleName are set for each pair
// Deprecated: use excludedFromEnforcement instead.
repeated PrometheusRuleExcludeConfig prometheus_rules_excluded_from_enforce = 27 [(dev.f110.kubeproto.field) = {go_name: "PrometheusRulesExcludedFromEnforce", api_field_name: "prometheusRulesExcludedFromEnforce", inline: false}];
// Log level for ThanosRuler to be configured with.
optional string log_level = 28 [(dev.f110.kubeproto.field) = {go_name: "LogLevel", api_field_name: "logLevel", inline: false}];
// Log format for ThanosRuler to be configured with.
optional string log_format = 29 [(dev.f110.kubeproto.field) = {go_name: "LogFormat", api_field_name: "logFormat", inline: false}];
// Port name used for the pods and governing service.
// This defaults to web
optional string port_name = 30 [(dev.f110.kubeproto.field) = {go_name: "PortName", api_field_name: "portName", inline: false}];
// Interval between consecutive evaluations.
string evaluation_interval = 31 [(dev.f110.kubeproto.field) = {go_name: "EvaluationInterval", api_field_name: "evaluationInterval", inline: false}];
// Time duration ThanosRuler shall retain data for. Default is '24h',
// and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)` (milliseconds seconds minutes hours days weeks years).
string retention = 32 [(dev.f110.kubeproto.field) = {go_name: "Retention", api_field_name: "retention", inline: false}];
// Containers allows injecting additional containers or modifying operator generated
// containers. This can be used to allow adding an authentication proxy to a ThanosRuler pod or
// to change the behavior of an operator generated container. Containers described here modify
// an operator generated container if they share the same name and modifications are done via a
// strategic merge patch. The current container names are: `thanos-ruler` and `config-reloader`.
// Overriding containers is entirely outside the scope of what the maintainers will support and by doing
// so, you accept that this behaviour may break at any time without notice.
repeated .k8s.io.api.core.v1.Container containers = 33 [(dev.f110.kubeproto.field) = {go_name: "Containers", api_field_name: "containers", inline: false}];
// InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
// fetch secrets for injection into the ThanosRuler configuration from external sources. Any
// errors during the execution of an initContainer will lead to a restart of the Pod.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
// Using initContainers for any use case other then secret fetching is entirely outside the scope
// of what the maintainers will support and by doing so, you accept that this behaviour may break
// at any time without notice.
repeated .k8s.io.api.core.v1.Container init_containers = 34 [(dev.f110.kubeproto.field) = {go_name: "InitContainers", api_field_name: "initContainers", inline: false}];
// TracingConfig configures tracing in Thanos. This is an experimental feature, it may change in any upcoming release in a breaking way.
optional .k8s.io.api.core.v1.SecretKeySelector tracing_config = 35 [(dev.f110.kubeproto.field) = {go_name: "TracingConfig", api_field_name: "tracingConfig", inline: false}];
// TracingConfig specifies the path of the tracing configuration file.
// When used alongside with TracingConfig, TracingConfigFile takes precedence.
optional string tracing_config_file = 36 [(dev.f110.kubeproto.field) = {go_name: "TracingConfigFile", api_field_name: "tracingConfigFile", inline: false}];
// Labels configure the external label pairs to ThanosRuler. A default replica label
// `thanos_ruler_replica` will be always added  as a label with the value of the pod's name and it will be dropped in the alerts.
map<string, string> labels = 37 [(dev.f110.kubeproto.field) = {go_name: "Labels", api_field_name: "labels", inline: false}];
// AlertDropLabels configure the label names which should be dropped in ThanosRuler alerts.
// The replica label `thanos_ruler_replica` will always be dropped in alerts.
repeated string alert_drop_labels = 38 [(dev.f110.kubeproto.field) = {go_name: "AlertDropLabels", api_field_name: "alertDropLabels", inline: false}];
// The external URL the Thanos Ruler instances will be available under. This is
// necessary to generate correct URLs. This is necessary if Thanos Ruler is not
// served from root of a DNS name.
optional string external_prefix = 39 [(dev.f110.kubeproto.field) = {go_name: "ExternalPrefix", api_field_name: "externalPrefix", inline: false}];
// The route prefix ThanosRuler registers HTTP handlers for. This allows thanos UI to be served on a sub-path.
optional string route_prefix = 40 [(dev.f110.kubeproto.field) = {go_name: "RoutePrefix", api_field_name: "routePrefix", inline: false}];
// GRPCServerTLSConfig configures the gRPC server from which Thanos Querier reads
// recorded rule data.
// Note: Currently only the CAFile, CertFile, and KeyFile fields are supported.
// Maps to the '--grpc-server-tls-*' CLI args.
optional TLSConfig grpc_tls_config_server = 41 [(dev.f110.kubeproto.field) = {go_name: "GRPCServerTLSConfig", api_field_name: "grpcServerTlsConfig", inline: false}];
// The external Query URL the Thanos Ruler will set in the 'Source' field
// of all alerts.
// Maps to the '--alert.query-url' CLI arg.
optional string alert_query_url = 42 [(dev.f110.kubeproto.field) = {go_name: "AlertQueryURL", api_field_name: "alertQueryUrl", inline: false}];
// Minimum number of seconds for which a newly created pod should be ready
// without any of its container crashing for it to be considered available.
// Defaults to 0 (pod will be considered available as soon as it is ready)
// This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
optional uint32 min_ready_seconds = 43 [(dev.f110.kubeproto.field) = {go_name: "MinReadySeconds", api_field_name: "minReadySeconds", inline: false}];
// AlertRelabelConfigs configures alert relabeling in ThanosRuler.
// Alert relabel configurations must have the form as specified in the official Prometheus documentation:
// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs
// Alternative to AlertRelabelConfigFile, and lower order priority.
optional .k8s.io.api.core.v1.SecretKeySelector alert_relabel_configs = 44 [(dev.f110.kubeproto.field) = {go_name: "AlertRelabelConfigs", api_field_name: "alertRelabelConfigs", inline: false}];
// AlertRelabelConfigFile specifies the path of the alert relabeling configuration file.
// When used alongside with AlertRelabelConfigs, alertRelabelConfigFile takes precedence.
optional string alert_relabel_config_file = 45 [(dev.f110.kubeproto.field) = {go_name: "AlertRelabelConfigFile", api_field_name: "alertRelabelConfigFile", inline: false}];
// Pods' hostAliases configuration
repeated HostAlias host_aliases = 46 [(dev.f110.kubeproto.field) = {go_name: "HostAliases", api_field_name: "hostAliases", inline: false}];
}

message ThanosRulerStatus {
// Represents whether any actions on the underlying managed objects are
// being performed. Only delete actions will be performed.
bool paused = 1 [(dev.f110.kubeproto.field) = {go_name: "Paused", api_field_name: "paused", inline: false}];
// Total number of non-terminated pods targeted by this ThanosRuler deployment
// (their labels match the selector).
int32 replicas = 2 [(dev.f110.kubeproto.field) = {go_name: "Replicas", api_field_name: "replicas", inline: false}];
// Total number of non-terminated pods targeted by this ThanosRuler deployment
// that have the desired version spec.
int32 updated_replicas = 3 [(dev.f110.kubeproto.field) = {go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false}];
// Total number of available pods (ready for at least minReadySeconds)
// targeted by this ThanosRuler deployment.
int32 available_replicas = 4 [(dev.f110.kubeproto.field) = {go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false}];
// Total number of unavailable pods targeted by this ThanosRuler deployment.
int32 unavailable_replicas = 5 [(dev.f110.kubeproto.field) = {go_name: "UnavailableReplicas", api_field_name: "unavailableReplicas", inline: false}];
}

message ThanosSpec {
// Image if specified has precedence over baseImage, tag and sha
// combinations. Specifying the version is still necessary to ensure the
// Prometheus Operator knows what version of Thanos is being
// configured.
optional string image = 1 [(dev.f110.kubeproto.field) = {go_name: "Image", api_field_name: "image", inline: false}];
// Version describes the version of Thanos to use.
optional string version = 2 [(dev.f110.kubeproto.field) = {go_name: "Version", api_field_name: "version", inline: false}];
// Tag of Thanos sidecar container image to be deployed. Defaults to the value of `version`.
// Version is ignored if Tag is set.
// Deprecated: use 'image' instead.  The image tag can be specified
// as part of the image URL.
optional string tag = 3 [(dev.f110.kubeproto.field) = {go_name: "Tag", api_field_name: "tag", inline: false}];
// SHA of Thanos container image to be deployed. Defaults to the value of `version`.
// Similar to a tag, but the SHA explicitly deploys an immutable container image.
// Version and Tag are ignored if SHA is set.
// Deprecated: use 'image' instead.  The image digest can be specified
// as part of the image URL.
optional string s_h_a = 4 [(dev.f110.kubeproto.field) = {go_name: "SHA", api_field_name: "sha", inline: false}];
// Thanos base image if other than default.
// Deprecated: use 'image' instead
optional string base_image = 5 [(dev.f110.kubeproto.field) = {go_name: "BaseImage", api_field_name: "baseImage", inline: false}];
// Resources defines the resource requirements for the Thanos sidecar.
// If not provided, no requests/limits will be set
optional .k8s.io.api.core.v1.ResourceRequirements resources = 6 [(dev.f110.kubeproto.field) = {go_name: "Resources", api_field_name: "resources", inline: false}];
// ObjectStorageConfig configures object storage in Thanos.
// Alternative to ObjectStorageConfigFile, and lower order priority.
optional .k8s.io.api.core.v1.SecretKeySelector object_storage_config = 7 [(dev.f110.kubeproto.field) = {go_name: "ObjectStorageConfig", api_field_name: "objectStorageConfig", inline: false}];
// ObjectStorageConfigFile specifies the path of the object storage configuration file.
// When used alongside with ObjectStorageConfig, ObjectStorageConfigFile takes precedence.
optional string object_storage_config_file = 8 [(dev.f110.kubeproto.field) = {go_name: "ObjectStorageConfigFile", api_field_name: "objectStorageConfigFile", inline: false}];
// ListenLocal makes the Thanos sidecar listen on loopback, so that it
// does not bind against the Pod IP.
optional bool listen_local = 9 [(dev.f110.kubeproto.field) = {go_name: "ListenLocal", api_field_name: "listenLocal", inline: false}];
// TracingConfig configures tracing in Thanos. This is an experimental feature, it may change in any upcoming release in a breaking way.
optional .k8s.io.api.core.v1.SecretKeySelector tracing_config = 10 [(dev.f110.kubeproto.field) = {go_name: "TracingConfig", api_field_name: "tracingConfig", inline: false}];
// TracingConfig specifies the path of the tracing configuration file.
// When used alongside with TracingConfig, TracingConfigFile takes precedence.
optional string tracing_config_file = 11 [(dev.f110.kubeproto.field) = {go_name: "TracingConfigFile", api_field_name: "tracingConfigFile", inline: false}];
// GRPCServerTLSConfig configures the gRPC server from which Thanos Querier reads
// recorded rule data.
// Note: Currently only the CAFile, CertFile, and KeyFile fields are supported.
// Maps to the '--grpc-server-tls-*' CLI args.
optional TLSConfig grpc_tls_config_server = 12 [(dev.f110.kubeproto.field) = {go_name: "GRPCServerTLSConfig", api_field_name: "grpcServerTlsConfig", inline: false}];
// LogLevel for Thanos sidecar to be configured with.
optional string log_level = 13 [(dev.f110.kubeproto.field) = {go_name: "LogLevel", api_field_name: "logLevel", inline: false}];
// LogFormat for Thanos sidecar to be configured with.
optional string log_format = 14 [(dev.f110.kubeproto.field) = {go_name: "LogFormat", api_field_name: "logFormat", inline: false}];
// MinTime for Thanos sidecar to be configured with. Option can be a constant time in RFC3339 format or time duration relative to current time, such as -1d or 2h45m. Valid duration units are ms, s, m, h, d, w, y.
optional string min_time = 15 [(dev.f110.kubeproto.field) = {go_name: "MinTime", api_field_name: "minTime", inline: false}];
// ReadyTimeout is the maximum time Thanos sidecar will wait for Prometheus to start. Eg 10m
string ready_timeout = 16 [(dev.f110.kubeproto.field) = {go_name: "ReadyTimeout", api_field_name: "readyTimeout", inline: false}];
// VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
// VolumeMounts specified will be appended to other VolumeMounts in the thanos-sidecar container.
repeated .k8s.io.api.core.v1.VolumeMount volume_mounts = 17 [(dev.f110.kubeproto.field) = {go_name: "VolumeMounts", api_field_name: "volumeMounts", inline: false}];
// AdditionalArgs allows setting additional arguments for the Thanos container.
// The arguments are passed as-is to the Thanos container which may cause issues
// if they are invalid or not supporeted the given Thanos version.
// In case of an argument conflict (e.g. an argument which is already set by the
// operator itself) or when providing an invalid argument the reconciliation will
// fail and an error will be logged.
repeated Argument additional_args = 18 [(dev.f110.kubeproto.field) = {go_name: "AdditionalArgs", api_field_name: "additionalArgs", inline: false}];
}

message WebConfigFileFields {
// Defines the TLS parameters for HTTPS.
optional WebTLSConfig tls_config = 1 [(dev.f110.kubeproto.field) = {go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false}];
// Defines HTTP parameters for web server.
optional WebHTTPConfig http_config = 2 [(dev.f110.kubeproto.field) = {go_name: "HTTPConfig", api_field_name: "httpConfig", inline: false}];
}

message WebHTTPConfig {
// Enable HTTP/2 support. Note that HTTP/2 is only supported with TLS.
// When TLSConfig is not configured, HTTP/2 will be disabled.
// Whenever the value of the field changes, a rolling update will be triggered.
optional bool http_2 = 1 [(dev.f110.kubeproto.field) = {go_name: "HTTP2", api_field_name: "http2", inline: false}];
// List of headers that can be added to HTTP responses.
optional WebHTTPHeaders headers = 2 [(dev.f110.kubeproto.field) = {go_name: "Headers", api_field_name: "headers", inline: false}];
}

message WebHTTPHeaders {
// Set the Content-Security-Policy header to HTTP responses.
// Unset if blank.
optional string content_security_policy = 1 [(dev.f110.kubeproto.field) = {go_name: "ContentSecurityPolicy", api_field_name: "contentSecurityPolicy", inline: false}];
// Set the X-Frame-Options header to HTTP responses.
// Unset if blank. Accepted values are deny and sameorigin.
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
optional string x_frame_options = 2 [(dev.f110.kubeproto.field) = {go_name: "XFrameOptions", api_field_name: "xFrameOptions", inline: false}];
// Set the X-Content-Type-Options header to HTTP responses.
// Unset if blank. Accepted value is nosniff.
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
optional string x_content_type_options = 3 [(dev.f110.kubeproto.field) = {go_name: "XContentTypeOptions", api_field_name: "xContentTypeOptions", inline: false}];
// Set the X-XSS-Protection header to all responses.
// Unset if blank.
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
optional string x_x_s_s_protection = 4 [(dev.f110.kubeproto.field) = {go_name: "XXSSProtection", api_field_name: "xXSSProtection", inline: false}];
// Set the Strict-Transport-Security header to HTTP responses.
// Unset if blank.
// Please make sure that you use this with care as this header might force
// browsers to load Prometheus and the other applications hosted on the same
// domain and subdomains over HTTPS.
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
optional string strict_transport_security = 5 [(dev.f110.kubeproto.field) = {go_name: "StrictTransportSecurity", api_field_name: "strictTransportSecurity", inline: false}];
}

message WebTLSConfig {
// Secret containing the TLS key for the server.
.k8s.io.api.core.v1.SecretKeySelector key_secret = 1 [(dev.f110.kubeproto.field) = {go_name: "KeySecret", api_field_name: "keySecret", inline: false}];
// Contains the TLS certificate for the server.
SecretOrConfigMap cert = 2 [(dev.f110.kubeproto.field) = {go_name: "Cert", api_field_name: "cert", inline: false}];
// Server policy for client authentication. Maps to ClientAuth Policies.
// For more detail on clientAuth options:
// https://golang.org/pkg/crypto/tls/#ClientAuthType
optional string client_auth_type = 3 [(dev.f110.kubeproto.field) = {go_name: "ClientAuthType", api_field_name: "clientAuthType", inline: false}];
// Contains the CA certificate for client certificate authentication to the server.
optional SecretOrConfigMap client_c_a = 4 [(dev.f110.kubeproto.field) = {go_name: "ClientCA", api_field_name: "client_ca", inline: false}];
// Minimum TLS version that is acceptable. Defaults to TLS12.
optional string min_version = 5 [(dev.f110.kubeproto.field) = {go_name: "MinVersion", api_field_name: "minVersion", inline: false}];
// Maximum TLS version that is acceptable. Defaults to TLS13.
optional string max_version = 6 [(dev.f110.kubeproto.field) = {go_name: "MaxVersion", api_field_name: "maxVersion", inline: false}];
// List of supported cipher suites for TLS versions up to TLS 1.2. If empty,
// Go default cipher suites are used. Available cipher suites are documented
// in the go documentation: https://golang.org/pkg/crypto/tls/#pkg-constants
repeated string cipher_suites = 7 [(dev.f110.kubeproto.field) = {go_name: "CipherSuites", api_field_name: "cipherSuites", inline: false}];
// Controls whether the server selects the
// client's most preferred cipher suite, or the server's most preferred
// cipher suite. If true then the server's preference, as expressed in
// the order of elements in cipherSuites, is used.
optional bool prefer_server_cipher_suites = 8 [(dev.f110.kubeproto.field) = {go_name: "PreferServerCipherSuites", api_field_name: "preferServerCipherSuites", inline: false}];
// Elliptic curves that will be used in an ECDHE handshake, in preference
// order. Available curves are documented in the go documentation:
// https://golang.org/pkg/crypto/tls/#CurveID
repeated string curve_preferences = 9 [(dev.f110.kubeproto.field) = {go_name: "CurvePreferences", api_field_name: "curvePreferences", inline: false}];
}

message WebTLSConfigError {
}

