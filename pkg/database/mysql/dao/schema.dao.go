// Generated by protoc-ddl.
// protoc-gen-dao: v0.1
package dao

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"golang.org/x/xerrors"

	"go.f110.dev/heimdallr/pkg/database/mysql/entity"
)

type ListOption func(opt *listOpt)

func Limit(limit int) func(opt *listOpt) {
	return func(opt *listOpt) {
		opt.limit = limit
	}
}

func Desc(opt *listOpt) {
	opt.desc = true
}

type listOpt struct {
	limit int
	desc  bool
}

func newListOpt(opts ...ListOption) *listOpt {
	opt := &listOpt{}
	for _, v := range opts {
		v(opt)
	}
	return opt
}

type ExecOption func(opt *execOpt)

func WithTx(tx *sql.Tx) ExecOption {
	return func(opt *execOpt) {
		opt.tx = tx
	}
}

type execOpt struct {
	tx *sql.Tx
}

func newExecOpt(opts ...ExecOption) *execOpt {
	opt := &execOpt{}
	for _, v := range opts {
		v(opt)
	}
	return opt
}

type execConn interface {
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
}

type User struct {
	conn *sql.DB
}

type UserInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*entity.User, error)
	SelectIdentity(ctx context.Context, identity string) (*entity.User, error)
	ListIdentityByLoginName(ctx context.Context, loginName string, opt ...ListOption) ([]*entity.User, error)
	ListAll(ctx context.Context, opt ...ListOption) ([]*entity.User, error)
	Create(ctx context.Context, user *entity.User, opt ...ExecOption) (*entity.User, error)
	Update(ctx context.Context, user *entity.User, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ UserInterface = &User{}

func NewUser(conn *sql.DB) *User {
	return &User{
		conn: conn,
	}
}

func (d *User) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *User) Select(ctx context.Context, id int32) (*entity.User, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `user` WHERE `id` = ?", id)

	v := &entity.User{}
	if err := row.Scan(&v.Id, &v.Identity, &v.LoginName, &v.Admin, &v.Type, &v.Comment, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil

}

func (d *User) SelectIdentity(ctx context.Context, identity string) (*entity.User, error) {
	row := d.conn.QueryRowContext(
		ctx,
		"SELECT `id`, `identity`, `login_name`, `admin`, `type`, `comment`, `created_at`, `updated_at` FROM `user` WHERE `identity` = ?",
		identity,
	)
	v := &entity.User{}
	if err := row.Scan(&v.Id, &v.Identity, &v.LoginName, &v.Admin, &v.Type, &v.Comment, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil

}

func (d *User) ListIdentityByLoginName(ctx context.Context, loginName string, opt ...ListOption) ([]*entity.User, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `identity` FROM `user` WHERE `login_name` = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		loginName,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.User, 0)
	for rows.Next() {
		r := &entity.User{}
		if err := rows.Scan(&r.Identity); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil

}

func (d *User) ListAll(ctx context.Context, opt ...ListOption) ([]*entity.User, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `identity`, `login_name`, `admin`, `type`, `comment`, `created_at`, `updated_at` FROM `user`"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.User, 0)
	for rows.Next() {
		r := &entity.User{}
		if err := rows.Scan(&r.Id, &r.Identity, &r.LoginName, &r.Admin, &r.Type, &r.Comment, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil

}

func (d *User) Create(ctx context.Context, user *entity.User, opt ...ExecOption) (*entity.User, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `user` (`identity`, `login_name`, `admin`, `type`, `comment`, `created_at`) VALUES (?, ?, ?, ?, ?, ?)",
		user.Identity, user.LoginName, user.Admin, user.Type, user.Comment, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	user = user.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	user.Id = int32(insertedId)

	user.ResetMark()
	return user, nil

}

func (d *User) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `user` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *User) Update(ctx context.Context, user *entity.User, opt ...ExecOption) error {
	if !user.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := user.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `user` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, user.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	user.ResetMark()
	return nil

}

type UserState struct {
	conn *sql.DB
}

type UserStateInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*entity.UserState, error)
	SelectState(ctx context.Context, state string) (*entity.UserState, error)
	Create(ctx context.Context, userState *entity.UserState, opt ...ExecOption) (*entity.UserState, error)
	Update(ctx context.Context, userState *entity.UserState, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ UserStateInterface = &UserState{}

func NewUserState(conn *sql.DB) *UserState {
	return &UserState{
		conn: conn,
	}
}

func (d *UserState) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *UserState) Select(ctx context.Context, id int32) (*entity.UserState, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `user_state` WHERE `id` = ?", id)

	v := &entity.UserState{}
	if err := row.Scan(&v.Id, &v.State, &v.Unique, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil

}

func (d *UserState) SelectState(ctx context.Context, state string) (*entity.UserState, error) {
	row := d.conn.QueryRowContext(
		ctx,
		"SELECT `id`, `state`, `unique`, `created_at`, `updated_at` FROM `user_state` WHERE `state` = ?",
		state,
	)
	v := &entity.UserState{}
	if err := row.Scan(&v.Id, &v.State, &v.Unique, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil

}

func (d *UserState) Create(ctx context.Context, userState *entity.UserState, opt ...ExecOption) (*entity.UserState, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `user_state` (`state`, `unique`, `created_at`) VALUES (?, ?, ?)",
		userState.State, userState.Unique, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	userState = userState.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	userState.Id = int32(insertedId)

	userState.ResetMark()
	return userState, nil

}

func (d *UserState) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `user_state` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *UserState) Update(ctx context.Context, userState *entity.UserState, opt ...ExecOption) error {
	if !userState.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := userState.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `user_state` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, userState.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	userState.ResetMark()
	return nil

}

type SSHKey struct {
	conn *sql.DB

	user *User
}

type SSHKeyInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, userId int32) (*entity.SSHKey, error)
	Create(ctx context.Context, sSHKey *entity.SSHKey, opt ...ExecOption) (*entity.SSHKey, error)
	Update(ctx context.Context, sSHKey *entity.SSHKey, opt ...ExecOption) error
	Delete(ctx context.Context, userId int32, opt ...ExecOption) error
}

var _ SSHKeyInterface = &SSHKey{}

func NewSSHKey(conn *sql.DB) *SSHKey {
	return &SSHKey{
		conn: conn,
		user: NewUser(conn),
	}
}

func (d *SSHKey) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *SSHKey) Select(ctx context.Context, userId int32) (*entity.SSHKey, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `ssh_key` WHERE `user_id` = ?", userId)

	v := &entity.SSHKey{}
	if err := row.Scan(&v.UserId, &v.Key, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.user.Select(ctx, v.UserId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.User = rel
	}

	v.ResetMark()
	return v, nil

}

func (d *SSHKey) Create(ctx context.Context, sSHKey *entity.SSHKey, opt ...ExecOption) (*entity.SSHKey, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `ssh_key` (`user_id`, `key`, `created_at`) VALUES (?, ?, ?)",
		sSHKey.UserId, sSHKey.Key, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	sSHKey = sSHKey.Copy()

	sSHKey.ResetMark()
	return sSHKey, nil

}

func (d *SSHKey) Delete(ctx context.Context, userId int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `ssh_key` WHERE `user_id` = ?", userId)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *SSHKey) Update(ctx context.Context, sSHKey *entity.SSHKey, opt ...ExecOption) error {
	if !sSHKey.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := sSHKey.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `ssh_key` SET %s WHERE `user_id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, sSHKey.UserId)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	sSHKey.ResetMark()
	return nil

}

type GPGKey struct {
	conn *sql.DB

	user *User
}

type GPGKeyInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, userId int32) (*entity.GPGKey, error)
	Create(ctx context.Context, gPGKey *entity.GPGKey, opt ...ExecOption) (*entity.GPGKey, error)
	Update(ctx context.Context, gPGKey *entity.GPGKey, opt ...ExecOption) error
	Delete(ctx context.Context, userId int32, opt ...ExecOption) error
}

var _ GPGKeyInterface = &GPGKey{}

func NewGPGKey(conn *sql.DB) *GPGKey {
	return &GPGKey{
		conn: conn,
		user: NewUser(conn),
	}
}

func (d *GPGKey) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *GPGKey) Select(ctx context.Context, userId int32) (*entity.GPGKey, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `gpg_key` WHERE `user_id` = ?", userId)

	v := &entity.GPGKey{}
	if err := row.Scan(&v.UserId, &v.Key, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.user.Select(ctx, v.UserId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.User = rel
	}

	v.ResetMark()
	return v, nil

}

func (d *GPGKey) Create(ctx context.Context, gPGKey *entity.GPGKey, opt ...ExecOption) (*entity.GPGKey, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `gpg_key` (`user_id`, `key`, `created_at`) VALUES (?, ?, ?)",
		gPGKey.UserId, gPGKey.Key, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	gPGKey = gPGKey.Copy()

	gPGKey.ResetMark()
	return gPGKey, nil

}

func (d *GPGKey) Delete(ctx context.Context, userId int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `gpg_key` WHERE `user_id` = ?", userId)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *GPGKey) Update(ctx context.Context, gPGKey *entity.GPGKey, opt ...ExecOption) error {
	if !gPGKey.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := gPGKey.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `gpg_key` SET %s WHERE `user_id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, gPGKey.UserId)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	gPGKey.ResetMark()
	return nil

}

type RoleBinding struct {
	conn *sql.DB

	user *User
}

type RoleBindingInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*entity.RoleBinding, error)
	ListUser(ctx context.Context, userId int32, opt ...ListOption) ([]*entity.RoleBinding, error)
	ListAll(ctx context.Context, opt ...ListOption) ([]*entity.RoleBinding, error)
	SelectUserRole(ctx context.Context, userId int32, role string) (*entity.RoleBinding, error)
	Create(ctx context.Context, roleBinding *entity.RoleBinding, opt ...ExecOption) (*entity.RoleBinding, error)
	Update(ctx context.Context, roleBinding *entity.RoleBinding, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ RoleBindingInterface = &RoleBinding{}

func NewRoleBinding(conn *sql.DB) *RoleBinding {
	return &RoleBinding{
		conn: conn,
		user: NewUser(conn),
	}
}

func (d *RoleBinding) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *RoleBinding) Select(ctx context.Context, id int32) (*entity.RoleBinding, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `role_binding` WHERE `id` = ?", id)

	v := &entity.RoleBinding{}
	if err := row.Scan(&v.Id, &v.UserId, &v.Role, &v.Maintainer, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.user.Select(ctx, v.UserId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.User = rel
	}

	v.ResetMark()
	return v, nil

}

func (d *RoleBinding) ListUser(ctx context.Context, userId int32, opt ...ListOption) ([]*entity.RoleBinding, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `user_id`, `role`, `maintainer`, `created_at`, `updated_at` FROM `role_binding` WHERE `user_id` = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		userId,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.RoleBinding, 0)
	for rows.Next() {
		r := &entity.RoleBinding{}
		if err := rows.Scan(&r.Id, &r.UserId, &r.Role, &r.Maintainer, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.user.Select(ctx, v.UserId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.User = rel
			}

		}
	}

	return res, nil

}

func (d *RoleBinding) ListAll(ctx context.Context, opt ...ListOption) ([]*entity.RoleBinding, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `user_id`, `role`, `maintainer`, `created_at`, `updated_at` FROM `role_binding`"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.RoleBinding, 0)
	for rows.Next() {
		r := &entity.RoleBinding{}
		if err := rows.Scan(&r.Id, &r.UserId, &r.Role, &r.Maintainer, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.user.Select(ctx, v.UserId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.User = rel
			}

		}
	}

	return res, nil

}

func (d *RoleBinding) SelectUserRole(ctx context.Context, userId int32, role string) (*entity.RoleBinding, error) {
	row := d.conn.QueryRowContext(
		ctx,
		"SELECT `id`, `user_id`, `role`, `maintainer`, `created_at`, `updated_at` FROM `role_binding` WHERE `user_id` = ? AND `role` = ?",
		userId,
		role,
	)
	v := &entity.RoleBinding{}
	if err := row.Scan(&v.Id, &v.UserId, &v.Role, &v.Maintainer, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.user.Select(ctx, v.UserId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.User = rel
	}

	v.ResetMark()
	return v, nil

}

func (d *RoleBinding) Create(ctx context.Context, roleBinding *entity.RoleBinding, opt ...ExecOption) (*entity.RoleBinding, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `role_binding` (`user_id`, `role`, `maintainer`, `created_at`) VALUES (?, ?, ?, ?)",
		roleBinding.UserId, roleBinding.Role, roleBinding.Maintainer, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	roleBinding = roleBinding.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	roleBinding.Id = int32(insertedId)

	roleBinding.ResetMark()
	return roleBinding, nil

}

func (d *RoleBinding) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `role_binding` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *RoleBinding) Update(ctx context.Context, roleBinding *entity.RoleBinding, opt ...ExecOption) error {
	if !roleBinding.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := roleBinding.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `role_binding` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, roleBinding.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	roleBinding.ResetMark()
	return nil

}

type AccessToken struct {
	conn *sql.DB

	user *User
}

type AccessTokenInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*entity.AccessToken, error)
	SelectAccessToken(ctx context.Context, value string) (*entity.AccessToken, error)
	ListByUser(ctx context.Context, userId int32, opt ...ListOption) ([]*entity.AccessToken, error)
	Create(ctx context.Context, accessToken *entity.AccessToken, opt ...ExecOption) (*entity.AccessToken, error)
	Update(ctx context.Context, accessToken *entity.AccessToken, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ AccessTokenInterface = &AccessToken{}

func NewAccessToken(conn *sql.DB) *AccessToken {
	return &AccessToken{
		conn: conn,
		user: NewUser(conn),
	}
}

func (d *AccessToken) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *AccessToken) Select(ctx context.Context, id int32) (*entity.AccessToken, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `access_token` WHERE `id` = ?", id)

	v := &entity.AccessToken{}
	if err := row.Scan(&v.Id, &v.Name, &v.Value, &v.UserId, &v.IssuerId, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.user.Select(ctx, v.IssuerId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.Issuer = rel
	}
	{
		rel, err := d.user.Select(ctx, v.UserId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.User = rel
	}

	v.ResetMark()
	return v, nil

}

func (d *AccessToken) SelectAccessToken(ctx context.Context, value string) (*entity.AccessToken, error) {
	row := d.conn.QueryRowContext(
		ctx,
		"SELECT `id`, `name`, `value`, `user_id`, `issuer_id`, `created_at`, `updated_at` FROM `access_token` WHERE `value` = ?",
		value,
	)
	v := &entity.AccessToken{}
	if err := row.Scan(&v.Id, &v.Name, &v.Value, &v.UserId, &v.IssuerId, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.user.Select(ctx, v.IssuerId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.Issuer = rel
	}
	{
		rel, err := d.user.Select(ctx, v.UserId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.User = rel
	}

	v.ResetMark()
	return v, nil

}

func (d *AccessToken) ListByUser(ctx context.Context, userId int32, opt ...ListOption) ([]*entity.AccessToken, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `name`, `value`, `user_id`, `issuer_id`, `created_at`, `updated_at` FROM `access_token` WHERE `user_id` = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		userId,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.AccessToken, 0)
	for rows.Next() {
		r := &entity.AccessToken{}
		if err := rows.Scan(&r.Id, &r.Name, &r.Value, &r.UserId, &r.IssuerId, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.user.Select(ctx, v.IssuerId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.Issuer = rel
			}
			{
				rel, err := d.user.Select(ctx, v.UserId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.User = rel
			}

		}
	}

	return res, nil

}

func (d *AccessToken) Create(ctx context.Context, accessToken *entity.AccessToken, opt ...ExecOption) (*entity.AccessToken, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `access_token` (`name`, `value`, `user_id`, `issuer_id`, `created_at`) VALUES (?, ?, ?, ?, ?)",
		accessToken.Name, accessToken.Value, accessToken.UserId, accessToken.IssuerId, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	accessToken = accessToken.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	accessToken.Id = int32(insertedId)

	accessToken.ResetMark()
	return accessToken, nil

}

func (d *AccessToken) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `access_token` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *AccessToken) Update(ctx context.Context, accessToken *entity.AccessToken, opt ...ExecOption) error {
	if !accessToken.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := accessToken.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `access_token` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, accessToken.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	accessToken.ResetMark()
	return nil

}

type Token struct {
	conn *sql.DB

	user *User
}

type TokenInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*entity.Token, error)
	ListAll(ctx context.Context, opt ...ListOption) ([]*entity.Token, error)
	ListToken(ctx context.Context, token string, opt ...ListOption) ([]*entity.Token, error)
	Create(ctx context.Context, token *entity.Token, opt ...ExecOption) (*entity.Token, error)
	Update(ctx context.Context, token *entity.Token, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ TokenInterface = &Token{}

func NewToken(conn *sql.DB) *Token {
	return &Token{
		conn: conn,
		user: NewUser(conn),
	}
}

func (d *Token) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *Token) Select(ctx context.Context, id int32) (*entity.Token, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `token` WHERE `id` = ?", id)

	v := &entity.Token{}
	if err := row.Scan(&v.Id, &v.Token, &v.UserId, &v.IssuedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.user.Select(ctx, v.UserId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.User = rel
	}

	v.ResetMark()
	return v, nil

}

func (d *Token) ListAll(ctx context.Context, opt ...ListOption) ([]*entity.Token, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `token`, `user_id`, `issued_at` FROM `token`"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.Token, 0)
	for rows.Next() {
		r := &entity.Token{}
		if err := rows.Scan(&r.Id, &r.Token, &r.UserId, &r.IssuedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.user.Select(ctx, v.UserId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.User = rel
			}

		}
	}

	return res, nil

}

func (d *Token) ListToken(ctx context.Context, token string, opt ...ListOption) ([]*entity.Token, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `token`, `user_id`, `issued_at` FROM `token` WHERE `token` = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		token,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.Token, 0)
	for rows.Next() {
		r := &entity.Token{}
		if err := rows.Scan(&r.Id, &r.Token, &r.UserId, &r.IssuedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.user.Select(ctx, v.UserId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.User = rel
			}

		}
	}

	return res, nil

}

func (d *Token) Create(ctx context.Context, token *entity.Token, opt ...ExecOption) (*entity.Token, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `token` (`token`, `user_id`, `issued_at`) VALUES (?, ?, ?)",
		token.Token, token.UserId, token.IssuedAt,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	token = token.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	token.Id = int32(insertedId)

	token.ResetMark()
	return token, nil

}

func (d *Token) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `token` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *Token) Update(ctx context.Context, token *entity.Token, opt ...ExecOption) error {
	if !token.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := token.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}

	query := fmt.Sprintf("UPDATE `token` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, token.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	token.ResetMark()
	return nil

}

type Code struct {
	conn *sql.DB

	user *User
}

type CodeInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*entity.Code, error)
	SelectCode(ctx context.Context, code string) (*entity.Code, error)
	ListAll(ctx context.Context, opt ...ListOption) ([]*entity.Code, error)
	Create(ctx context.Context, code *entity.Code, opt ...ExecOption) (*entity.Code, error)
	Update(ctx context.Context, code *entity.Code, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ CodeInterface = &Code{}

func NewCode(conn *sql.DB) *Code {
	return &Code{
		conn: conn,
		user: NewUser(conn),
	}
}

func (d *Code) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *Code) Select(ctx context.Context, id int32) (*entity.Code, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `code` WHERE `id` = ?", id)

	v := &entity.Code{}
	if err := row.Scan(&v.Id, &v.Code, &v.Challenge, &v.ChallengeMethod, &v.UserId, &v.IssuedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.user.Select(ctx, v.UserId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.User = rel
	}

	v.ResetMark()
	return v, nil

}

func (d *Code) SelectCode(ctx context.Context, code string) (*entity.Code, error) {
	row := d.conn.QueryRowContext(
		ctx,
		"SELECT `id`, `code`, `challenge`, `challenge_method`, `user_id`, `issued_at` FROM `code` WHERE `code` = ?",
		code,
	)
	v := &entity.Code{}
	if err := row.Scan(&v.Id, &v.Code, &v.Challenge, &v.ChallengeMethod, &v.UserId, &v.IssuedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.user.Select(ctx, v.UserId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.User = rel
	}

	v.ResetMark()
	return v, nil

}

func (d *Code) ListAll(ctx context.Context, opt ...ListOption) ([]*entity.Code, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `code`, `challenge`, `challenge_method`, `user_id`, `issued_at` FROM `code`"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.Code, 0)
	for rows.Next() {
		r := &entity.Code{}
		if err := rows.Scan(&r.Id, &r.Code, &r.Challenge, &r.ChallengeMethod, &r.UserId, &r.IssuedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.user.Select(ctx, v.UserId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.User = rel
			}

		}
	}

	return res, nil

}

func (d *Code) Create(ctx context.Context, code *entity.Code, opt ...ExecOption) (*entity.Code, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `code` (`code`, `challenge`, `challenge_method`, `user_id`, `issued_at`) VALUES (?, ?, ?, ?, ?)",
		code.Code, code.Challenge, code.ChallengeMethod, code.UserId, code.IssuedAt,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	code = code.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	code.Id = int32(insertedId)

	code.ResetMark()
	return code, nil

}

func (d *Code) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `code` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *Code) Update(ctx context.Context, code *entity.Code, opt ...ExecOption) error {
	if !code.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := code.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}

	query := fmt.Sprintf("UPDATE `code` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, code.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	code.ResetMark()
	return nil

}

type Relay struct {
	conn *sql.DB
}

type RelayInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*entity.Relay, error)
	ListName(ctx context.Context, name string, opt ...ListOption) ([]*entity.Relay, error)
	SelectEndpoint(ctx context.Context, name string, addr string) (*entity.Relay, error)
	ListAll(ctx context.Context, opt ...ListOption) ([]*entity.Relay, error)
	Create(ctx context.Context, relay *entity.Relay, opt ...ExecOption) (*entity.Relay, error)
	Update(ctx context.Context, relay *entity.Relay, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ RelayInterface = &Relay{}

func NewRelay(conn *sql.DB) *Relay {
	return &Relay{
		conn: conn,
	}
}

func (d *Relay) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *Relay) Select(ctx context.Context, id int32) (*entity.Relay, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `relay` WHERE `id` = ?", id)

	v := &entity.Relay{}
	if err := row.Scan(&v.Id, &v.Name, &v.Addr, &v.FromAddr, &v.ConnectedAt, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil

}

func (d *Relay) ListName(ctx context.Context, name string, opt ...ListOption) ([]*entity.Relay, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `name`, `addr`, `from_addr`, `connected_at`, `created_at`, `updated_at` FROM `relay` WHERE `name` = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		name,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.Relay, 0)
	for rows.Next() {
		r := &entity.Relay{}
		if err := rows.Scan(&r.Id, &r.Name, &r.Addr, &r.FromAddr, &r.ConnectedAt, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil

}

func (d *Relay) SelectEndpoint(ctx context.Context, name string, addr string) (*entity.Relay, error) {
	row := d.conn.QueryRowContext(
		ctx,
		"SELECT `id`, `name`, `addr`, `from_addr`, `connected_at`, `created_at`, `updated_at` FROM `relay` WHERE `name` = ? AND `addr` = ?",
		name,
		addr,
	)
	v := &entity.Relay{}
	if err := row.Scan(&v.Id, &v.Name, &v.Addr, &v.FromAddr, &v.ConnectedAt, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil

}

func (d *Relay) ListAll(ctx context.Context, opt ...ListOption) ([]*entity.Relay, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `name`, `addr`, `from_addr`, `connected_at`, `created_at`, `updated_at` FROM `relay`"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.Relay, 0)
	for rows.Next() {
		r := &entity.Relay{}
		if err := rows.Scan(&r.Id, &r.Name, &r.Addr, &r.FromAddr, &r.ConnectedAt, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil

}

func (d *Relay) Create(ctx context.Context, relay *entity.Relay, opt ...ExecOption) (*entity.Relay, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `relay` (`name`, `addr`, `from_addr`, `connected_at`, `created_at`) VALUES (?, ?, ?, ?, ?)",
		relay.Name, relay.Addr, relay.FromAddr, relay.ConnectedAt, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	relay = relay.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	relay.Id = int32(insertedId)

	relay.ResetMark()
	return relay, nil

}

func (d *Relay) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `relay` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *Relay) Update(ctx context.Context, relay *entity.Relay, opt ...ExecOption) error {
	if !relay.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := relay.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `relay` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, relay.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	relay.ResetMark()
	return nil

}

type SerialNumber struct {
	conn *sql.DB
}

type SerialNumberInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int64) (*entity.SerialNumber, error)
	SelectSerialNumber(ctx context.Context, serialNumber []byte) (*entity.SerialNumber, error)
	Create(ctx context.Context, serialNumber *entity.SerialNumber, opt ...ExecOption) (*entity.SerialNumber, error)
	Update(ctx context.Context, serialNumber *entity.SerialNumber, opt ...ExecOption) error
	Delete(ctx context.Context, id int64, opt ...ExecOption) error
}

var _ SerialNumberInterface = &SerialNumber{}

func NewSerialNumber(conn *sql.DB) *SerialNumber {
	return &SerialNumber{
		conn: conn,
	}
}

func (d *SerialNumber) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *SerialNumber) Select(ctx context.Context, id int64) (*entity.SerialNumber, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `serial_number` WHERE `id` = ?", id)

	v := &entity.SerialNumber{}
	if err := row.Scan(&v.Id, &v.SerialNumber); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil

}

func (d *SerialNumber) SelectSerialNumber(ctx context.Context, serialNumber []byte) (*entity.SerialNumber, error) {
	row := d.conn.QueryRowContext(
		ctx,
		"SELECT `id`, `serial_number` FROM `serial_number` WHERE `serial_number` = ?",
		serialNumber,
	)
	v := &entity.SerialNumber{}
	if err := row.Scan(&v.Id, &v.SerialNumber); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil

}

func (d *SerialNumber) Create(ctx context.Context, serialNumber *entity.SerialNumber, opt ...ExecOption) (*entity.SerialNumber, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `serial_number` (`serial_number`) VALUES (?)",
		serialNumber.SerialNumber,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	serialNumber = serialNumber.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	serialNumber.Id = int64(insertedId)

	serialNumber.ResetMark()
	return serialNumber, nil

}

func (d *SerialNumber) Delete(ctx context.Context, id int64, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `serial_number` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *SerialNumber) Update(ctx context.Context, serialNumber *entity.SerialNumber, opt ...ExecOption) error {
	if !serialNumber.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := serialNumber.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}

	query := fmt.Sprintf("UPDATE `serial_number` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, serialNumber.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	serialNumber.ResetMark()
	return nil

}

type SignedCertificate struct {
	conn *sql.DB

	serialNumber *SerialNumber
}

type SignedCertificateInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*entity.SignedCertificate, error)
	ListSerialNumber(ctx context.Context, serialNumberId int64, opt ...ListOption) ([]*entity.SignedCertificate, error)
	ListAll(ctx context.Context, opt ...ListOption) ([]*entity.SignedCertificate, error)
	Create(ctx context.Context, signedCertificate *entity.SignedCertificate, opt ...ExecOption) (*entity.SignedCertificate, error)
	Update(ctx context.Context, signedCertificate *entity.SignedCertificate, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ SignedCertificateInterface = &SignedCertificate{}

func NewSignedCertificate(conn *sql.DB) *SignedCertificate {
	return &SignedCertificate{
		conn:         conn,
		serialNumber: NewSerialNumber(conn),
	}
}

func (d *SignedCertificate) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *SignedCertificate) Select(ctx context.Context, id int32) (*entity.SignedCertificate, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `signed_certificate` WHERE `id` = ?", id)

	v := &entity.SignedCertificate{}
	if err := row.Scan(&v.Id, &v.Certificate, &v.SerialNumberId, &v.P12, &v.Agent, &v.Comment, &v.IssuedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.serialNumber.Select(ctx, v.SerialNumberId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.SerialNumber = rel
	}

	v.ResetMark()
	return v, nil

}

func (d *SignedCertificate) ListSerialNumber(ctx context.Context, serialNumberId int64, opt ...ListOption) ([]*entity.SignedCertificate, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `certificate`, `serial_number_id`, `p12`, `agent`, `comment`, `issued_at` FROM `signed_certificate` WHERE `serial_number_id` = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		serialNumberId,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.SignedCertificate, 0)
	for rows.Next() {
		r := &entity.SignedCertificate{}
		if err := rows.Scan(&r.Id, &r.Certificate, &r.SerialNumberId, &r.P12, &r.Agent, &r.Comment, &r.IssuedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.serialNumber.Select(ctx, v.SerialNumberId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.SerialNumber = rel
			}

		}
	}

	return res, nil

}

func (d *SignedCertificate) ListAll(ctx context.Context, opt ...ListOption) ([]*entity.SignedCertificate, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `certificate`, `serial_number_id`, `p12`, `agent`, `comment`, `issued_at` FROM `signed_certificate`"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.SignedCertificate, 0)
	for rows.Next() {
		r := &entity.SignedCertificate{}
		if err := rows.Scan(&r.Id, &r.Certificate, &r.SerialNumberId, &r.P12, &r.Agent, &r.Comment, &r.IssuedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.serialNumber.Select(ctx, v.SerialNumberId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.SerialNumber = rel
			}

		}
	}

	return res, nil

}

func (d *SignedCertificate) Create(ctx context.Context, signedCertificate *entity.SignedCertificate, opt ...ExecOption) (*entity.SignedCertificate, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `signed_certificate` (`certificate`, `serial_number_id`, `p12`, `agent`, `comment`, `issued_at`) VALUES (?, ?, ?, ?, ?, ?)",
		signedCertificate.Certificate, signedCertificate.SerialNumberId, signedCertificate.P12, signedCertificate.Agent, signedCertificate.Comment, signedCertificate.IssuedAt,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	signedCertificate = signedCertificate.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	signedCertificate.Id = int32(insertedId)

	signedCertificate.ResetMark()
	return signedCertificate, nil

}

func (d *SignedCertificate) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `signed_certificate` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *SignedCertificate) Update(ctx context.Context, signedCertificate *entity.SignedCertificate, opt ...ExecOption) error {
	if !signedCertificate.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := signedCertificate.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}

	query := fmt.Sprintf("UPDATE `signed_certificate` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, signedCertificate.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	signedCertificate.ResetMark()
	return nil

}

type RevokedCertificate struct {
	conn *sql.DB
}

type RevokedCertificateInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*entity.RevokedCertificate, error)
	ListSerialNumber(ctx context.Context, serialNumber []byte, opt ...ListOption) ([]*entity.RevokedCertificate, error)
	ListAll(ctx context.Context, opt ...ListOption) ([]*entity.RevokedCertificate, error)
	Create(ctx context.Context, revokedCertificate *entity.RevokedCertificate, opt ...ExecOption) (*entity.RevokedCertificate, error)
	Update(ctx context.Context, revokedCertificate *entity.RevokedCertificate, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ RevokedCertificateInterface = &RevokedCertificate{}

func NewRevokedCertificate(conn *sql.DB) *RevokedCertificate {
	return &RevokedCertificate{
		conn: conn,
	}
}

func (d *RevokedCertificate) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *RevokedCertificate) Select(ctx context.Context, id int32) (*entity.RevokedCertificate, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `revoked_certificate` WHERE `id` = ?", id)

	v := &entity.RevokedCertificate{}
	if err := row.Scan(&v.Id, &v.CommonName, &v.SerialNumber, &v.Agent, &v.Comment, &v.RevokedAt, &v.IssuedAt, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil

}

func (d *RevokedCertificate) ListSerialNumber(ctx context.Context, serialNumber []byte, opt ...ListOption) ([]*entity.RevokedCertificate, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `common_name`, `serial_number`, `agent`, `comment`, `revoked_at`, `issued_at`, `created_at`, `updated_at` FROM `revoked_certificate` WHERE `serial_number` = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		serialNumber,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.RevokedCertificate, 0)
	for rows.Next() {
		r := &entity.RevokedCertificate{}
		if err := rows.Scan(&r.Id, &r.CommonName, &r.SerialNumber, &r.Agent, &r.Comment, &r.RevokedAt, &r.IssuedAt, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil

}

func (d *RevokedCertificate) ListAll(ctx context.Context, opt ...ListOption) ([]*entity.RevokedCertificate, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `common_name`, `serial_number`, `agent`, `comment`, `revoked_at`, `issued_at`, `created_at`, `updated_at` FROM `revoked_certificate`"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.RevokedCertificate, 0)
	for rows.Next() {
		r := &entity.RevokedCertificate{}
		if err := rows.Scan(&r.Id, &r.CommonName, &r.SerialNumber, &r.Agent, &r.Comment, &r.RevokedAt, &r.IssuedAt, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil

}

func (d *RevokedCertificate) Create(ctx context.Context, revokedCertificate *entity.RevokedCertificate, opt ...ExecOption) (*entity.RevokedCertificate, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `revoked_certificate` (`common_name`, `serial_number`, `agent`, `comment`, `revoked_at`, `issued_at`, `created_at`) VALUES (?, ?, ?, ?, ?, ?, ?)",
		revokedCertificate.CommonName, revokedCertificate.SerialNumber, revokedCertificate.Agent, revokedCertificate.Comment, revokedCertificate.RevokedAt, revokedCertificate.IssuedAt, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	revokedCertificate = revokedCertificate.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	revokedCertificate.Id = int32(insertedId)

	revokedCertificate.ResetMark()
	return revokedCertificate, nil

}

func (d *RevokedCertificate) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `revoked_certificate` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *RevokedCertificate) Update(ctx context.Context, revokedCertificate *entity.RevokedCertificate, opt ...ExecOption) error {
	if !revokedCertificate.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := revokedCertificate.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `revoked_certificate` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, revokedCertificate.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	revokedCertificate.ResetMark()
	return nil

}

type Node struct {
	conn *sql.DB
}

type NodeInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*entity.Node, error)
	ListAll(ctx context.Context, opt ...ListOption) ([]*entity.Node, error)
	ListHostname(ctx context.Context, hostname string, opt ...ListOption) ([]*entity.Node, error)
	Create(ctx context.Context, node *entity.Node, opt ...ExecOption) (*entity.Node, error)
	Update(ctx context.Context, node *entity.Node, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ NodeInterface = &Node{}

func NewNode(conn *sql.DB) *Node {
	return &Node{
		conn: conn,
	}
}

func (d *Node) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if err := fn(tx); err != nil {
		rErr := tx.Rollback()
		return xerrors.Errorf("%v: %w", rErr, err)
	}

	err = tx.Commit()
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return nil

}

func (d *Node) Select(ctx context.Context, id int32) (*entity.Node, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `node` WHERE `id` = ?", id)

	v := &entity.Node{}
	if err := row.Scan(&v.Id, &v.Hostname, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil

}

func (d *Node) ListAll(ctx context.Context, opt ...ListOption) ([]*entity.Node, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `hostname`, `created_at`, `updated_at` FROM `node`"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.Node, 0)
	for rows.Next() {
		r := &entity.Node{}
		if err := rows.Scan(&r.Id, &r.Hostname, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil

}

func (d *Node) ListHostname(ctx context.Context, hostname string, opt ...ListOption) ([]*entity.Node, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `hostname`, `created_at`, `updated_at` FROM `node` WHERE `hostname` = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		hostname,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*entity.Node, 0)
	for rows.Next() {
		r := &entity.Node{}
		if err := rows.Scan(&r.Id, &r.Hostname, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil

}

func (d *Node) Create(ctx context.Context, node *entity.Node, opt ...ExecOption) (*entity.Node, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `node` (`hostname`, `created_at`) VALUES (?, ?)",
		node.Hostname, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	node = node.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	node.Id = int32(insertedId)

	node.ResetMark()
	return node, nil

}

func (d *Node) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `node` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil

}

func (d *Node) Update(ctx context.Context, node *entity.Node, opt ...ExecOption) error {
	if !node.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := node.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `node` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, node.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	node.ResetMark()
	return nil

}
