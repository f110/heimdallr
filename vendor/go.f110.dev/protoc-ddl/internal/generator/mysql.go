package generator

import (
	"bytes"
	"fmt"
	"strconv"
	"strings"

	"go.f110.dev/protoc-ddl/internal/schema"
)

const (
	MySQLGeneratorVersion = "v0.1"
)

var (
	DataTypeMap = map[string]string{
		"TYPE_FLOAT":         "FLOAT",
		"TYPE_DOUBLE":        "DOUBLE",
		"TYPE_INT32":         "INTEGER",
		"TYPE_INT64":         "BIGINT",
		"TYPE_UINT32":        "INTEGER UNSIGNED",
		"TYPE_UINT64":        "BIGINT UNSIGNED",
		"TYPE_SINT32":        "INTEGER",
		"TYPE_SINT64":        "BIGINT",
		"TYPE_FIXED32":       "INTEGER UNSIGNED",
		"TYPE_FIXED64":       "BIGINT UNSIGNED",
		"TYPE_SFIXED32":      "INTEGER",
		"TYPE_SFIXED64":      "BIGINT",
		"TYPE_BOOL":          "TINYINT(1)",
		"TYPE_BYTES":         "BLOB",
		"TYPE_STRING":        "VARCHAR",
		schema.TimestampType: "DATETIME",
	}
)

type MySQLGenerator struct{}

func (m MySQLGenerator) Generate(writer *bytes.Buffer, tables *schema.Messages) {
	writer.WriteString(fmt.Sprintf("-- Generated by MySQL Generator (%s)\n\n", MySQLGeneratorVersion))
	writer.WriteString("SET foreign_key_checks=0;\n\n")
	writer.WriteString("")

	tables.Each(func(table *schema.Message) {
		writer.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS `%s`;\n", table.TableName))
		writer.WriteString(fmt.Sprintf("CREATE TABLE `%s` (\n", table.TableName))

		colLine := make([]string, 0)
		colLine = append(colLine, m.generateColumnDefinition(table)...)
		colLine = append(colLine, m.generateIndexDefinition(table)...)

		if len(table.PrimaryKeys) > 0 {
			primaryKeys := make([]string, 0, len(table.PrimaryKeys))
			for _, p := range table.PrimaryKeys {
				primaryKeys = append(primaryKeys, fmt.Sprintf("`%s`", p.Name))
			}
			colLine = append(colLine, fmt.Sprintf("\tPRIMARY KEY(%s)", strings.Join(primaryKeys, ",")))
		}

		writer.WriteString(strings.Join(colLine, ",\n"))
		writer.WriteString("\n")
		engine := "InnoDB"
		if table.Engine != "" {
			engine = table.Engine
		}
		writer.WriteString(fmt.Sprintf(") Engine=%s;\n\n", engine))
	})

	writer.WriteString("SET foreign_key_checks=1;\n")
}

func (m MySQLGenerator) generateColumnDefinition(table *schema.Message) []string {
	colLine := make([]string, 0)

	table.Fields.Each(func(col *schema.Field) {
		nullConstraint := "NOT NULL"
		if col.Null {
			nullConstraint = "NULL"
		}
		columnOpt := ""
		if col.Sequence {
			columnOpt += " AUTO_INCREMENT"
		}
		if col.Default != "" {
			switch col.Type {
			case "TYPE_INT32", "TYPE_INT64", "TYPE_UINT32", "TYPE_UINT64", "TYPE_SINT32", "TYPE_SINT64":
				columnOpt += fmt.Sprintf(" DEFAULT %s", col.Default)
			default:
				columnOpt += fmt.Sprintf(" DEFAULT \"%s\"", col.Default)
			}
		}

		colLine = append(colLine, fmt.Sprintf("\t`%s` %s %s%s", col.Name, m.columnType(col), nullConstraint, columnOpt))
	})

	return colLine
}

func (MySQLGenerator) generateIndexDefinition(table *schema.Message) []string {
	colLine := make([]string, 0)

	for _, i := range table.Indexes {
		idxName := i.Name
		if idxName == "" {
			colNames := make([]string, 0, i.Columns.Len())
			i.Columns.Each(func(f *schema.Field) {
				colNames = append(colNames, f.Name)
			})
			idxName = "idx_" + strings.Join(colNames, "_")
		}
		cols := make([]string, 0, i.Columns.Len())
		i.Columns.Each(func(f *schema.Field) {
			cols = append(cols, fmt.Sprintf("`%s`", f.Name))
		})
		indexType := "INDEX"
		if i.Unique {
			indexType = "UNIQUE"
		}
		colLine = append(colLine, fmt.Sprintf("\t%s `%s` (%s)", indexType, idxName, strings.Join(cols, ", ")))
	}

	return colLine
}

func (MySQLGenerator) columnType(col *schema.Field) string {
	columnType := ""
	if t, ok := DataTypeMap[col.Type]; ok {
		switch col.Type {
		case "TYPE_STRING":
			switch col.OptionalType {
			case "text":
				columnType = "TEXT"
			default:
				if col.Size == 0 {
					col.Size = 255
				}
				columnType = t + "(" + strconv.Itoa(col.Size) + ")"
			}
		case "TYPE_BYTES":
			if col.Size > 0 && col.Size < 255 {
				columnType = fmt.Sprintf("VARBINARY(%d)", col.Size)
			} else {
				switch col.OptionalType {
				case "tiny":
					columnType = "TINYBLOB"
				case "blob":
					columnType = "BLOB"
				case "medium":
					columnType = "MEDIUMBLOB"
				case "long":
					columnType = "LONGBLOB"
				default:
					columnType = t
				}
			}
		default:
			columnType = t
		}
		return columnType
	}

	return ""
}
